/*! OnfidoIDV SDK 9.0.0 */
"use strict";(self.webpackChunkOnfido=self.webpackChunkOnfido||[]).push([["activeVideo"],{"./components/ActiveVideo/ActiveVideo.tsx":function(e,t,n){n.r(t),n.d(t,{default:function(){return z}});var r=n("../node_modules/@babel/runtime-corejs3/helpers/esm/slicedToArray.js"),a=n("../node_modules/preact/dist/preact.module.js"),s=n("../node_modules/preact/compat/dist/compat.module.js"),o=n("../node_modules/preact/hooks/dist/hooks.module.js"),i=n("../node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js"),l={"./src/assets/onfido.svg":
/*!*******************************!*\
  !*** ./src/assets/onfido.svg ***!
  \*******************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>l});var r,a,s,o=n(/*! react */"./node_modules/preact/compat/dist/compat.module.js");function i(){return i=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},i.apply(this,arguments)}const l=e=>o.createElement("svg",i({width:144,height:32,fill:"none",xmlns:"http://www.w3.org/2000/svg"},e),r||(r=o.createElement("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M46.908 8.307c.204-.205.454-.307.74-.307s.536.107.74.307c.204.204.306.454.306.74 0 .292-.102.537-.306.742a1.012 1.012 0 0 1-.74.306c-.29 0-.536-.102-.74-.306a1.016 1.016 0 0 1-.306-.741c0-.292.102-.537.306-.741Zm1.429 3.373h-1.373v8.125h1.373V11.68Zm5.484-.225c1.143 0 2.23.495 3.01 1.364V8.383h1.373v11.422h-1.372v-1.14a4.046 4.046 0 0 1-3.01 1.365c-2.271 0-4.118-1.926-4.118-4.287 0-2.361 1.847-4.288 4.117-4.288Zm.087 7.277c1.587 0 2.883-1.339 2.883-2.99 0-1.65-1.296-2.99-2.883-2.99s-2.883 1.34-2.883 2.99c0 1.651 1.291 2.99 2.883 2.99Zm5.53-2.99a4.29 4.29 0 0 1 4.281-4.287A4.29 4.29 0 0 1 68 15.743a4.293 4.293 0 0 1-4.28 4.287 4.293 4.293 0 0 1-4.281-4.287Zm4.281 2.99c1.587 0 2.883-1.339 2.883-2.99 0-1.65-1.29-2.99-2.883-2.99-1.586 0-2.882 1.34-2.882 2.99 0 1.651 1.29 2.99 2.882 2.99Zm-20.663-8.657v1.605h2.322v1.272h-2.322v6.859h-1.372v-6.854h-1.52v-1.272h1.52v-1.636c0-1.073.872-1.947 1.944-1.947h1.75v1.252h-1.602a.72.72 0 0 0-.72.72Zm-6.944 1.38c-1.199 0-2.097.485-2.617 1.4V11.68h-1.373v8.125h1.373V15.58c0-.853.214-1.543.638-2.054.423-.506 1.01-.762 1.755-.762.622 0 1.127.204 1.49.608.362.41.55 1.033.55 1.85v4.58h1.373v-4.84c0-1.16-.28-2.05-.837-2.632-.54-.563-1.377-.874-2.352-.874ZM22.25 15.743a4.29 4.29 0 0 1 4.28-4.288 4.29 4.29 0 0 1 4.281 4.288 4.29 4.29 0 0 1-4.28 4.287 4.293 4.293 0 0 1-4.281-4.287Zm4.286 2.99c1.586 0 2.882-1.34 2.882-2.99 0-1.651-1.296-2.99-2.882-2.99-1.587 0-2.883 1.339-2.883 2.99 0 1.65 1.29 2.99 2.883 2.99ZM12.16 15.52a2.663 2.663 0 0 1-2.66 2.666 2.663 2.663 0 0 1-2.658-2.666A2.663 2.663 0 0 1 9.5 12.854a2.663 2.663 0 0 1 2.66 2.666Zm-6.564 5.522c.145-.1.29-.2.445-.291a7.077 7.077 0 0 1 7.323.01c.085.05.085.17.005.226l-.064.04c-.12.078-.243.158-.366.23-.795.476-1.644.882-2.53 1.198-.594.215-1.214.39-1.859.536a1.975 1.975 0 0 1-1.71-.426 16.47 16.47 0 0 1-1.274-1.223.199.199 0 0 1 .03-.3ZM12.96 10.287c.154-.09.299-.19.444-.29.1-.07.115-.211.03-.301a16.44 16.44 0 0 0-1.275-1.223 1.975 1.975 0 0 0-1.71-.426 15.38 15.38 0 0 0-1.859.536c-.885.316-1.734.722-2.53 1.198-.122.072-.245.152-.365.23l-.064.04a.134.134 0 0 0 .005.226 7.078 7.078 0 0 0 7.323.01ZM4.28 12.051a6.79 6.79 0 0 0-.29-.446.197.197 0 0 0-.3-.03c-.42.396-.83.822-1.22 1.278-.399.471-.559 1.107-.424 1.714.145.646.32 1.268.535 1.864a14.335 14.335 0 0 0 1.423 2.903l.041.064c.055.08.175.08.225-.005a7.126 7.126 0 0 0 .01-7.342Zm10.727 7.382c-.1-.145-.2-.29-.29-.446a7.126 7.126 0 0 1 .01-7.342.133.133 0 0 1 .226-.005l.04.064c.078.12.157.244.23.367.474.797.88 1.649 1.194 2.536.215.596.39 1.218.535 1.864a1.987 1.987 0 0 1-.425 1.714c-.39.456-.8.882-1.22 1.278a.197.197 0 0 1-.3-.03Z",fill:"#fff"})),a||(a=o.createElement("path",{d:"M89.32 17.98c-.1.03-.23.05-.4.05-.25 0-.48-.09-.66-.45l-.7-1.35c.81-.3 1.33-.96 1.33-1.94 0-1.39-.95-2.15-2.41-2.15h-2.66V19h1.22v-2.59h1.2l.81 1.53c.35.66.72 1.11 1.68 1.11.27 0 .49-.04.66-.09l-.07-.98Zm-4.28-4.82h1.44c.77 0 1.17.47 1.17 1.14 0 .67-.4 1.14-1.17 1.14h-1.44v-2.28Zm9.494 3.42c0-1.53-.84-2.53-2.29-2.53-1.4 0-2.42 1.03-2.42 2.51 0 1.45.91 2.49 2.41 2.49 1.43 0 2.11-.79 2.28-1.65h-1.15c-.08.3-.35.68-1.08.68-.7 0-1.17-.45-1.26-1.25h3.51v-.25Zm-2.28-1.59c.61 0 1.02.34 1.12 1.09h-2.33c.13-.72.6-1.09 1.21-1.09Zm7.889 2.98c-.11.04-.17.05-.25.05-.15 0-.25-.11-.25-.3V16c0-1.22-.75-1.95-2.14-1.95-1.25 0-2.1.61-2.18 1.71h1.12c.05-.48.41-.76.99-.76.68 0 1.02.36 1.02.93v.25h-.76c-1.34 0-2.49.38-2.49 1.54 0 .79.57 1.33 1.66 1.33 1.05 0 1.48-.5 1.64-.8.14.53.53.8 1.06.8.25 0 .47-.04.66-.09l-.08-.99Zm-2.96.17c-.54 0-.79-.2-.79-.55 0-.46.44-.7 1.24-.7h.82v.32c0 .42-.47.93-1.27.93Zm5.468-.17c-.11.04-.16.05-.24.05-.15 0-.26-.11-.26-.3V11.9h-1.21v5.92c0 .78.39 1.23 1.12 1.23.27 0 .48-.04.67-.09l-.08-.99Zm3.243 1.03h1.22v-6.86h-1.22V19Zm5.984-7.1v2.89c-.27-.44-.75-.74-1.49-.74-1.36 0-2.23 1.06-2.23 2.56 0 1.52.89 2.44 2.16 2.44.75 0 1.28-.34 1.57-.79l.03.74h1.18v-7.1h-1.22Zm-1.29 6.12c-.73 0-1.2-.56-1.2-1.44 0-.9.49-1.5 1.21-1.5.84 0 1.28.7 1.28 1.33v.29c0 .6-.43 1.32-1.29 1.32Zm8.187-1.44c0-1.53-.84-2.53-2.29-2.53-1.4 0-2.42 1.03-2.42 2.51 0 1.45.91 2.49 2.41 2.49 1.43 0 2.11-.79 2.28-1.65h-1.15c-.08.3-.35.68-1.08.68-.7 0-1.17-.45-1.26-1.25h3.51v-.25Zm-2.28-1.59c.61 0 1.02.34 1.12 1.09h-2.33c.13-.72.6-1.09 1.21-1.09Zm6.009-.94c-.74 0-1.25.31-1.54.76l-.04-.71h-1.17V19h1.22v-2.78c0-.67.43-1.12 1.09-1.12.62 0 .94.41.94 1.1V19h1.23v-3.08c0-1.13-.64-1.87-1.73-1.87Zm5.604 3.25c0 .54-.23.76-.63.76-.41 0-.61-.24-.61-.76v-2.22h1.73v-.98h-1.73v-1.45h-1.15v1.45h-.8v.99h.73v2.18c0 1.16.68 1.77 1.78 1.77 1.14 0 1.76-.64 1.76-1.74h-1.08Zm3.249-4.79c0-.44-.35-.77-.8-.77-.45 0-.8.33-.8.77 0 .46.35.78.8.78.45 0 .8-.32.8-.78Zm-1.42 6.49h1.22v-4.9h-1.22V19Zm5.2-1.7c0 .54-.23.76-.63.76-.41 0-.61-.24-.61-.76v-2.22h1.73v-.98h-1.73v-1.45h-1.15v1.45h-.8v.99h.73v2.18c0 1.16.68 1.77 1.78 1.77 1.14 0 1.76-.64 1.76-1.74h-1.08Zm4.872-3.2-1.05 3.19c-.05.14-.09.32-.13.55h-.03c-.05-.23-.09-.4-.14-.55l-1.04-3.19h-1.33l1.89 5.02-.08.21c-.2.57-.56.7-1.01.7-.19 0-.32-.04-.47-.1l-.08 1.03c.18.06.49.1.79.1 1.01 0 1.51-.47 1.97-1.69l.14-.37 1.81-4.9h-1.24Z",fill:"#fff"})),s||(s=o.createElement("path",{stroke:"#fff",strokeWidth:.7,d:"M75.35 6v19"})))},"./node_modules/@vladmandic/human/dist/human.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vladmandic/human/dist/human.esm.js ***!
  \**********************************************************/(e,t,n)=>{var r="/index.js";n.r(t),n.d(t,{Human:()=>V5,default:()=>V5,defaults:()=>m,draw:()=>q2,env:()=>HZ,match:()=>R5,models:()=>UY});var a=Object.defineProperty,s=(e,t)=>{for(var n in t)a(e,n,{get:t[n],enumerable:!0})},o=(e,t,n)=>(((e,t,n)=>{t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n})(e,"symbol"!=typeof t?t+"":t,n),n),i=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot "+n)},l=(e,t,n)=>(i(e,t,"read from private field"),n?n.call(e):t.get(e)),u=(e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,n)},c=(e,t,n,r)=>(i(e,t,"write to private field"),r?r.call(e,n):t.set(e,n),n);function d(...e){const t=new Date,n=`${t.getHours().toString().padStart(2,"0")}:${t.getMinutes().toString().padStart(2,"0")}:${t.getSeconds().toString().padStart(2,"0")}.${t.getMilliseconds().toString().padStart(3,"0")}`;e&&console.log(n,"Human:",...e)}var h=()=>"undefined"!=typeof performance?performance.now():parseInt((Number(process.hrtime.bigint())/1e3/1e3).toString());function p(e,t,n="config",r=[]){for(const a of Object.keys(t))if("object"==typeof t[a])p(e[a],t[a],a,r);else{const s=e&&void 0!==e[a];s||r.push({reason:"unknown property",where:`${n}.${a} = ${t[a]}`});const o=e&&typeof e[a]==typeof t[a];s&&!o&&r.push({reason:"property type mismatch",where:`${n}.${a} = ${t[a]}`,expected:typeof e[a]})}return t.debug&&"config"===n&&r.length>0&&d("invalid configuration",r),r}function f(...e){const t=e=>e&&"object"==typeof e;return e.reduce(((e,n)=>(Object.keys(n||{}).forEach((r=>{const a=e[r],s=n[r];Array.isArray(a)&&Array.isArray(s)?e[r]=a.concat(...s):t(a)&&t(s)?e[r]=f(a,s):e[r]=s})),e)),{})}var m={backend:"",modelBasePath:"",cacheModels:!0,wasmPath:"",wasmPlatformFetch:!1,debug:!1,async:!0,warmup:"full",cacheSensitivity:.7,skipAllowed:!1,deallocate:!1,filter:{enabled:!0,equalization:!1,width:0,height:0,flip:!1,return:!0,brightness:0,contrast:0,sharpness:0,blur:0,saturation:0,hue:0,negative:!1,sepia:!1,vintage:!1,kodachrome:!1,technicolor:!1,polaroid:!1,pixelate:0},gesture:{enabled:!0},face:{enabled:!0,detector:{modelPath:"blazeface.json",rotation:!0,maxDetected:1,skipFrames:99,skipTime:2500,minConfidence:.2,iouThreshold:.1,mask:!1,return:!1},mesh:{enabled:!0,modelPath:"facemesh.json",keepInvalid:!1},attention:{enabled:!1,modelPath:"facemesh-attention.json"},iris:{enabled:!0,modelPath:"iris.json"},emotion:{enabled:!0,minConfidence:.1,skipFrames:99,skipTime:1500,modelPath:"emotion.json"},description:{enabled:!0,modelPath:"faceres.json",skipFrames:99,skipTime:3e3,minConfidence:.1},antispoof:{enabled:!1,skipFrames:99,skipTime:4e3,modelPath:"antispoof.json"},liveness:{enabled:!1,skipFrames:99,skipTime:4e3,modelPath:"liveness.json"}},body:{enabled:!0,modelPath:"movenet-lightning.json",maxDetected:-1,minConfidence:.3,skipFrames:1,skipTime:200},hand:{enabled:!0,rotation:!0,skipFrames:99,skipTime:1e3,minConfidence:.5,iouThreshold:.2,maxDetected:-1,landmarks:!0,detector:{modelPath:"handtrack.json"},skeleton:{modelPath:"handlandmark-full.json"}},object:{enabled:!1,modelPath:"mb3-centernet.json",minConfidence:.2,iouThreshold:.4,maxDetected:10,skipFrames:99,skipTime:2e3},segmentation:{enabled:!1,modelPath:"selfie.json",blur:8}},A={};s(A,{Abs:()=>Je,Acos:()=>Qe,Acosh:()=>et,AdadeltaOptimizer:()=>nf,AdagradOptimizer:()=>rf,AdamOptimizer:()=>af,AdamaxOptimizer:()=>sf,Add:()=>tt,AddN:()=>nt,All:()=>rt,Any:()=>at,ArgMax:()=>st,ArgMin:()=>ot,Asin:()=>it,Asinh:()=>lt,Atan:()=>ut,Atan2:()=>dt,Atanh:()=>ct,AvgPool:()=>ht,AvgPool3D:()=>ft,AvgPool3DGrad:()=>mt,AvgPoolGrad:()=>pt,BackendWasm:()=>TG,BatchMatMul:()=>At,BatchToSpaceND:()=>gt,Bincount:()=>yt,BroadcastArgs:()=>bt,BroadcastTo:()=>xt,Callback:()=>yS,CallbackList:()=>mx,Cast:()=>vt,Ceil:()=>wt,ClipByValue:()=>kt,Complex:()=>St,ComplexAbs:()=>It,Concat:()=>Ct,Conv2D:()=>Et,Conv2DBackpropFilter:()=>Nt,Conv2DBackpropInput:()=>Tt,Conv3D:()=>Rt,Conv3DBackpropFilterV2:()=>_t,Conv3DBackpropInputV2:()=>Mt,Cos:()=>$t,Cosh:()=>Ft,CropAndResize:()=>zt,Cumprod:()=>Ot,Cumsum:()=>Dt,CustomCallback:()=>yx,DataStorage:()=>q,DenseBincount:()=>Pt,DepthToSpace:()=>Lt,DepthwiseConv2dNative:()=>Bt,DepthwiseConv2dNativeBackpropFilter:()=>Wt,DepthwiseConv2dNativeBackpropInput:()=>Ut,Diag:()=>Vt,Dilation2D:()=>jt,Dilation2DBackpropFilter:()=>Ht,Dilation2DBackpropInput:()=>Gt,ENV:()=>Ke,EarlyStopping:()=>vS,Einsum:()=>Xt,Elu:()=>Kt,EluGrad:()=>Zt,Environment:()=>Ge,Equal:()=>Jt,Erf:()=>Yt,Exp:()=>Qt,ExpandDims:()=>en,Expm1:()=>tn,FFT:()=>nn,Fill:()=>rn,FlipLeftRight:()=>an,Floor:()=>sn,FloorDiv:()=>on,FromPixels:()=>aa,FusedBatchNorm:()=>ln,FusedConv2D:()=>ia,FusedDepthwiseConv2D:()=>la,GPGPUContext:()=>RO,GatherNd:()=>cn,GatherV2:()=>un,GraphModel:()=>nC,Greater:()=>dn,GreaterEqual:()=>hn,History:()=>gx,IFFT:()=>fn,Identity:()=>pn,Imag:()=>mn,InputSpec:()=>Ay,IsFinite:()=>An,IsInf:()=>gn,IsNan:()=>yn,KernelBackend:()=>X,LRN:()=>_n,LRNGrad:()=>Mn,LayerVariable:()=>py,LayersModel:()=>vb,LeakyRelu:()=>xn,Less:()=>bn,LessEqual:()=>vn,LinSpace:()=>wn,Log:()=>kn,Log1p:()=>Sn,LogSoftmax:()=>Tn,LogicalAnd:()=>In,LogicalNot:()=>Cn,LogicalOr:()=>En,LogicalXor:()=>Nn,LowerBound:()=>Rn,MathBackendWebGL:()=>$D,Max:()=>$n,MaxPool:()=>On,MaxPool3D:()=>zn,MaxPool3DGrad:()=>Pn,MaxPoolGrad:()=>Dn,MaxPoolWithArgmax:()=>Ln,Maximum:()=>Fn,Mean:()=>Bn,Min:()=>Wn,Minimum:()=>Un,MirrorPad:()=>Vn,Mod:()=>jn,MomentumOptimizer:()=>lf,Multinomial:()=>Gn,Multiply:()=>Hn,Neg:()=>qn,NonMaxSuppressionV3:()=>Kn,NonMaxSuppressionV4:()=>Zn,NonMaxSuppressionV5:()=>Yn,NotEqual:()=>Xn,OP_SCOPE_SUFFIX:()=>Ps,OneHot:()=>Qn,OnesLike:()=>Jn,Optimizer:()=>tf,OptimizerConstructors:()=>cf,Pack:()=>er,PadV2:()=>tr,Pool:()=>nr,Pow:()=>rr,Prelu:()=>ar,Prod:()=>sr,RMSPropOptimizer:()=>uf,RNN:()=>Nv,Range:()=>or,Rank:()=>ns,Real:()=>ir,RealDiv:()=>qt,Reciprocal:()=>lr,Reduction:()=>Tp,Relu:()=>ur,Relu6:()=>mr,Reshape:()=>cr,ResizeBilinear:()=>pr,ResizeBilinearGrad:()=>fr,ResizeNearestNeighbor:()=>dr,ResizeNearestNeighborGrad:()=>hr,Reverse:()=>Ar,RotateWithOffset:()=>sa,Round:()=>gr,Rsqrt:()=>yr,SGDOptimizer:()=>of,ScatterNd:()=>xr,SearchSorted:()=>br,Select:()=>vr,Selu:()=>wr,Sequential:()=>Ib,Sigmoid:()=>Er,Sign:()=>Cr,Sin:()=>Sr,Sinh:()=>Ir,Slice:()=>kr,Softmax:()=>$r,Softplus:()=>Nr,SpaceToBatchND:()=>_r,SparseFillEmptyRows:()=>Fr,SparseReshape:()=>Or,SparseSegmentMean:()=>Dr,SparseSegmentSum:()=>zr,SparseToDense:()=>Pr,SplitV:()=>Mr,Sqrt:()=>Tr,Square:()=>Br,SquaredDifference:()=>Lr,Step:()=>ra,StridedSlice:()=>Wr,StringNGrams:()=>Ur,StringSplit:()=>Vr,StringToHashBucketFast:()=>jr,Sub:()=>Gr,Sum:()=>Rr,SymbolicTensor:()=>gy,Tan:()=>Hr,Tanh:()=>qr,Tensor:()=>Qa,TensorBuffer:()=>Za,Tile:()=>Xr,TopK:()=>Kr,Transform:()=>Zr,Transpose:()=>Yr,Unique:()=>Jr,Unpack:()=>Qr,UnsortedSegmentSum:()=>ea,UpperBound:()=>ta,Variable:()=>ts,ZerosLike:()=>na,_FusedMatMul:()=>oa,abs:()=>Pl,acos:()=>Ll,acosh:()=>Bl,add:()=>Fl,addN:()=>Wl,all:()=>Ul,any:()=>Vl,argMax:()=>jl,argMin:()=>Gl,asin:()=>Hl,asinh:()=>ql,atan:()=>Xl,atan2:()=>Kl,atanh:()=>Zl,avgPool:()=>hu,avgPool3d:()=>pu,backend:()=>Ni,backend_util:()=>ff,basicLSTMCell:()=>yu,batchNorm:()=>bu,batchNorm2d:()=>vu,batchNorm3d:()=>wu,batchNorm4d:()=>ku,batchToSpaceND:()=>xu,bincount:()=>Su,booleanMaskAsync:()=>Mh,broadcastArgs:()=>Iu,broadcastTo:()=>Cu,broadcast_util:()=>Oi,browser:()=>Bi,buffer:()=>Do,callbacks:()=>IS,cast:()=>zo,ceil:()=>Eu,clipByValue:()=>Nu,clone:()=>Po,complex:()=>Bs,concat:()=>fu,concat1d:()=>Tu,concat2d:()=>Ru,concat3d:()=>_u,concat4d:()=>Mu,constraints:()=>My,conv1d:()=>Fu,conv2d:()=>$u,conv2dTranspose:()=>Du,conv3d:()=>zu,conv3dTranspose:()=>Lu,copyRegisteredKernels:()=>ba,cos:()=>Bu,cosh:()=>Wu,cosineWindow:()=>Lh,cumprod:()=>Uu,cumsum:()=>Vu,customGrad:()=>Hc,data:()=>oC,denseBincount:()=>ju,deprecationWarn:()=>hi,depthToSpace:()=>Gu,depthwiseConv2d:()=>Hu,deregisterOp:()=>TS,device_util:()=>Ns,diag:()=>qu,dilation2d:()=>Xu,disableDeprecationWarnings:()=>di,dispose:()=>yi,disposeVariables:()=>pi,div:()=>Dl,divNoNan:()=>Ju,dot:()=>Qu,dropout:()=>zh,einsum:()=>ec,elu:()=>tc,enableDebugMode:()=>ci,enableProdMode:()=>ui,enclosingPowerOfTwo:()=>Ph,engine:()=>fi,env:()=>qe,equal:()=>Ku,erf:()=>nc,euclideanNorm:()=>bc,exp:()=>vc,expandDims:()=>wc,expm1:()=>kc,eye:()=>Ic,fft:()=>ih,fill:()=>Cc,findBackend:()=>Ii,findBackendFactory:()=>Ci,floor:()=>Ec,floorDiv:()=>Ol,forceHalfFloat:()=>OD,fused:()=>Wh,gather:()=>Nc,gatherND:()=>Dh,gather_util:()=>qi,getBackend:()=>ki,getGradient:()=>fa,getKernel:()=>pa,getKernelsForBackend:()=>ma,getThreadsCount:()=>VG,gpgpu_util:()=>iO,grad:()=>Wc,grads:()=>Uc,greater:()=>Tc,greaterEqual:()=>Rc,ifft:()=>lh,imag:()=>Ri,image:()=>Zp,inTopKAsync:()=>Bh,initializers:()=>qy,input:()=>Tb,io:()=>Bo,irfft:()=>uh,isFinite:()=>_c,isInf:()=>Mc,isNaN:()=>$c,keep:()=>xi,kernel_impls:()=>fm,layers:()=>dx,leakyRelu:()=>Fc,less:()=>Oc,lessEqual:()=>Dc,linalg:()=>Yp,linspace:()=>zc,loadGraphModel:()=>rC,loadGraphModelSync:()=>aC,loadLayersModel:()=>Nb,localResponseNormalization:()=>Pc,log:()=>Lc,log1p:()=>Bc,logSigmoid:()=>Kc,logSoftmax:()=>Yc,logSumExp:()=>Jc,logicalAnd:()=>Qc,logicalNot:()=>ed,logicalOr:()=>td,logicalXor:()=>nd,losses:()=>Jp,lowerBound:()=>sd,matMul:()=>ii,math:()=>oi,max:()=>dc,maxPool:()=>od,maxPool3d:()=>id,maxPoolWithArgmax:()=>ld,maximum:()=>ud,mean:()=>cd,memory:()=>mi,meshgrid:()=>pd,metrics:()=>Yk,min:()=>hc,minimum:()=>fd,mirrorPad:()=>md,mod:()=>Ad,model:()=>Cb,models:()=>pS,moments:()=>gd,movingAverage:()=>$h,mul:()=>zl,multiRNNCell:()=>yd,multinomial:()=>xd,neg:()=>_i,nextFrame:()=>pf,norm:()=>xc,notEqual:()=>bd,oneHot:()=>li,ones:()=>hd,onesLike:()=>vd,op:()=>Ls,outerProduct:()=>wd,pad:()=>kd,pad1d:()=>Sd,pad2d:()=>Id,pad3d:()=>Cd,pad4d:()=>Ed,pool:()=>Td,pow:()=>pc,prelu:()=>Rd,print:()=>Lo,prod:()=>_d,profile:()=>Ai,rand:()=>Md,randomGamma:()=>Od,randomNormal:()=>Dd,randomStandardNormal:()=>zd,randomUniform:()=>Pd,range:()=>Ld,ready:()=>wi,real:()=>Mi,reciprocal:()=>Bd,registerBackend:()=>Ei,registerCallbackConstructor:()=>Rb,registerGradient:()=>ga,registerKernel:()=>Aa,registerOp:()=>ES,regularizers:()=>fS,relu:()=>Wd,relu6:()=>Ud,removeBackend:()=>Si,reshape:()=>du,reverse:()=>Vd,reverse1d:()=>jd,reverse2d:()=>Gd,reverse3d:()=>Hd,reverse4d:()=>qd,rfft:()=>dh,round:()=>Xd,rsqrt:()=>Kd,scalar:()=>fc,scatterND:()=>Fh,scatter_util:()=>Ki,searchSorted:()=>ad,selu:()=>Zd,separableConv2d:()=>Yd,sequential:()=>Eb,serialization:()=>gl,setBackend:()=>vi,setPlatform:()=>Ti,setThreadsCount:()=>UG,setWasmPath:()=>PG,setWasmPaths:()=>LG,setWebGLContext:()=>F$,setdiff1dAsync:()=>Jd,sigmoid:()=>mu,sign:()=>Qd,signal:()=>Kp,sin:()=>eh,sinh:()=>th,slice:()=>Au,slice1d:()=>nh,slice2d:()=>rh,slice3d:()=>ah,slice4d:()=>sh,slice_util:()=>Qi,softmax:()=>oh,softplus:()=>Xc,spaceToBatchND:()=>Nd,sparse:()=>Qp,sparseToDense:()=>Oh,spectral:()=>Xp,split:()=>ch,sqrt:()=>mc,square:()=>Ac,squaredDifference:()=>hh,squeeze:()=>ph,stack:()=>fh,step:()=>mh,stridedSlice:()=>Ah,string:()=>ef,sub:()=>Zc,sum:()=>gc,sumOutType:()=>ms,tan:()=>gh,tanh:()=>gu,tensor:()=>Us,tensor1d:()=>yh,tensor2d:()=>xh,tensor3d:()=>Wi,tensor4d:()=>bh,tensor5d:()=>vh,tensor6d:()=>wh,tensor_util:()=>hs,test_util:()=>vl,tidy:()=>gi,tile:()=>Sc,time:()=>bi,topk:()=>kh,train:()=>df,transpose:()=>$i,truncatedNormal:()=>Sh,unique:()=>Ih,unregisterGradient:()=>xa,unregisterKernel:()=>ya,unsortedSegmentSum:()=>Ch,unstack:()=>Eh,upcastType:()=>fs,upperBound:()=>Nh,util:()=>wa,valueAndGrad:()=>Vc,valueAndGrads:()=>jc,variable:()=>Th,variableGrads:()=>Gc,version:()=>$Z,version_converter:()=>sC,version_core:()=>$l,version_layers:()=>tb,version_wasm:()=>jG,version_webgl:()=>FD,webgl:()=>DD,webgl_util:()=>I$,webgpu:()=>MZ,where:()=>Zu,whereAsync:()=>_h,zeros:()=>dd,zerosLike:()=>Yu});var g=Object.create,y=Object.defineProperty,x=Object.getOwnPropertyDescriptor,b=Object.getOwnPropertyNames,v=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty,k=(e,t)=>function(){return t||(0,e[b(e)[0]])((t={exports:{}}).exports,t),t.exports},S=(e,t)=>{for(var n in t)y(e,n,{get:t[n],enumerable:!0})},I=(e,t,n)=>(n=null!=e?g(v(e)):{},((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of b(t))w.call(e,a)||a===n||y(e,a,{get:()=>t[a],enumerable:!(r=x(t,a))||r.enumerable});return e})(!t&&e&&e.__esModule?n:y(n,"default",{value:e,enumerable:!0}),e)),C=k({"node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js"(e,t){t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var s={},o={};function i(e,t){var n,r,a;return t?(a=0<=(e>>>=0)&&e<256)&&(r=o[e])?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(o[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=u(e,e<0?-1:0,!1),a&&(s[e]=n),n)}function l(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=f)return k}else{if(e<=-m)return S;if(e+1>=m)return w}return e<0?l(-e,t).neg():u(e%p|0,e/p|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=i,r.fromNumber=l,r.fromBits=u;var c=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return d(e.substring(1),t,n).neg();for(var a=l(c(n,8)),s=g,o=0;o<e.length;o+=8){var i=Math.min(8,e.length-o),u=parseInt(e.substring(o,o+i),n);if(i<8){var h=l(c(n,i));s=s.mul(h).add(l(u))}else s=(s=s.mul(a)).add(l(u))}return s.unsigned=t,s}function h(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?d(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=d,r.fromValue=h;var p=4294967296,f=p*p,m=f/2,A=i(1<<24),g=i(0);r.ZERO=g;var y=i(0,!0);r.UZERO=y;var x=i(1);r.ONE=x;var b=i(1,!0);r.UONE=b;var v=i(-1);r.NEG_ONE=v;var w=u(-1,2147483647,!1);r.MAX_VALUE=w;var k=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=k;var S=u(0,-2147483648,!1);r.MIN_VALUE=S;var I=r.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=l(c(e,6),this.unsigned),s=this,o="";;){var i=s.div(a),u=(s.sub(i.mul(a)).toInt()>>>0).toString(e);if((s=i).isZero())return u+o;for(;u.length<6;)u="0"+u;o=""+u+o}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1==(1&this.low)},I.isEven=function(){return 0==(1&this.low)},I.equals=function(e){return a(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(a(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(x)},I.neg=I.negate,I.add=function(e){a(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,o=e.high>>>16,i=65535&e.high,l=e.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,d+=(p+=r+l)>>>16,c+=(d+=n+i)>>>16,c+=t+o,u((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(e){return a(e)||(e=h(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(a(e)||(e=h(e)),n)return u(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(A)&&e.lt(A))return l(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,r=65535&this.high,s=this.low>>>16,o=65535&this.low,i=e.high>>>16,c=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,m=0,y=0,x=0;return y+=(x+=o*p)>>>16,m+=(y+=s*p)>>>16,y&=65535,m+=(y+=o*d)>>>16,f+=(m+=r*p)>>>16,m&=65535,f+=(m+=s*d)>>>16,m&=65535,f+=(m+=o*c)>>>16,f+=t*p+r*d+s*c+o*i,u((y&=65535)<<16|(x&=65535),(f&=65535)<<16|(m&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(a(e)||(e=h(e)),e.isZero())throw Error("division by zero");var t,r,s;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return b;s=y}else{if(this.eq(S))return e.eq(x)||e.eq(v)?S:e.eq(S)?x:(t=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?x:v:(r=this.sub(e.mul(t)),s=t.add(r.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=g}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var o=Math.ceil(Math.log(t)/Math.LN2),i=o<=48?1:c(2,o-48),d=l(t),p=d.mul(e);p.isNegative()||p.gt(r);)p=(d=l(t-=i,this.unsigned)).mul(e);d.isZero()&&(d=x),s=s.add(d),r=r.sub(p)}return s},I.div=I.divide,I.modulo=function(e){return a(e)||(e=h(e)),n?u((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return u(~this.low,~this.high,this.unsigned)},I.and=function(e){return a(e)||(e=h(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return a(e)||(e=h(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return a(e)||(e=h(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return a(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}}}),E=k({"(disabled):node_modules/.pnpm/node-fetch@2.6.7/node_modules/node-fetch/browser.js"(){}}),N=k({"(disabled):util"(){}}),T=k({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/alea.js"(e,t){!function(e,t,n){function r(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new r(e),s=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,s&&("object"==typeof s&&a(s,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),R=k({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor128.js"(e,t){!function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new r(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,s&&("object"==typeof s&&a(s,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),_=k({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorwow.js"(e,t){!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,s&&("object"==typeof s&&a(s,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),M=k({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorshift7.js"(e,t){!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,s&&(s.x&&a(s,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),$=k({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor4096.js"(e,t){!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,a,s,o,i=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(o=o+1640531527|0,a=0==(n=i[127&s]^=r+o)?a+1:0);for(a>=128&&(i[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=i[a+34&127],n=i[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[a]=r^n;e.w=o,e.X=i,e.i=a}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,s&&(s.X&&a(s,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),F=k({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/tychei.js"(e,t){!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,s&&("object"==typeof s&&a(s,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)}}),O=k({"(disabled):crypto"(){}}),D=k({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/seedrandom.js"(e,t){!function(e,r,a){var s,o=256,i=a.pow(o,6),l=a.pow(2,52),u=2*l,c=255;function d(t,n,c){var d=[],g=m(f((n=1==n?{entropy:!0}:n||{}).entropy?[t,A(r)]:null==t?function(){try{var t;return s&&(t=s.randomBytes)?t=t(o):(t=new Uint8Array(o),(e.crypto||e.msCrypto).getRandomValues(t)),A(t)}catch(t){var n=e.navigator,a=n&&n.plugins;return[+new Date,e,a,e.screen,A(r)]}}():t,3),d),y=new h(d),x=function(){for(var e=y.g(6),t=i,n=0;e<l;)e=(e+n)*o,t*=o,n=y.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|y.g(4)},x.quick=function(){return y.g(4)/4294967296},x.double=x,m(A(y.S),r),(n.pass||c||function(e,t,n,r){return r&&(r.S&&p(r,y),e.state=function(){return p(y,{})}),n?(a.random=e,t):e})(x,g,"global"in n?n.global:this==a,n.state)}function h(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);a<o;)i[a]=a++;for(a=0;a<o;a++)i[a]=i[s=c&s+e[a%n]+(t=i[a])],i[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,i=r.S;e--;)t=i[a=c&a+1],n=n*o+i[c&(i[a]=i[s=c&s+t])+(i[s]=t)];return r.i=a,r.j=s,n})(o)}function p(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function f(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(f(e[n],t-1))}catch(e){}return r.length?r:"string"==a?e:e+"\0"}function m(e,t){for(var n,r=e+"",a=0;a<r.length;)t[c&a]=c&(n^=19*t[c&a])+r.charCodeAt(a++);return A(t)}function A(e){return String.fromCharCode.apply(0,e)}if(m(a.random(),r),"object"==typeof t&&t.exports){t.exports=d;try{s=O()}catch(e){}}else"function"==typeof define&&n.amdO?define((function(){return d})):a.seedrandom=d}("undefined"!=typeof self?self:e,[],Math)}}),z=k({"node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/index.js"(e,t){var n=T(),r=R(),a=_(),s=M(),o=$(),i=F(),l=D();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=o,l.tychei=i,t.exports=l}}),P=k({"(disabled):node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js"(){}}),L=k({"(disabled):fs"(){}}),B=k({"(disabled):path"(){}}),W=k({"(disabled):worker_threads"(){}}),U=k({"(disabled):perf_hooks"(){}}),V=k({"(disabled):os"(){}}),j=k({"node_modules/.pnpm/@tensorflow+tfjs-backend-wasm@3.19.0_hek32lflchivueqv5i4vgonghu/node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.js"(e,t){var a,s=(a=(a="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||r,function(e){function t(){return M.buffer!=G&&ee(M.buffer),H}function r(){return M.buffer!=G&&ee(M.buffer),q}function s(){return M.buffer!=G&&ee(M.buffer),X}function o(){return M.buffer!=G&&ee(M.buffer),K}var i,l,u,c=void 0!==(e=e||{})?e:{};c.ready=new Promise((function(e,t){i=e,l=t})),"undefined"!=typeof process&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d,h,p,f,m,A,g=Object.assign({},c),y=[],x=(e,t)=>{throw t},b="object"==typeof window,v="function"==typeof importScripts,w="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,k=c.ENVIRONMENT_IS_PTHREAD||!1,S="";function I(e){return c.locateFile?c.locateFile(e,S):S+e}if(w){let e;S=v?B().dirname(S)+"/":"//",A=()=>{m||(f=L(),m=B())},d=function(e,t){return A(),e=m.normalize(e),f.readFileSync(e,t?void 0:"utf8")},p=e=>{var t=d(e,!0);return t.buffer||(t=new Uint8Array(t)),t},h=(e,t,n)=>{A(),e=m.normalize(e),f.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),y=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof pt))throw e})),process.on("unhandledRejection",(function(e){throw e})),x=(e,t)=>{if(ie())throw process.exitCode=e,t;var n;(n=t)instanceof pt||R("exiting due to exception: "+n),process.exit(e)},c.inspect=function(){return"[Emscripten Module object]"};try{e=W()}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}n.g.Worker=e.Worker}else(b||v)&&(v?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),void 0!==a&&a&&(S=a),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",w||(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},v&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));w&&"undefined"==typeof performance&&(n.g.performance=U().performance);var C=console.log.bind(console),E=console.warn.bind(console);w&&(A(),C=e=>f.writeSync(1,e+"\n"),E=e=>f.writeSync(2,e+"\n"));var N,T=c.print||C,R=c.printErr||E;function _(e){_.shown||(_.shown={}),_.shown[e]||(_.shown[e]=1,R(e))}Object.assign(c,g),g=null,c.arguments&&(y=c.arguments),c.thisProgram&&c.thisProgram,c.quit&&(x=c.quit),Atomics.load,Atomics.store,Atomics.compareExchange,c.wasmBinary&&(N=c.wasmBinary);var M,$,F=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&pe("no native wasm support detected");var O,D=!1;function z(e){return c["_"+e]}function P(e,n,r,a,s){var o={string:function(e){var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);Q(e,t=dt(n),n)}return t},array:function(e){var n,r,a=dt(e.length);return n=e,r=a,t().set(n,r),a}},i=z(e),l=[],u=0;if(a)for(var c=0;c<a.length;c++){var d=o[r[c]];d?(0===u&&(u=ut()),l[c]=d(a[c])):l[c]=a[c]}var h,p=i.apply(null,l);return h=p,0!==u&&ct(u),p=function(e){return"string"===n?J(e):"boolean"===n?Boolean(e):e}(h),p}function j(e){var t=new TextDecoder(e);this.decode=e=>(e.buffer instanceof SharedArrayBuffer&&(e=new Uint8Array(e)),t.decode.call(t,e))}var G,H,q,X,K,Z="undefined"!=typeof TextDecoder?new j("utf8"):void 0;function Y(e,t,n){for(var r=t+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.subarray&&Z)return Z.decode(e.subarray(t,a));for(var s="";t<a;){var o=e[t++];if(128&o){var i=63&e[t++];if(192!=(224&o)){var l=63&e[t++];if((o=224==(240&o)?(15&o)<<12|i<<6|l:(7&o)<<18|i<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(o);else{var u=o-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&o)<<6|i)}else s+=String.fromCharCode(o)}return s}function J(e,t){return e?Y(r(),e,t):""}function Q(e,t,n){return function(e,t,n,r){if(!(r>0))return 0;for(var a=n,s=n+r-1,o=0;o<e.length;++o){var i=e.charCodeAt(o);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),i<=127){if(n>=s)break;t[n++]=i}else if(i<=2047){if(n+1>=s)break;t[n++]=192|i>>6,t[n++]=128|63&i}else if(i<=65535){if(n+2>=s)break;t[n++]=224|i>>12,t[n++]=128|i>>6&63,t[n++]=128|63&i}else{if(n+3>=s)break;t[n++]=240|i>>18,t[n++]=128|i>>12&63,t[n++]=128|i>>6&63,t[n++]=128|63&i}}return t[n]=0,n-a}(e,r(),t,n)}function ee(e){G=e,c.HEAP8=H=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=X=new Int32Array(e),c.HEAPU8=q=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=K=new Float64Array(e)}"undefined"!=typeof TextDecoder&&new j("utf-16le"),k&&(G=c.buffer);var te,ne=c.INITIAL_MEMORY||16777216;if(k)M=c.wasmMemory,G=c.buffer;else if(c.wasmMemory)M=c.wasmMemory;else if(!((M=new WebAssembly.Memory({initial:ne/65536,maximum:32768,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");M&&(G=M.buffer),ne=G.byteLength,ee(G);var re=[],ae=[],se=[],oe=[];function ie(){return F||!1}function le(){k||ye(ae)}var ue,ce=0,de=null,he=null;function pe(e){k?postMessage({cmd:"onAbort",arg:e}):c.onAbort&&c.onAbort(e),R(e="Aborted("+e+")"),D=!0,O=1,e+=". Build with -s ASSERTIONS=1 for more info.";var t=new WebAssembly.RuntimeError(e);throw l(t),t}function fe(e){return e.startsWith("data:application/octet-stream;base64,")}function me(e){return e.startsWith("file://")}function Ae(e){try{if(e==ue&&N)return new Uint8Array(N);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){pe(e)}}c.preloadedImages={},c.preloadedAudios={},fe(ue="tfjs-backend-wasm-threaded-simd.wasm")||(ue=I(ue));var ge={};function ye(e){for(;e.length>0;){var t=e.shift();if("function"!=typeof t){var n=t.func;"number"==typeof n?void 0===t.arg?Ce(n)():Ce(n)(t.arg):n(void 0===t.arg?null:t.arg)}else t(c)}}function xe(e){var t=ut(),n=e();return ct(t),n}function be(e){var t=we.pthreads[e];if(t){s()[e>>2]=0;var n=t.worker;we.returnWorkerToPool(n)}}function ve(e){!function(e,t){if(O=e,!t&&k)throw ke(e),"unwind";var n;ie()||k||we.terminateAllThreads(),O=n=e,ie()||(we.terminateAllThreads(),c.onExit&&c.onExit(n),D=!0),x(n,new pt(n))}(e)}var we={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],init:function(){k?we.initWorker():we.initMainThread()},initMainThread:function(){for(var e=0;e<8;++e)we.allocateUnusedWorker()},initWorker:function(){F=!1},pthreads:{},setExitStatus:function(e){O=e},terminateAllThreads:function(){for(var e in we.pthreads){var t=we.pthreads[e];t&&t.worker&&we.returnWorkerToPool(t.worker)}for(var n=0;n<we.unusedWorkers.length;++n)we.unusedWorkers[n].terminate();we.unusedWorkers=[]},returnWorkerToPool:function(e){we.runWithoutMainThreadQueuedCalls((function(){delete we.pthreads[e.pthread.threadInfoStruct],we.unusedWorkers.push(e),we.runningWorkers.splice(we.runningWorkers.indexOf(e),1),it(e.pthread.threadInfoStruct),e.pthread=void 0}))},runWithoutMainThreadQueuedCalls:function(e){s()[ht>>2]=0;try{e()}finally{s()[ht>>2]=1}},receiveObjectTransfer:function(e){},threadInit:function(){for(var e in we.tlsInitFunctions)we.tlsInitFunctions[e]()},loadWasmModuleToWorker:function(e,t){e.onmessage=n=>{var r,a=n.data,o=a.cmd;if(e.pthread&&(we.currentProxiedOperationCallerThread=e.pthread.threadInfoStruct),a.targetThread&&a.targetThread!=tt()){var i=we.pthreads[a.targetThread];return i?i.worker.postMessage(a,a.transferList):R('Internal error! Worker sent a message "'+o+'" to target pthread '+a.targetThread+", but that thread no longer exists!"),void(we.currentProxiedOperationCallerThread=void 0)}"processQueuedMainThreadWork"===o?nt():"spawnThread"===o?Ne(a):"cleanupThread"===o?be(a.thread):"killThread"===o?function(e){s()[e>>2]=0;var t=we.pthreads[e];delete we.pthreads[e],t.worker.terminate(),it(e),we.runningWorkers.splice(we.runningWorkers.indexOf(t.worker),1),t.worker.pthread=void 0}(a.thread):"cancelThread"===o?(r=a.thread,we.pthreads[r].worker.postMessage({cmd:"cancel"})):"loaded"===o?(e.loaded=!0,t&&t(e),e.runPthread&&(e.runPthread(),delete e.runPthread)):"print"===o?T("Thread "+a.threadId+": "+a.text):"printErr"===o?R("Thread "+a.threadId+": "+a.text):"alert"===o?alert("Thread "+a.threadId+": "+a.text):"setimmediate"===a.target?e.postMessage(a):"onAbort"===o?c.onAbort&&c.onAbort(a.arg):R("worker sent an unknown command "+o),we.currentProxiedOperationCallerThread=void 0},e.onerror=e=>{throw R("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},w&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:c.mainScriptUrlOrBlob||a,wasmMemory:M,wasmModule:$})},allocateUnusedWorker:function(){var e=I("tfjs-backend-wasm-threaded-simd.worker.js");we.unusedWorkers.push(new Worker(e))},getNewWorker:function(){return 0==we.unusedWorkers.length&&(we.allocateUnusedWorker(),we.loadWasmModuleToWorker(we.unusedWorkers[0])),we.unusedWorkers.pop()}};function ke(e){if(k)return Re(1,0,e);try{ve(e)}catch(e){!function(e){if(e instanceof pt||"unwind"==e)return O;x(1,e)}(e)}}c.establishStackSpace=function(){var e=tt(),t=s()[e+44>>2],n=s()[e+48>>2];lt(t,t-n),ct(t)};var Se,Ie=[];function Ce(e){var t=Ie[e];return t||(e>=Ie.length&&(Ie.length=e+1),Ie[e]=t=te.get(e)),t}function Ee(e,t){var n,r;if(0===e)n=Date.now();else{if(1!==e&&4!==e)return r=28,s()[et()>>2]=r,-1;n=Se()}return s()[t>>2]=n/1e3|0,s()[t+4>>2]=n%1e3*1e3*1e3|0,0}function Ne(e){var t=we.getNewWorker();if(!t)return 6;we.runningWorkers.push(t);var n=we.pthreads[e.pthread_ptr]={worker:t,threadInfoStruct:e.pthread_ptr};t.pthread=n;var r={cmd:"run",start_routine:e.startRoutine,arg:e.arg,threadInfoStruct:e.pthread_ptr};return t.runPthread=()=>{r.time=performance.now(),t.postMessage(r,e.transferList)},t.loaded&&(t.runPthread(),delete t.runPthread),0}function Te(){return 2147483648}function Re(e,t){var n=arguments.length-2,r=arguments;return xe((function(){for(var a=n,s=dt(8*a),i=s>>3,l=0;l<n;l++){var u=r[2+l];o()[i+l]=u}return st(e,a,s,t)}))}c.invokeEntryPoint=function(e,t){return Ce(e)(t)},Se=w?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:k?()=>performance.now()-c.__performance_now_clock_drift:()=>performance.now();var _e=[];function Me(e){try{return M.grow(e-G.byteLength+65535>>>16),ee(M.buffer),1}catch(e){}}var $e={inEventHandler:0,removeAllEventListeners:function(){for(var e=$e.eventHandlers.length-1;e>=0;--e)$e._removeHandler(e);$e.eventHandlers=[],$e.deferredCalls=[]},registerRemoveEventListeners:function(){$e.removeEventListenersRegistered||(se.push($e.removeAllEventListeners),$e.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(e,t,n){function r(e,t){if(e.length!=t.length)return!1;for(var n in e)if(e[n]!=t[n])return!1;return!0}for(var a in $e.deferredCalls){var s=$e.deferredCalls[a];if(s.targetFunction==e&&r(s.argsList,n))return}$e.deferredCalls.push({targetFunction:e,precedence:t,argsList:n}),$e.deferredCalls.sort((function(e,t){return e.precedence<t.precedence}))},removeDeferredCalls:function(e){for(var t=0;t<$e.deferredCalls.length;++t)$e.deferredCalls[t].targetFunction==e&&($e.deferredCalls.splice(t,1),--t)},canPerformEventHandlerRequests:function(){return $e.inEventHandler&&$e.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if($e.canPerformEventHandlerRequests())for(var e=0;e<$e.deferredCalls.length;++e){var t=$e.deferredCalls[e];$e.deferredCalls.splice(e,1),--e,t.targetFunction.apply(null,t.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(e,t){for(var n=0;n<$e.eventHandlers.length;++n)$e.eventHandlers[n].target!=e||t&&t!=$e.eventHandlers[n].eventTypeString||$e._removeHandler(n--)},_removeHandler:function(e){var t=$e.eventHandlers[e];t.target.removeEventListener(t.eventTypeString,t.eventListenerFunc,t.useCapture),$e.eventHandlers.splice(e,1)},registerOrRemoveHandler:function(e){var t=function(t){++$e.inEventHandler,$e.currentEventHandler=e,$e.runDeferredCalls(),e.handlerFunc(t),$e.runDeferredCalls(),--$e.inEventHandler};if(e.callbackfunc)e.eventListenerFunc=t,e.target.addEventListener(e.eventTypeString,t,e.useCapture),$e.eventHandlers.push(e),$e.registerRemoveEventListeners();else for(var n=0;n<$e.eventHandlers.length;++n)$e.eventHandlers[n].target==e.target&&$e.eventHandlers[n].eventTypeString==e.eventTypeString&&$e._removeHandler(n--)},queueEventHandlerOnThread_iiii:function(e,t,n,r,a){xe((function(){var o=dt(12);s()[o>>2]=n,s()[o+4>>2]=r,s()[o+8>>2]=a,ot(e,637534208,t,r,o)}))},getTargetThreadForEventCallback:function(e){switch(e){case 1:return 0;case 2:return we.currentProxiedOperationCallerThread;default:return e}},getNodeNameForTarget:function(e){return e?e==window?"#window":e==screen?"#screen":e&&e.nodeName?e.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function Fe(e,t,n,r){xe((function(){var a,o,i,l=dt(12),u=0;t&&(o=function(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);r>=55296&&r<=57343&&(r=65536+((1023&r)<<10)|1023&e.charCodeAt(++n)),r<=127?++t:t+=r<=2047?2:r<=65535?3:4}return t}(a=t)+1,i=Je(o),Q(a,i,o),u=i),s()[l>>2]=u,s()[l+4>>2]=n,s()[l+8>>2]=r,ot(e,657457152,0,u,l)}))}var Oe=[0,"undefined"!=typeof document?document:0,"undefined"!=typeof window?window:0];function De(e){var t;return e=(t=e)>2?J(t):t,Oe[e]||("undefined"!=typeof document?document.querySelector(e):void 0)}function ze(e){return De(e)}function Pe(e,t,n){var r=ze(e);if(!r)return-4;if(r.canvasSharedPtr&&(s()[r.canvasSharedPtr>>2]=t,s()[r.canvasSharedPtr+4>>2]=n),!r.offscreenCanvas&&r.controlTransferredOffscreen)return r.canvasSharedPtr?(function(e,t,n,r){Fe(e,t=t?J(t):"",n,r)}(s()[r.canvasSharedPtr+8>>2],e,t,n),1):-4;r.offscreenCanvas&&(r=r.offscreenCanvas);var a=!1;if(r.GLctxObject&&r.GLctxObject.GLctx){var o=r.GLctxObject.GLctx.getParameter(2978);a=0===o[0]&&0===o[1]&&o[2]===r.width&&o[3]===r.height}return r.width=t,r.height=n,a&&r.GLctxObject.GLctx.viewport(0,0,t,n),0}function Le(e,t,n){return k?Re(2,1,e,t,n):Pe(e,t,n)}var Be,We={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function(e){We.lastError||(We.lastError=e)},getNewId:function(e){for(var t=We.counter++,n=e.length;n<t;n++)e[n]=null;return t},getSource:function(e,t,n,r){for(var a="",o=0;o<t;++o){var i=r?s()[r+4*o>>2]:-1;a+=J(s()[n+4*o>>2],i<0?void 0:i)}return a},createContext:function(e,t){e.getContextSafariWebGL2Fixed||(e.getContextSafariWebGL2Fixed=e.getContext,e.getContext=function(t,n){var r=e.getContextSafariWebGL2Fixed(t,n);return"webgl"==t==r instanceof WebGLRenderingContext?r:null});var n=e.getContext("webgl",t);return n?We.registerContext(n,t):0},registerContext:function(e,t){var n=Je(8);s()[n+4>>2]=tt();var r={handle:n,attributes:t,version:t.majorVersion,GLctx:e};return e.canvas&&(e.canvas.GLctxObject=r),We.contexts[n]=r,(void 0===t.enableExtensionsByDefault||t.enableExtensionsByDefault)&&We.initExtensions(r),n},makeContextCurrent:function(e){return We.currentContext=We.contexts[e],c.ctx=Be=We.currentContext&&We.currentContext.GLctx,!(e&&!Be)},getContext:function(e){return We.contexts[e]},deleteContext:function(e){We.currentContext===We.contexts[e]&&(We.currentContext=null),"object"==typeof $e&&$e.removeAllHandlersOnTarget(We.contexts[e].GLctx.canvas),We.contexts[e]&&We.contexts[e].GLctx.canvas&&(We.contexts[e].GLctx.canvas.GLctxObject=void 0),Qe(We.contexts[e].handle),We.contexts[e]=null},initExtensions:function(e){if(e||(e=We.currentContext),!e.initExtensionsDone){e.initExtensionsDone=!0;var t,n=e.GLctx;!function(e){var t=e.getExtension("ANGLE_instanced_arrays");t&&(e.vertexAttribDivisor=function(e,n){t.vertexAttribDivisorANGLE(e,n)},e.drawArraysInstanced=function(e,n,r,a){t.drawArraysInstancedANGLE(e,n,r,a)},e.drawElementsInstanced=function(e,n,r,a,s){t.drawElementsInstancedANGLE(e,n,r,a,s)})}(n),function(e){var t=e.getExtension("OES_vertex_array_object");t&&(e.createVertexArray=function(){return t.createVertexArrayOES()},e.deleteVertexArray=function(e){t.deleteVertexArrayOES(e)},e.bindVertexArray=function(e){t.bindVertexArrayOES(e)},e.isVertexArray=function(e){return t.isVertexArrayOES(e)})}(n),function(e){var t=e.getExtension("WEBGL_draw_buffers");t&&(e.drawBuffers=function(e,n){t.drawBuffersWEBGL(e,n)})}(n),n.disjointTimerQueryExt=n.getExtension("EXT_disjoint_timer_query"),(t=n).multiDrawWebgl=t.getExtension("WEBGL_multi_draw"),(n.getSupportedExtensions()||[]).forEach((function(e){e.includes("lose_context")||e.includes("debug")||n.getExtension(e)}))}}},Ue=["default","low-power","high-performance"],Ve={mappings:{},buffers:[null,[],[]],printChar:function(e,t){var n=Ve.buffers[e];0===t||10===t?((1===e?T:R)(Y(n,0)),n.length=0):n.push(t)},varargs:void 0,get:function(){return Ve.varargs+=4,s()[Ve.varargs-4>>2]},getStr:function(e){return J(e)},get64:function(e,t){return e}};function je(e){return k?Re(3,1,e):0}function Ge(e,t,n,r,a){if(k)return Re(4,1,e,t,n,r,a)}function He(e,t,n,a){if(k)return Re(5,1,e,t,n,a);for(var o=0,i=0;i<n;i++){var l=s()[t>>2],u=s()[t+4>>2];t+=8;for(var c=0;c<u;c++)Ve.printChar(e,r()[l+c]);o+=u}return s()[a>>2]=o,0}we.init();var qe,Xe,Ke,Ze=[null,ke,Le,je,Ge,He],Ye={__clock_gettime:function(e,t){return Ee(e,t)},__emscripten_init_main_thread_js:function(e){rt(e,!v,1,!b),we.threadInit()},__emscripten_thread_cleanup:function(e){k?postMessage({cmd:"cleanupThread",thread:e}):be(e)},__pthread_create_js:function(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];if(k&&0===a.length)return at(687865856,e,t,n,r);var s={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return k?(s.cmd="spawnThread",postMessage(s,a),0):Ne(s)},_emscripten_default_pthread_stack_size:function(){return 2097152},_emscripten_notify_thread_queue:function(e,t){if(e==t)postMessage({cmd:"processQueuedMainThreadWork"});else if(k)postMessage({targetThread:e,cmd:"processThreadQueue"});else{var n=we.pthreads[e],r=n&&n.worker;if(!r)return;r.postMessage({cmd:"processThreadQueue"})}return 1},abort:function(){pe("")},emscripten_check_blocking_allowed:function(){w||v||_("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_get_heap_max:Te,emscripten_get_now:Se,emscripten_memcpy_big:function(e,t,n){r().copyWithin(e,t,t+n)},emscripten_num_logical_cores:function(){return w?V().cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){_e.length=t;for(var r=n>>3,a=0;a<t;a++)_e[a]=o()[r+a];return(e<0?ge[-e-1]:Ze[e]).apply(null,_e)},emscripten_resize_heap:function(e){var t=r().length;if((e>>>=0)<=t)return!1;var n,a,s=2147483648;if(e>s)return!1;for(var o=1;o<=4;o*=2){var i=t*(1+.2/o);if(i=Math.min(i,e+100663296),Me(Math.min(s,((n=Math.max(e,i))%(a=65536)>0&&(n+=a-n%a),n))))return!0}return!1},emscripten_set_canvas_element_size:function(e,t,n){return ze(e)?Pe(e,t,n):Le(e,t,n)},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},emscripten_webgl_create_context:function(e,t){return n=e,r=t>>2,a=s()[r+6],o={alpha:!!s()[r+0],depth:!!s()[r+1],stencil:!!s()[r+2],antialias:!!s()[r+3],premultipliedAlpha:!!s()[r+4],preserveDrawingBuffer:!!s()[r+5],powerPreference:Ue[a],failIfMajorPerformanceCaveat:!!s()[r+7],majorVersion:s()[r+8],minorVersion:s()[r+9],enableExtensionsByDefault:s()[r+10],explicitSwapControl:s()[r+11],proxyContextToMainThread:s()[r+12],renderViaOffscreenBackBuffer:s()[r+13]},(i=ze(n))?o.explicitSwapControl?0:We.createContext(i,o):0;var n,r,a,o,i},exit:ve,fd_close:je,fd_seek:Ge,fd_write:He,memory:M||c.wasmMemory,setTempRet0:function(e){}},Je=(function(){var e={env:Ye,wasi_snapshot_preview1:Ye};function t(e,t){var n,r,a=e.exports;if(c.asm=a,n=c.asm.emscripten_tls_init,we.tlsInitFunctions.push(n),te=c.asm.__indirect_function_table,r=c.asm.__wasm_call_ctors,ae.unshift(r),$=t,!k){var s=we.unusedWorkers.length;we.unusedWorkers.forEach((function(e){we.loadWasmModuleToWorker(e,(function(){--s||function(e){if(ce--,c.monitorRunDependencies&&c.monitorRunDependencies(ce),0==ce&&(null!==de&&(clearInterval(de),de=null),he)){var t=he;he=null,t()}}()}))}))}}function n(e){t(e.instance,e.module)}function r(t){return function(){if(!N&&(b||v)){if("function"==typeof fetch&&!me(ue))return fetch(ue,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ue+"'";return e.arrayBuffer()})).catch((function(){return Ae(ue)}));if(h)return new Promise((function(e,t){h(ue,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return Ae(ue)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){R("failed to asynchronously prepare wasm: "+e),pe(e)}))}if(k||(ce++,c.monitorRunDependencies&&c.monitorRunDependencies(ce)),c.instantiateWasm)try{return c.instantiateWasm(e,t)}catch(e){return R("Module.instantiateWasm callback failed with error: "+e),!1}(N||"function"!=typeof WebAssembly.instantiateStreaming||fe(ue)||me(ue)||"function"!=typeof fetch?r(n):fetch(ue,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return R("wasm streaming compile failed: "+e),R("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(l)}(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(Je=c._malloc=c.asm.malloc).apply(null,arguments)}),Qe=c._free=function(){return(Qe=c._free=c.asm.free).apply(null,arguments)},et=(c._emscripten_tls_init=function(){return(c._emscripten_tls_init=c.asm.emscripten_tls_init).apply(null,arguments)},c.___errno_location=function(){return(et=c.___errno_location=c.asm.__errno_location).apply(null,arguments)}),tt=c._pthread_self=function(){return(tt=c._pthread_self=c.asm.pthread_self).apply(null,arguments)},nt=c._emscripten_main_thread_process_queued_calls=function(){return(nt=c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},rt=(c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c.__emscripten_thread_init=function(){return(rt=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)}),at=(c._emscripten_current_thread_process_queued_calls=function(){return(c._emscripten_current_thread_process_queued_calls=c.asm.emscripten_current_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)},c._emscripten_sync_run_in_main_thread_2=function(){return(c._emscripten_sync_run_in_main_thread_2=c.asm.emscripten_sync_run_in_main_thread_2).apply(null,arguments)},c._emscripten_sync_run_in_main_thread_4=function(){return(at=c._emscripten_sync_run_in_main_thread_4=c.asm.emscripten_sync_run_in_main_thread_4).apply(null,arguments)}),st=c._emscripten_run_in_main_runtime_thread_js=function(){return(st=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},ot=c._emscripten_dispatch_to_thread_=function(){return(ot=c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},it=c.__emscripten_thread_free_data=function(){return(it=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},lt=(c.__emscripten_thread_exit=function(){return(c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},c._memalign=function(){return(c._memalign=c.asm.memalign).apply(null,arguments)},c._emscripten_stack_set_limits=function(){return(lt=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)}),ut=c.stackSave=function(){return(ut=c.stackSave=c.asm.stackSave).apply(null,arguments)},ct=c.stackRestore=function(){return(ct=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},dt=c.stackAlloc=function(){return(dt=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)},ht=(c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)},c.__emscripten_allow_main_runtime_queued_calls=21672);function pt(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function ft(e){if(e=e||y,!(ce>0)){if(k)return i(c),le(),void postMessage({cmd:"loaded"});!function(){if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)e=c.preRun.shift(),re.unshift(e);var e;ye(re)}(),ce>0||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),t()}),1)):t())}function t(){qe||(qe=!0,c.calledRun=!0,D||(le(),i(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),function(){if(!k){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;)e=c.postRun.shift(),oe.unshift(e);var e;ye(oe)}}()))}}if(c.cwrap=function(e,t,n,r){var a=(n=n||[]).every((function(e){return"number"===e}));return"string"!==t&&a&&!r?z(e):function(){return P(e,t,n,arguments)}},c.keepRuntimeAlive=ie,c.PThread=we,c.PThread=we,c.wasmMemory=M,c.ExitStatus=pt,he=function e(){qe||ft(),qe||(he=e)},c.run=ft,c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();if(ft(),u&&(Xe={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!u.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!u.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)Ke=WasmBackendModule;else{if(void 0===e)throw new Error("Could not find wasm module in post.js");Ke=e}if(Xe){var mt=Ke._dispose;Ke._dispose=function(){mt(),Xe.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Xe.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return e.ready});"object"==typeof e&&"object"==typeof t?t.exports=s:"function"==typeof define&&n.amdO?define([],(function(){return s})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=s)}}),G=k({"node_modules/.pnpm/@tensorflow+tfjs-backend-wasm@3.19.0_hek32lflchivueqv5i4vgonghu/node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.worker.js"(e,t){t.exports.wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});'}}),H=k({"node_modules/.pnpm/@tensorflow+tfjs-backend-wasm@3.19.0_hek32lflchivueqv5i4vgonghu/node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm.js"(e,t){var a,s=(a=(a="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||r,function(e){var t,n,r,s=void 0!==(e=e||{})?e:{};s.ready=new Promise((function(e,r){t=e,n=r})),"undefined"!=typeof process&&process.listeners&&(r={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var o,i,l,u,c,d,h=Object.assign({},s),p=[],f="object"==typeof window,m="function"==typeof importScripts,A="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,g="";A?(g=m?B().dirname(g)+"/":"//",d=()=>{c||(u=L(),c=B())},o=function(e,t){return d(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},l=e=>{var t=o(e,!0);return t.buffer||(t=new Uint8Array(t)),t},i=(e,t,n)=>{d(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),p=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),s.inspect=function(){return"[Emscripten Module object]"}):(f||m)&&(m?g=self.location.href:"undefined"!=typeof document&&document.currentScript&&(g=document.currentScript.src),a&&(g=a),g=0!==g.indexOf("blob:")?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},m&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var y,x=s.print||console.log.bind(console),b=s.printErr||console.warn.bind(console);Object.assign(s,h),h=null,s.arguments&&(p=s.arguments),s.thisProgram&&s.thisProgram,s.quit&&s.quit,s.wasmBinary&&(y=s.wasmBinary);var v;s.noExitRuntime;"object"!=typeof WebAssembly&&j("no native wasm support detected");var w=!1;function k(e){return s["_"+e]}function S(e,t,n,r,a){var s={string:function(e){var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);!function(e,t,n){!function(e,t,n,r){if(!(r>0))return 0;for(var a=n+r-1,s=0;s<e.length;++s){var o=e.charCodeAt(s);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++s)),o<=127){if(n>=a)break;t[n++]=o}else if(o<=2047){if(n+1>=a)break;t[n++]=192|o>>6,t[n++]=128|63&o}else if(o<=65535){if(n+2>=a)break;t[n++]=224|o>>12,t[n++]=128|o>>6&63,t[n++]=128|63&o}else{if(n+3>=a)break;t[n++]=240|o>>18,t[n++]=128|o>>12&63,t[n++]=128|o>>6&63,t[n++]=128|63&o}}t[n]=0}(e,E,t,n)}(e,t=oe(n),n)}return t},array:function(e){var t,n,r=oe(e.length);return t=e,n=r,C.set(t,n),r}},o=k(e),i=[],l=0;if(r)for(var u=0;u<r.length;u++){var c=s[n[u]];c?(0===l&&(l=ae()),i[u]=c(r[u])):i[u]=r[u]}var d,h=o.apply(null,i);return d=h,0!==l&&se(l),h=function(e){return"string"===t?_(e):"boolean"===t?Boolean(e):e}(d),h}var I,C,E,N,T="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(e,t,n){for(var r=t+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.subarray&&T)return T.decode(e.subarray(t,a));for(var s="";t<a;){var o=e[t++];if(128&o){var i=63&e[t++];if(192!=(224&o)){var l=63&e[t++];if((o=224==(240&o)?(15&o)<<12|i<<6|l:(7&o)<<18|i<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(o);else{var u=o-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&o)<<6|i)}else s+=String.fromCharCode(o)}return s}function _(e,t){return e?R(E,e,t):""}function M(e){I=e,s.HEAP8=C=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=N=new Int32Array(e),s.HEAPU8=E=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=new Float64Array(e)}"undefined"!=typeof TextDecoder&&new TextDecoder("utf-16le"),s.INITIAL_MEMORY;var $,F=[],O=[],D=[];var z,P,W=0,U=null,V=null;function j(e){s.onAbort&&s.onAbort(e),b(e="Aborted("+e+")"),w=!0,e+=". Build with -s ASSERTIONS=1 for more info.";var t=new WebAssembly.RuntimeError(e);throw n(t),t}function G(e){return e.startsWith("data:application/octet-stream;base64,")}function H(e){return e.startsWith("file://")}function q(e){try{if(e==z&&y)return new Uint8Array(y);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(e){j(e)}}function X(e){for(;e.length>0;){var t=e.shift();if("function"!=typeof t){var n=t.func;"number"==typeof n?void 0===t.arg?Z(n)():Z(n)(t.arg):n(void 0===t.arg?null:t.arg)}else t(s)}}s.preloadedImages={},s.preloadedAudios={},G(z="tfjs-backend-wasm.wasm")||(P=z,z=s.locateFile?s.locateFile(P,g):g+P);var K=[];function Z(e){var t=K[e];return t||(e>=K.length&&(K.length=e+1),K[e]=t=$.get(e)),t}function Y(){return 2147483648}function J(e){try{return v.grow(e-I.byteLength+65535>>>16),M(v.buffer),1}catch(e){}}var Q,ee,te,ne={mappings:{},buffers:[null,[],[]],printChar:function(e,t){var n=ne.buffers[e];0===t||10===t?((1===e?x:b)(R(n,0)),n.length=0):n.push(t)},varargs:void 0,get:function(){return ne.varargs+=4,N[ne.varargs-4>>2]},getStr:function(e){return _(e)},get64:function(e,t){return e}},re={abort:function(){j("")},emscripten_get_heap_max:Y,emscripten_memcpy_big:function(e,t,n){E.copyWithin(e,t,t+n)},emscripten_resize_heap:function(e){var t,n,r=E.length,a=2147483648;if((e>>>=0)>a)return!1;for(var s=1;s<=4;s*=2){var o=r*(1+.2/s);if(o=Math.min(o,e+100663296),J(Math.min(a,((t=Math.max(e,o))%(n=65536)>0&&(t+=n-t%n),t))))return!0}return!1},fd_close:function(e){return 0},fd_seek:function(e,t,n,r,a){},fd_write:function(e,t,n,r){for(var a=0,s=0;s<n;s++){var o=N[t>>2],i=N[t+4>>2];t+=8;for(var l=0;l<i;l++)ne.printChar(e,E[o+l]);a+=i}return N[r>>2]=a,0},setTempRet0:function(e){}},ae=(function(){var e={env:re,wasi_snapshot_preview1:re};function t(e,t){var n,r=e.exports;s.asm=r,M((v=s.asm.memory).buffer),$=s.asm.__indirect_function_table,n=s.asm.__wasm_call_ctors,O.unshift(n),function(e){if(W--,s.monitorRunDependencies&&s.monitorRunDependencies(W),0==W&&(null!==U&&(clearInterval(U),U=null),V)){var t=V;V=null,t()}}()}function r(e){t(e.instance)}function a(t){return function(){if(!y&&(f||m)){if("function"==typeof fetch&&!H(z))return fetch(z,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+z+"'";return e.arrayBuffer()})).catch((function(){return q(z)}));if(i)return new Promise((function(e,t){i(z,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q(z)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){b("failed to asynchronously prepare wasm: "+e),j(e)}))}if(W++,s.monitorRunDependencies&&s.monitorRunDependencies(W),s.instantiateWasm)try{return s.instantiateWasm(e,t)}catch(e){return b("Module.instantiateWasm callback failed with error: "+e),!1}(y||"function"!=typeof WebAssembly.instantiateStreaming||G(z)||H(z)||"function"!=typeof fetch?a(r):fetch(z,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(r,(function(e){return b("wasm streaming compile failed: "+e),b("falling back to ArrayBuffer instantiation"),a(r)}))}))).catch(n)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)},s._emscripten_main_thread_process_queued_calls=function(){return(s._emscripten_main_thread_process_queued_calls=s.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},s.stackSave=function(){return(ae=s.stackSave=s.asm.stackSave).apply(null,arguments)}),se=s.stackRestore=function(){return(se=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},oe=s.stackAlloc=function(){return(oe=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function le(e){function n(){Q||(Q=!0,s.calledRun=!0,w||(X(O),t(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),function(){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;)e=s.postRun.shift(),D.unshift(e);var e;X(D)}()))}e=e||p,W>0||(function(){if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)e=s.preRun.shift(),F.unshift(e);var e;X(F)}(),W>0||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),n()}),1)):n()))}if(s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=function(e,t,n,r){var a=(n=n||[]).every((function(e){return"number"===e}));return"string"!==t&&a&&!r?k(e):function(){return S(e,t,n,arguments)}},V=function e(){Q||le(),Q||(V=e)},s.run=le,s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();if(le(),r&&(ee={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!r.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!r.unhandledRejection.indexOf(e)>-1}))}),void 0!==e)te=e;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");te=WasmBackendModuleThreadedSimd}if(ee){var ue=te._dispose;te._dispose=function(){ue(),ee.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),ee.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return e.ready});"object"==typeof e&&"object"==typeof t?t.exports=s:"function"==typeof define&&n.amdO?define([],(function(){return s})):"object"==typeof e&&(e.WasmBackendModule=s)}}),q=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},X=class{refCount(e){return K("refCount")}incRef(e){return K("incRef")}timerAvailable(){return!0}time(e){return K("time")}read(e){return K("read")}readSync(e){return K("readSync")}readToGPU(e,t){return K("readToGPU")}numDataIds(){return K("numDataIds")}disposeData(e,t){return K("disposeData")}write(e,t,n){return K("write")}move(e,t,n,r,a){return K("move")}memory(){return K("memory")}floatPrecision(){return K("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return K("dispose")}};function K(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Z(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,ee(e,t,n)}function Y(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,ee(e,n,r),ee(t,n,r)}function J(e,t,n){return Math.max(e,Math.min(t,n))}function Q(e){return e%2==0?e:e+1}function ee(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function te(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function ne(e,t){const n=Math.random();return t*n+(1-n)*e}function re(e,t){let n=0;for(let r=0;r<e.length;r++){const a=Number(e[r])-Number(t[r]);n+=a*a}return n}function ae(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function se(e,t,n=""){ae(ce(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function oe(e){ae(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function ie(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||Ie(e)&&!n)for(let r=0;r<e.length;++r)ie(e[r],t,n);else t.push(e);return t}function le(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function ue(e){return 0===e.length}function ce(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function de(e){return e%1==0}function he(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function pe(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function fe(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Z(t),t}function me(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Ae(e,t=(e=>0),n){return new Promise(((r,a)=>{let s=0;const o=()=>{if(e())return void r();s++;const i=t(s);null!=n&&s>=n?a():setTimeout(o,i)};o()}))}function ge(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const a=e.slice();return a[r]=t/n,a}function ye(e,t){const n=t.length;return ae((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),ae(e.every((e=>de(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function xe(e,t){const n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:ye(t,e).sort();let o=0;for(let t=0;t<e.length;++t){if(null!=s){if(s[o]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==s[o]||s[o]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),s[o]<=t&&o++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function be(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function ve(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function we(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function ke(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function Se(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function Ie(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function Ce(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Ee(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function Ne(e){return"string"==typeof e||e instanceof String}function Te(e){return"boolean"==typeof e}function Re(e){return"number"==typeof e}function _e(e){return Array.isArray(e)?_e(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Re(e)?"float32":Ne(e)?"string":Te(e)?"bool":"float32"}function Me(e){return!!(e&&e.constructor&&e.call&&e.apply)}function $e(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function Fe(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Oe(e,t,n,r=!1){const a=new Array;if(1===t.length){const s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{const s=t[0],o=t.slice(1),i=o.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=Oe(e+t*i,o,n,r)}return a}function De(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Oe(0,e,t,n)}function ze(e,t){const n=Pe(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function Pe(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Le(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return De(e,new Float32Array(n));if("int32"===t)return De(e,new Int32Array(n));if("bool"===t)return De(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Be(e){e.forEach((t=>{ae(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function We(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function Ue(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function Ve(e){return e&&e.then&&"function"==typeof e.then}var je="tfjsflags",Ge=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=He,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(qe().getBool("IS_TEST")||qe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];qe().getBool("IS_TEST")||qe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Ve(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(je in e){e.tfjsflags.split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)}))}}};function He(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function qe(){return Ke}var Xe,Ke=null;function Ze(){if(null==Xe){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}Xe=e}return Xe}function Ye(e,t){const n=function(){const e=Ze();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}var Je="Abs",Qe="Acos",et="Acosh",tt="Add",nt="AddN",rt="All",at="Any",st="ArgMax",ot="ArgMin",it="Asin",lt="Asinh",ut="Atan",ct="Atanh",dt="Atan2",ht="AvgPool",pt="AvgPoolGrad",ft="AvgPool3D",mt="AvgPool3DGrad",At="BatchMatMul",gt="BatchToSpaceND",yt="Bincount",xt="BroadcastTo",bt="BroadcastArgs",vt="Cast",wt="Ceil",kt="ClipByValue",St="Complex",It="ComplexAbs",Ct="Concat",Et="Conv2D",Nt="Conv2DBackpropFilter",Tt="Conv2DBackpropInput",Rt="Conv3D",_t="Conv3DBackpropFilterV2",Mt="Conv3DBackpropInputV2",$t="Cos",Ft="Cosh",Ot="Cumprod",Dt="Cumsum",zt="CropAndResize",Pt="DenseBincount",Lt="DepthToSpace",Bt="DepthwiseConv2dNative",Wt="DepthwiseConv2dNativeBackpropFilter",Ut="DepthwiseConv2dNativeBackpropInput",Vt="Diag",jt="Dilation2D",Gt="Dilation2DBackpropInput",Ht="Dilation2DBackpropFilter",qt="RealDiv",Xt="Einsum",Kt="Elu",Zt="EluGrad",Yt="Erf",Jt="Equal",Qt="Exp",en="ExpandDims",tn="Expm1",nn="FFT",rn="Fill",an="FlipLeftRight",sn="Floor",on="FloorDiv",ln="FusedBatchNorm",un="GatherV2",cn="GatherNd",dn="Greater",hn="GreaterEqual",pn="Identity",fn="IFFT",mn="Imag",An="IsFinite",gn="IsInf",yn="IsNan",xn="LeakyRelu",bn="Less",vn="LessEqual",wn="LinSpace",kn="Log",Sn="Log1p",In="LogicalAnd",Cn="LogicalNot",En="LogicalOr",Nn="LogicalXor",Tn="LogSoftmax",Rn="LowerBound",_n="LRN",Mn="LRNGrad",$n="Max",Fn="Maximum",On="MaxPool",Dn="MaxPoolGrad",zn="MaxPool3D",Pn="MaxPool3DGrad",Ln="MaxPoolWithArgmax",Bn="Mean",Wn="Min",Un="Minimum",Vn="MirrorPad",jn="Mod",Gn="Multinomial",Hn="Multiply",qn="Neg",Xn="NotEqual",Kn="NonMaxSuppressionV3",Zn="NonMaxSuppressionV4",Yn="NonMaxSuppressionV5",Jn="OnesLike",Qn="OneHot",er="Pack",tr="PadV2",nr="Pool",rr="Pow",ar="Prelu",sr="Prod",or="Range",ir="Real",lr="Reciprocal",ur="Relu",cr="Reshape",dr="ResizeNearestNeighbor",hr="ResizeNearestNeighborGrad",pr="ResizeBilinear",fr="ResizeBilinearGrad",mr="Relu6",Ar="Reverse",gr="Round",yr="Rsqrt",xr="ScatterNd",br="SearchSorted",vr="Select",wr="Selu",kr="Slice",Sr="Sin",Ir="Sinh",Cr="Sign",Er="Sigmoid",Nr="Softplus",Tr="Sqrt",Rr="Sum",_r="SpaceToBatchND",Mr="SplitV",$r="Softmax",Fr="SparseFillEmptyRows",Or="SparseReshape",Dr="SparseSegmentMean",zr="SparseSegmentSum",Pr="SparseToDense",Lr="SquaredDifference",Br="Square",Wr="StridedSlice",Ur="StringNGrams",Vr="StringSplit",jr="StringToHashBucketFast",Gr="Sub",Hr="Tan",qr="Tanh",Xr="Tile",Kr="TopK",Zr="Transform",Yr="Transpose",Jr="Unique",Qr="Unpack",ea="UnsortedSegmentSum",ta="UpperBound",na="ZerosLike",ra="Step",aa="FromPixels",sa="RotateWithOffset",oa="_FusedMatMul",ia="FusedConv2D",la="FusedDepthwiseConv2D";function ua(...e){qe().getBool("IS_TEST")||qe().getBool("PROD")||console.warn(...e)}function ca(...e){qe().getBool("IS_TEST")||qe().getBool("PROD")||console.log(...e)}var da=Ye("kernelRegistry",(()=>new Map)),ha=Ye("gradRegistry",(()=>new Map));function pa(e,t){const n=va(e,t);return da.get(n)}function fa(e){return ha.get(e)}function ma(e){const t=da.entries(),n=[];for(;;){const{done:r,value:a}=t.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===e&&n.push(o)}return n}function Aa(e){const{kernelName:t,backendName:n}=e,r=va(t,n);da.has(r)&&ua(`The kernel '${t}' for backend '${n}' is already registered`),da.set(r,e)}function ga(e){const{kernelName:t}=e;ha.has(t)&&qe().getBool("DEBUG")&&ua(`Overriding the gradient for '${t}'`),ha.set(t,e)}function ya(e,t){const n=va(e,t);if(!da.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);da.delete(n)}function xa(e){if(!ha.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);ha.delete(e)}function ba(e,t){ma(e).forEach((e=>{Aa(Object.assign({},e,{backendName:t}))}))}function va(e,t){return`${t}_${e}`}var wa={};S(wa,{arraysEqual:()=>ce,assert:()=>ae,assertNonNegativeIntegerDimensions:()=>Be,assertNonNull:()=>oe,assertShapesMatch:()=>se,bytesFromStringArray:()=>Ee,bytesPerElement:()=>Ce,checkConversionForErrors:()=>we,clamp:()=>J,computeStrides:()=>Fe,createScalarValue:()=>za,createShuffledIndices:()=>fe,decodeString:()=>Ua,distSquared:()=>re,encodeString:()=>Wa,fetch:()=>Ba,fingerPrint64:()=>Da,flatten:()=>ie,getArrayFromDType:()=>ve,getTypedArrayFromDType:()=>be,hasEncodingLoss:()=>Se,hexToLong:()=>Ia,indexToLoc:()=>Ue,inferDtype:()=>_e,inferFromImplicitShape:()=>ge,isBoolean:()=>Te,isFunction:()=>Me,isInt:()=>de,isNumber:()=>Re,isPromise:()=>Ve,isScalarShape:()=>ue,isString:()=>Ne,isTypedArray:()=>Ie,isValidDtype:()=>ke,locToIndex:()=>We,makeOnesTypedArray:()=>ze,makeZerosNestedTypedArray:()=>Le,makeZerosTypedArray:()=>Pe,nearestDivisor:()=>$e,nearestLargerEven:()=>Q,now:()=>La,parseAxisParam:()=>ye,randUniform:()=>ne,repeatedTry:()=>Ae,rightPad:()=>me,shuffle:()=>Z,shuffleCombo:()=>Y,sizeFromShape:()=>le,sizeToSquarishShape:()=>pe,squeezeShape:()=>xe,sum:()=>te,swap:()=>ee,tanh:()=>he,toNestedArray:()=>De,toTypedArray:()=>Pa});var ka=I(C()),Sa=ka.default||ka;function Ia(e){return Sa.fromString(e,!0,16)}var Ca=Ia("c3a5c85c97cb3127"),Ea=Ia("b492b66fbe98f273"),Na=Ia("9ae16a3b2f90404f");function Ta(e){return e.xor(e.shru(47))}function Ra(e,t,n){const r=e.slice(t,t+n);return Sa.fromBytes(Array.from(r),!0,!0)}function _a(e,t){return Ra(e,t,8)}function Ma(e,t){return Ra(e,t,4)}function $a(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Fa(e,t,n=Ia("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function Oa(e,t,n,r){return function(e,t,n,r,a,s){a=a.add(e),s=$a(s.add(a).add(r),21);const o=a;return a=(a=a.add(t)).add(n),s=s.add($a(a,44)),[a.add(r),s.add(o)]}(_a(e,t),_a(e,t+8),_a(e,t+16),_a(e,t+24),n,r)}function Da(e,t=e.length){const n=Sa.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=Na.add(2*t),r=_a(e,0).add(Na),a=_a(e,t-8);return Fa($a(a,37).mul(n).add(r),$a(r,25).add(a).mul(n),n)}if(t>=4){const n=Na.add(2*t);return Fa(Ma(e,0).shl(3).add(t),Ma(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return Ta(Na.mul(n).xor(Ca.mul(r))).mul(Na)}return Na}(e,t):function(e,t=e.length){const n=Na.add(2*t),r=_a(e,0).mul(Ea),a=_a(e,8),s=_a(e,t-8).mul(n),o=_a(e,t-16).mul(Na);return Fa($a(r.add(a),43).add($a(s,30)).add(o),r.add($a(a.add(Na),18)).add(s),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=Na.add(2*t),r=_a(e,0).mul(Na),a=_a(e,8),s=_a(e,t-8).mul(n),o=_a(e,t-16).mul(Na),i=$a(r.add(a),43).add($a(s,30)).add(o),l=Fa(i,r.add($a(a.add(Na),18)).add(s),n),u=_a(e,16).mul(n),c=_a(e,24),d=i.add(_a(e,t-32)).mul(n),h=l.add(_a(e,t-24)).mul(n);return Fa($a(u.add(c),43).add($a(d,30)).add(h),u.add($a(c.add(r),18)).add(d),n)}(e,t);let r=n,a=n.mul(Ea).add(113),s=Ta(a.mul(Na).add(113)).mul(Na),o=[Sa.UZERO,Sa.UZERO],i=[Sa.UZERO,Sa.UZERO];r=r.mul(Na).add(_a(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=$a(r.add(a).add(o[0]).add(_a(e,l+8)),37).mul(Ea),a=$a(a.add(o[1]).add(_a(e,l+48)),42).mul(Ea),r=r.xor(i[1]),a=a.add(o[0]).add(_a(e,l+40)),s=$a(s.add(i[0]),33).mul(Ea),o=Oa(e,l,o[1].mul(Ea),r.add(i[0])),i=Oa(e,l+32,s.add(i[1]),a.add(_a(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);const d=Ea.add(s.and(255).shl(1));return l=c,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=$a(r.add(a).add(o[0]).add(_a(e,l+8)),37).mul(d),a=$a(a.add(o[1]).add(_a(e,l+48)),42).mul(d),r=r.xor(i[1].mul(9)),a=a.add(o[0].mul(9).add(_a(e,l+40))),s=$a(s.add(i[0]),33).mul(d),o=Oa(e,l,o[1].mul(d),r.add(i[0])),i=Oa(e,l+32,s.add(i[1]),a.add(_a(e,l+16))),[s,r]=[r,s],Fa(Fa(o[0],i[0],d).add(Ta(a).mul(Ca)).add(s),Fa(o[1],i[1],d).add(r),d)}function za(e,t){return"string"===t?Wa(e):Pa([e],t)}function Pa(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ie(e)),qe().getBool("DEBUG")&&we(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function La(){return qe().platform.now()}function Ba(e,t){return qe().platform.fetch(e,t)}function Wa(e,t="utf-8"){return t=t||"utf-8",qe().platform.encode(e,t)}function Ua(e,t="utf-8"){return t=t||"utf-8",qe().platform.decode(e,t)}function Va(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}var ja=class{logKernelProfile(e,t,n,r,a,s){const o="number"==typeof r?me(`${r}ms`,9):r.error,i=me(e,25),l=t.rank,u=t.size,c=me(t.shape.toString(),14);let d="";for(const e in a){const n=a[e];if(null!=n){const r=n.shape||t.shape,a=r.length;d+=`${e}: ${a}D ${a>0?r:""} `}}console.log(`%c${i}\t%c${o}\t%c${l}D ${c}\t%c${u}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function Ga(e,t,n,r){const a=Fe(t),s=function(e,t,n,r){const a=le(t),s=r[r.length-1],o=new Array(s).fill(0),i=t.length,l="complex64"===n?Ka(e):e;if(i>1)for(let e=0;e<a/s;e++){const t=e*s;for(let e=0;e<s;e++)o[e]=Math.max(o[e],Ha(l[t+e],0,n).length)}return o}(e,t,n,a),o=t.length,i=Xa(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(i.map((e=>"    "+e)).join("\n")),l.join("\n")}function Ha(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Ne(e)?`'${e}'`:"bool"===n?qa(e):parseFloat(e.toFixed(7)).toString(),me(r,t)}function qa(e){return 0===e?"false":"true"}function Xa(e,t,n,r,a,s=!0){const o="complex64"===n?2:1,i=t[0],l=t.length;if(0===l){if("complex64"===n){return[Ha(Ka(e)[0],0,n)]}return"bool"===n?[qa(e[0])]:[e[0].toString()]}if(1===l){if(i>20){const t=3*o;let r=Array.from(e.slice(0,t)),s=Array.from(e.slice((i-3)*o,i*o));return"complex64"===n&&(r=Ka(r),s=Ka(s)),["["+r.map(((e,t)=>Ha(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>Ha(e,a[i-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?Ka(e):Array.from(e)).map(((e,t)=>Ha(e,a[t],n))).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*o,h=[];if(i>20){for(let t=0;t<3;t++){const r=t*d,s=r+d;h.push(...Xa(e.slice(r,s),u,n,c,a,!1))}h.push("...");for(let t=i-3;t<i;t++){const r=t*d,s=r+d;h.push(...Xa(e.slice(r,s),u,n,c,a,t===i-1))}}else for(let t=0;t<i;t++){const r=t*d,s=r+d;h.push(...Xa(e.slice(r,s),u,n,c,a,t===i-1))}const p=2===l?",":"";h[0]="["+h[0]+p;for(let e=1;e<h.length-1;e++)h[e]=" "+h[e]+p;let f=",\n";for(let e=2;e<l;e++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function Ka(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Za=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=le(e),null!=n){const e=n.length;ae(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ve(t,this.size),this.strides=Fe(e)}set(e,...t){0===t.length&&(t=[0]),ae(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ya().makeTensor(this.values,this.shape,this.dtype)}},Ya=null,Ja=null;var Qa=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=le(e),this.strides=Fe(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Ja.buffer(this.shape,this.dtype,e)}bufferSync(){return Ja.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return De(this.shape,e,"complex64"===this.dtype)}arraySync(){return De(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Ya().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>Ua(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ya().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ya().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Ua(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ya().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Ya().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Ja.print(this,e)}clone(){return this.throwIfDisposed(),Ja.clone(this)}toString(e=!1){return Ga(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ja.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ya().makeVariable(this,e,t,n)}};function es(){return Ye("Tensor",(()=>Qa))}Object.defineProperty(Qa,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),es();var ts=class extends Qa{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ce(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ya().disposeTensor(this),this.dataId=e.dataId,Ya().incRef(this,null)}dispose(){Ya().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(ts,Symbol.hasInstance,{value:e=>e instanceof Qa&&null!=e.assign&&e.assign instanceof Function});var ns,rs,as,ss,os,is,ls,us,cs,ds,hs={};S(hs,{assertTypesMatch:()=>gs,getTensorsInContainer:()=>xs,isTensorInList:()=>ys,makeTypesMatch:()=>As}),(rs=ns||(ns={})).R0="R0",rs.R1="R1",rs.R2="R2",rs.R3="R3",rs.R4="R4",rs.R5="R5",rs.R6="R6",(ss=as||(as={})).float32="float32",ss.int32="int32",ss.bool="int32",ss.complex64="complex64",(is=os||(os={})).float32="float32",is.int32="int32",is.bool="bool",is.complex64="complex64",(us=ls||(ls={})).float32="float32",us.int32="float32",us.bool="float32",us.complex64="complex64",(ds=cs||(cs={})).float32="complex64",ds.int32="complex64",ds.bool="complex64",ds.complex64="complex64";var ps={float32:ls,int32:as,bool:os,complex64:cs};function fs(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return ps[e][t]}function ms(e){return fs(e,"int32")}function As(e,t){if(e.dtype===t.dtype)return[e,t];const n=fs(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function gs(e,t){ae(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function ys(e,t){return t.some((t=>t.id===e.id))}function xs(e){const t=[];return bs(e,t,new Set),t}function bs(e,t,n){if(null==e)return;if(e instanceof Qa)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const a=e;for(const e in a){const r=a[e];n.has(r)||(n.add(r),bs(r,t,n))}}function vs(e){return null!=e.kernelName}var ws=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}},ks=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ws}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(ua(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new ja)}profileKernel(e,t,n){let r;const a=()=>{r=n()};let s;const o=La();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const e of r)e.dataSync();s=Promise.resolve({kernelMs:La()-o})}if(qe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{Va(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}(this.backendInstance),!0}setupRegisteredKernels(){ma(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){ma(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof X||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,ua(`Initialization of backend ${e} failed`),ua(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return ua(`Initialization of backend ${e} failed`),ua(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return ks.nextTensorId++}nextVariableId(){return ks.nextVariableId++}clone(e){const t=Is.runKernel(pn,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Is.runKernel(vt,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=pa(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-a-s;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=vs(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(vs(e)){const{kernelName:t,inputs:a,attrs:s}=e;null==this.backendName&&this.backend;const l=pa(t,this.backendName);ae(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),o=()=>{const e=this.backend.numDataIds();i=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,o);const u=o.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,a,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,a=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};o=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,a)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,d=vs(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(l,u,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=o()})),r&&this.addTapeNode(l,u,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const r=fa(e);if(null!=r){const e=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(ae(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const o=n.filter(((e,t)=>a[t]));return s.concat(o)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&Ne(e[0])&&(a=e.map((e=>Wa(e))));const s=r.write(a,t,n),o=new Qa(t,n,s,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){const e=this.state.tensorInfo.get(s),t=Ee(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,r){const a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:a}=e,s=new Qa(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const a=new ts(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Ce(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof ts||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Ce(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},i=fa(e);null!=i&&(r=i.gradFunc),null!=r&&(o.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=Pe(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=xs(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(ae(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));ae(a instanceof Qa,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const r={},a={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const s=e[n],o=s.inputs;for(const e in o){const n=o[e];let i=!1;for(let e=0;e<t.length;e++)if(r[n.id]){s.outputs.forEach((e=>r[e.id]=!0)),i=!0,a[s.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(s[n.outputs[e].id]){for(const e in r)s[r[e].id]=!0,o[n.id]=!0;break}}const i=[];for(let t=0;t<e.length;t++){const n=e[t];if(a[n.id]&&o[n.id]){const e={};for(const t in n.inputs){const a=n.inputs[t];r[a.id]&&(e[t]=a)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,i.push(t)}}return i}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[a.id]=null==n?function(e){const t=ze(le(e),"float32");return Is.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){const s=t[a],o=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const i=s.gradient(o);for(const t in s.inputs){if(!(t in i))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(i)}.`);const a=n((()=>i[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);const o=s.inputs[t];if(!ce(a.shape,o.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=a;else{const t=e[o.id];e[o.id]=r(t,a),t.dispose()}}}}(e,s,(e=>this.tidy(e)),Cs);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){return ae(Me(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;ae(t.every((e=>e instanceof Qa)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};t.forEach(((e,t)=>{r[t]=e}));return this.runKernelFunc({forwardFunc:(r,a)=>(n=e(...t,a),ae(n.value instanceof Qa,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),ae(Me(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const a=n.gradFunc(e,r),s=Array.isArray(a)?a:[a];ae(s.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),ae(s.every((e=>e instanceof Qa)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return s.forEach(((e,t)=>{o[t]=()=>e})),o},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=La(),n=await this.backend.time(e);return n.wallMs=La()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ws;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function Ss(){const e=Ze();if(null==e._tfengine){const t=new Ge(e);e._tfengine=new ks(t)}var t;return t=e._tfengine.ENV,Ke=t,Ya=()=>e._tfengine,e._tfengine}ks.nextTensorId=0,ks.nextVariableId=0;var Is=Ss();function Cs(e,t){const n={a:e,b:t};return Is.runKernel(tt,n)}var Es,Ns={};function Ts(e){Es=e}function Rs(e){if(void 0!==Es)return Es;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function _s(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}S(Ns,{isBrowser:()=>_s,isMobile:()=>Rs,mockIsMobile:()=>Ts});var Ms=qe();function $s(e,t){let n=e;if(Ie(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||Ie(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&qe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Fs(e,r,[]),r}function Fs(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ie(e))return void ae(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));ae(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),ae(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)Fs(e[t],r,n.concat(t))}function Os(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Ds(e,t,n,r="numeric"){if(e instanceof Qa)return Os(r,e.dtype,t,n),e;let a=_e(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),Os(r,a,t,n),null==e||!Ie(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const s=$s(e,a);Ie(e)||Array.isArray(e)||(e=[e]);const o="string"!==a?Pa(e,a):ie(e,[],!0);return Is.makeTensor(o,s,a)}function zs(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>Ds(e,`${t}[${a}]`,n,r)))}Ms.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Ms.registerFlag("IS_BROWSER",(()=>_s())),Ms.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),Ms.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Ms.registerFlag("PROD",(()=>!1)),Ms.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Ms.getBool("DEBUG"))),Ms.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Ms.registerFlag("IS_TEST",(()=>!1)),Ms.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),Ms.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Ms.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var Ps="__op";function Ls(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Ps;const a=(...e)=>{Is.startScope(n);try{const t=r(...e);return Ve(t)&&console.error("Cannot return a Promise inside of tidy."),Is.endScope(t),t}catch(e){throw Is.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}var Bs=Ls({complex_:function(e,t){const n=Ds(e,"real","complex"),r=Ds(t,"imag","complex");se(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const a={real:n,imag:r};return Is.runKernel(St,a)}});function Ws(e,t,n,r){if(null==r&&(r=_e(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Ie(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Be(t);const e=le(t),r=le(n);ae(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],a=e!==n.length-1||r!==le(t.slice(e));ae(n[e]===t[e]||!a,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return Ie(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?Pa(e,r):ie(e,[],!0),Is.makeTensor(e,t,r)}function Us(e,t,n){return Ws(e,t,$s(e,n),n)}var Vs={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function js(e,t){const n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<a.length;++s){const o=a[s],i=Array.isArray(e)?e[s].tensor:e[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${i.dtype}`);const l={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise((async e=>{const t=await i.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,r=new Uint8Array(n);let a=0;for(let e=0;e<t.length;e++){const n=t[e],s=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(s,a),a+=4,r.set(n,a),a+=n.length}e(r)}));r.push(e)}else r.push(i.data());null!=t&&(l.group=t),n.push(l)}return{data:Hs(await Promise.all(r)),specs:n}}function Gs(e,t){const n={};let r,a=0;for(const s of t){const t=s.name,o=s.dtype,i=s.shape,l=le(i);let u;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${s.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${s.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${o}.`)}const i=Vs[n.dtype],c=e.slice(a,a+l*i),d="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(d.length);for(let e=0;e<d.length;e++){const t=d[e];u[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=eo()),u=r(d)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${t}': ${o}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(d.length);for(let e=0;e<d.length;e++){const t=d[e];u[e]=Math.round(t*n.scale+n.min)}}a+=l*i}else if("string"===o){const t=le(s.shape);u=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(a,a+4))[0];a+=4;const n=new Uint8Array(e.slice(a,a+t));u.push(n),a+=t}}else{const r=Vs[o],s=e.slice(a,a+l*r);if("float32"===o)u=new Float32Array(s);else if("int32"===o)u=new Int32Array(s);else if("bool"===o)u=new Uint8Array(s);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${t}': ${o}`);{u=new Float32Array(s);const e=new Float32Array(u.length/2),r=new Float32Array(u.length/2);for(let t=0;t<e.length;t++)e[t]=u[2*t],r[t]=u[2*t+1];const a=Us(e,i,"float32"),o=Us(r,i,"float32");n[t]=Bs(a,o),a.dispose(),o.dispose()}}a+=l*r}"complex64"!==o&&(n[t]=Us(u,i,o))}return n}function Hs(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}var qs="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Xs(e){return qs?Buffer.byteLength(e):new Blob([e]).size}function Ks(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let r=0;return e.forEach((e=>{n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function Zs(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function Ys(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function Js(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),null!=e.weightsManifest){const[r,a]=await t(e.weightsManifest);n.weightSpecs=r,n.weightData=a}return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),n}function Qs(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:Xs(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:Xs(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function eo(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let a=0;a<r.length;a++){const o=r[a],i=e[n[o>>10]+(1023&o)]+t[o>>10];s[a]=i}return new Float32Array(a)}}var to=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==to.instance&&(to.instance=new to),to.instance}static registerSaveRouter(e){to.getInstance().saveRouters.push(e)}static registerLoadRouter(e){to.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return to.getHandlers(e,"save")}static getLoadHandlers(e,t){return to.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?to.getInstance().loadRouters:to.getInstance().saveRouters).forEach((t=>{const a=t(e,n);null!==a&&r.push(a)})),r}},no=e=>to.registerSaveRouter(e),ro=e=>to.registerLoadRouter(e),ao=e=>to.getSaveHandlers(e),so=(e,t)=>to.getLoadHandlers(e,t),oo="tensorflowjs",io="models_store",lo="model_info_store";function uo(){if(!qe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function co(e){const t=e.result;t.createObjectStore(io,{keyPath:"modelPath"}),t.createObjectStore(lo,{keyPath:"modelPath"})}var ho=class{constructor(e){if(this.indexedDB=uo(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(oo,1);r.onupgradeneeded=()=>co(r),r.onsuccess=()=>{const a=r.result;if(null==t){const t=a.transaction(io,"readonly"),r=t.objectStore(io).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{const r=Qs(t),s=a.transaction(lo,"readwrite");let o=s.objectStore(lo);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;i.onsuccess=()=>{l=a.transaction(io,"readwrite");const i=l.objectStore(io).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});i.onsuccess=()=>e({modelArtifactsInfo:r}),i.onerror=e=>{o=s.objectStore(lo);const t=o.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(i.error)),t.onerror=e=>(a.close(),n(i.error))}},i.onerror=e=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}};ho.URL_SCHEME="indexeddb://";var po=e=>{return qe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ho.URL_SCHEME)?(t=e.slice(ho.URL_SCHEME.length),new ho(t)):null;var t};to.registerSaveRouter(po),to.registerLoadRouter(po);var fo="/",mo="tensorflowjs_models",Ao="info",go="model_topology",yo="weight_specs",xo="weight_data",bo="model_metadata";function vo(e){return{info:[mo,e,Ao].join(fo),topology:[mo,e,go].join(fo),weightSpecs:[mo,e,yo].join(fo),weightData:[mo,e,xo].join(fo),modelMetadata:[mo,e,bo].join(fo)}}function wo(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function ko(e){const t=e.split(fo);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(fo)}var So=class{constructor(e){if(!qe().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=vo(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=Qs(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(qs)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(e){throw wo(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(qs){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(s),t}};So.URL_SCHEME="localstorage://";var Io=e=>{return qe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(So.URL_SCHEME)?(t=e.slice(So.URL_SCHEME.length),new So(t)):null;var t};to.registerSaveRouter(Io),to.registerLoadRouter(Io);var Co="://",Eo=class{constructor(){this.managers={}}static getInstance(){return null==Eo.instance&&(Eo.instance=new Eo),Eo.instance}static registerManager(e,t){ae(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Co)&&(e=e.slice(0,e.indexOf(Co))),ae(e.length>0,(()=>"scheme must not be an empty string."));const n=Eo.getInstance();ae(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Eo.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Eo.getInstance().managers)}};function No(e){if(-1===e.indexOf(Co))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Eo.getSchemes().join(",")}`);return{scheme:e.split(Co)[0],path:e.split(Co)[1]}}async function To(e,t,n=!1){ae(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=to.getLoadHandlers(e);ae(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),ae(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const a=r[0],s=to.getSaveHandlers(t);ae(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),ae(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const o=s[0],i=No(e).scheme,l=No(e).path,u=i===No(e).scheme,c=await a.load();n&&u&&await Eo.getManager(i).removeModel(l);const d=await o.save(c);return n&&!u&&await Eo.getManager(i).removeModel(l),d.modelArtifactsInfo}async function Ro(){const e=Eo.getSchemes(),t={};for(const n of e){const e=await Eo.getManager(n).listModels();for(const r in e){t[n+Co+r]=e[r]}}return t}async function _o(e){const t=No(e);return Eo.getManager(t.scheme).removeModel(t.path)}async function Mo(e,t){return To(e,t,!1)}async function $o(e,t){return To(e,t,!0)}if(qe().get("IS_BROWSER")){qe().setPlatform("browser",new class{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}});try{Eo.registerManager(So.URL_SCHEME,new class{constructor(){ae(qe().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),ae("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=mo+fo,n=fo+Ao;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);a.startsWith(t)&&a.endsWith(n)&&(e[ko(a)]=JSON.parse(this.LS.getItem(a)))}return e}async removeModel(e){var t;const n=vo(e=(t=e).startsWith(So.URL_SCHEME)?t.slice(So.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return wo(n),r}})}catch(e){}try{Eo.registerManager(ho.URL_SCHEME,new class{constructor(){this.indexedDB=uo()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(oo,1);n.onupgradeneeded=()=>co(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(lo,"readonly"),s=a.objectStore(lo).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(ho.URL_SCHEME)?t.slice(ho.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(oo,1);r.onupgradeneeded=()=>co(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(lo,"readwrite"),o=s.objectStore(lo),i=o.get(e);let l;i.onsuccess=()=>{if(null==i.result)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=o.delete(e),s=()=>{l=a.transaction(io,"readwrite");const r=l.objectStore(io).delete(e);r.onsuccess=()=>t(i.result.modelArtifactsInfo),r.onerror=e=>n(i.error)};r.onsuccess=s,r.onerror=e=>(s(),a.close(),n(i.error))}},i.onerror=e=>(a.close(),n(i.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=e=>n(r.error)}))}})}catch(e){}}var Fo,Oo=()=>E();function Do(e,t="float32",n){return t=t||"float32",Be(e),new Za(e,t,n)}qe().get("IS_NODE")&&!qe().get("IS_BROWSER")&&qe().setPlatform("node",new class{constructor(){this.util=N(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=qe().global.fetch?qe().global.fetch(e,t):(null==Fo&&(Fo=Oo()),Fo(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});var zo=Ls({cast_:function(e,t){const n=Ds(e,"x","cast");if(!ke(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:t};return Is.runKernel(vt,r,a)}});var Po=Ls({clone_:function(e){const t={x:Ds(e,"x","clone","string_or_numeric")};return Is.runKernel(pn,t)}});function Lo(e,t=!1){console.log(e.toString(t))}Ss(),Ja={buffer:Do,cast:zo,clone:Po,print:Lo};var Bo={};S(Bo,{browserFiles:()=>Vo,browserHTTPRequest:()=>Jo,concatenateArrayBuffers:()=>Ks,copyModel:()=>Mo,decodeWeights:()=>Gs,encodeWeights:()=>js,fromMemory:()=>ni,fromMemorySync:()=>ri,getLoadHandlers:()=>so,getModelArtifactsForJSON:()=>Js,getModelArtifactsInfoForJSON:()=>Qs,getSaveHandlers:()=>ao,http:()=>Yo,isHTTPScheme:()=>Ko,listModels:()=>Ro,loadWeights:()=>Ho,moveModel:()=>$o,registerLoadRouter:()=>ro,registerSaveRouter:()=>no,removeModel:()=>_o,weightsLoaderFactory:()=>qo,withSaveHandler:()=>ai,withSaveHandlerSync:()=>si});function Wo(e){return new Promise((e=>setTimeout(e))).then(e)}var Uo=class{constructor(e){if(!qe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Uo.URL_SCHEME)&&(e=e.slice(Uo.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=Ys(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await Wo((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await Wo((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Qs(e)}}}};Uo.URL_SCHEME="downloads://";function Vo(e){return new class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});const s=Js(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const r of e)t.push(...r.weights),n.push(...r.paths);const r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,Ks(e)]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const a=new FileReader;a.onload=e=>{const t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>Zs(e.name))),r={};for(const a of e)a.paths.forEach((e=>{const a=Zs(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}(e)}function jo(e,t,n,r){var a,s,o;ae(null!=(a=e)&&Array.isArray(a)&&a.length>0,(()=>"promises must be a none empty array")),o=r=null==r?1:r,ae((s=n=null==n?0:n)>=0&&s<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${s}`)),ae(o>=0&&o<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${o}`)),ae(o>=s,(()=>`startFraction must be no more than endFraction, but got startFraction ${s} and endFraction ${o}`));let i=0;return Promise.all(e.map((a=>(a.then((a=>{const s=n+ ++i/e.length*(r-n);return t(s),a})),a))))}async function Go(e,t){null==t&&(t={});const n=null==t.fetchFunc?qe().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await jo(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await jo(a,t.onProgress,.5,1)}async function Ho(e,t="",n,r){return qo((e=>Go(e,{requestInit:r})))(e,t,n)}function qo(e){return async(t,n="",r)=>{const a=t.map((()=>!1)),s={},o=null!=r?r.map((()=>!1)):[],i=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=Vs[l]*le(e.shape),c=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),o[n]=!0)})):c(),i.push(e.name),n+=u}))})),!o.every((e=>e))){const e=r.filter(((e,t)=>!o[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${i.join(", ")}.`)}const l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));const c=await e(u),d={};let h=0;return l.forEach((e=>{const n=t[e].paths.length;let r=0;for(let e=0;e<n;e++)r+=c[h+e].byteLength;const a=new ArrayBuffer(r),o=new Uint8Array(a);let i=0;for(let e=0;e<n;e++){const t=new Uint8Array(c[h+e]);o.set(t,i),i+=t.byteLength}s[e].forEach((e=>{const t=Gs(a.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const e in t)d[e]=t[e]})),h+=n})),d}}to.registerSaveRouter((e=>qe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Uo.URL_SCHEME)?function(e="model"){return new Uo(e)}(e.slice(Uo.URL_SCHEME.length)):null));var Xo=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(ae("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=qe().platform.fetch,ae(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&ae(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=Ys(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Qs(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Js(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,s=[];for(const t of e)s.push(...t.weights);const o=[],i=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):o.push(a+e+r);this.weightUrlConverter&&o.push(...await Promise.all(i));return[s,Ks(await Go(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}};function Ko(e){return null!=e.match(Xo.URL_SCHEME_REGEX)}Xo.URL_SCHEME_REGEX=/^https?:\/\//;var Zo=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Ko(e))):Ko(e),n)return Yo(e,t)}return null};function Yo(e,t){return new Xo(e,t)}function Jo(e,t){return Yo(e,t)}to.registerSaveRouter(Zo),to.registerLoadRouter(Zo);var Qo=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},ei=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},ti=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function ni(e,t,n,r){const a=arguments;return new ti(ri(...a))}function ri(e,t,n,r){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new Qo(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Qo({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Qo({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function ai(e){return new ei(e)}function si(e){return new ei(e)}var oi={};S(oi,{confusionMatrix:()=>Fi});var ii=Ls({matMul_:function(e,t,n=!1,r=!1){let a=Ds(e,"a","matMul"),s=Ds(t,"b","matMul");[a,s]=As(a,s);const o={a:a,b:s},i={transposeA:n,transposeB:r};return Is.runKernel(At,o,i)}});var li=Ls({oneHot_:function(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:Ds(e,"indices","oneHot","int32")},s={depth:t,onValue:n,offValue:r};return Is.runKernel(Qn,a,s)}});function ui(){qe().set("PROD",!0)}function ci(){qe().set("DEBUG",!0)}function di(){qe().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function hi(e){qe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function pi(){Is.disposeVariables()}function fi(){return Is}function mi(){return Is.memory()}function Ai(e){return Is.profile(e)}function gi(e,t){return Is.tidy(e,t)}function yi(e){xs(e).forEach((e=>e.dispose()))}function xi(e){return Is.keep(e)}function bi(e){return Is.time(e)}function vi(e){return Is.setBackend(e)}function wi(){return Is.ready()}function ki(){return Is.backendName}function Si(e){Is.removeBackend(e)}function Ii(e){return Is.findBackend(e)}function Ci(e){return Is.findBackendFactory(e)}function Ei(e,t,n=1){return Is.registerBackend(e,t,n)}function Ni(){return Is.backend}function Ti(e,t){qe().setPlatform(e,t)}var Ri=Ls({imag_:function(e){const t={input:Ds(e,"input","imag")};return Is.runKernel(mn,t)}});var _i=Ls({neg_:function(e){const t={x:Ds(e,"x","neg")};return Is.runKernel(qn,t)}});var Mi=Ls({real_:function(e){const t={input:Ds(e,"input","real")};return Is.runKernel(ir,t)}});var $i=Ls({transpose_:function(e,t,n){const r=Ds(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),ae(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{ae(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();const a={x:r},s={perm:t};return"complex64"===r.dtype?gi((()=>{let e=Mi(r),t=Ri(r);return e=Is.runKernel(Yr,{x:e},s),t=Is.runKernel(Yr,{x:t},s),n&&(t=_i(t)),Bs(e,t)})):Is.runKernel(Yr,a,s)}});var Fi=Ls({confusionMatrix_:function(e,t,n){const r=Ds(e,"labels","confusionMatrix"),a=Ds(t,"predictions","confusionMatrix");ae(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),ae(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),ae(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),ae(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),ae(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const s=li(zo(r,"int32"),n),o=li(zo(a,"int32"),n),i=$i(s),l=ii(i,o);return zo(l,"int32")}}),Oi={};function Di(e,t){const n=e.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,o=e[s]||1;(t[t.length-1-a]||1)>1&&1===o&&r.unshift(s)}return r}function zi(e,t){const n=[];for(let r=0;r<t.length;r++){const a=e[e.length-r-1],s=t.length-r-1,o=t[s];(null==a||1===a&&o>1)&&n.unshift(s)}return n}function Pi(e,t){const n=[],r=Math.max(e.length,t.length);for(let a=0;a<r;a++){let r=e[e.length-a-1];null==r&&(r=1);let s=t[t.length-a-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}n.unshift(r)}}return n}S(Oi,{assertAndGetBroadcastShape:()=>Pi,getBroadcastDims:()=>Di,getReductionAxes:()=>zi});var Li,Bi={};function Wi(e,t,n){if(oe(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=$s(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ws(e,t,r,n)}function Ui(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,o=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)o=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);i=!0}if(a){const t=2;if(a&&e.readyState<t)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=pa(aa,Is.backendName)){const n={pixels:e},r={numChannels:t};return Is.runKernel(aa,n,r)}const[l,u]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(o)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(s||a||i){if(null==Li)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Li=new OffscreenCanvas(1,1).getContext("2d")}else Li=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Li.canvas.width=l,Li.canvas.height=u,Li.drawImage(e,0,0,l,u),c=Li.getImageData(0,0,l,u).data}if(4===t)d=new Int32Array(c);else{const e=l*u;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}return Wi(d,[u,l,t],"int32")}function Vi(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function ji(e,t=3){let n=null;if(qe().getBool("WRAP_TO_IMAGEBITMAP")&&Vi(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return Ui(n,t)}async function Gi(e,t){let n=Ds(e,"img","toPixels");if(!(e instanceof Qa)){const e=n;n=zo(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const o=await n.data(),i="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let e=0;e<r*a;++e){const t=[0,0,0,255];for(let r=0;r<s;r++){const a=o[e*s+r];if("float32"===n.dtype){if(a<0||a>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${a}.`)}else if("int32"===n.dtype&&(a<0||a>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${a}.`);1===s?(t[0]=a*i,t[1]=a*i,t[2]=a*i):t[r]=a*i}const r=4*e;l[r+0]=Math.round(t[0]),l[r+1]=Math.round(t[1]),l[r+2]=Math.round(t[2]),l[r+3]=Math.round(t[3])}if(null!=t){t.width=a,t.height=r;const e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}S(Bi,{fromPixels:()=>Hi,fromPixelsAsync:()=>ji,toPixels:()=>Gi});var Hi=Ls({fromPixels_:Ui}),qi={};function Xi(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===le(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const a=t.shape,s=a[a.length-1];let o=1;for(let e=0;e<a.length-1;++e)o*=a[e];const i=e.shape,l=a.slice();l.pop();let u=1;for(let e=s;e<n;++e)u*=i[e],l.push(i[e]);const c=[...Fe(e.shape).map((e=>e/u)),1].slice(0,s);return[l,o,u,c]}S(qi,{prepareAndValidate:()=>Xi});var Ki={};function Zi(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let e=0;e<a;++e)if(n.shape[e]!==t.shape[e])throw new Error(s+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-a;++t)if(n.shape[t+a]!==e[t+r])throw new Error(s+` updates.shape[${t+a}] (${n.shape[t+a]}) != shape[${t+a}] (${e[t+a]})`)}function Yi(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Zi(n,t,e)}function Ji(e,t,n){const r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length;let o=1;for(let e=a;e<s;++e)o*=n[e];const i=a<1?1:a;return{sliceRank:a,numUpdates:le(t.shape)/i,sliceSize:o,strides:[...Fe(n.slice(0,a)),1],outputSize:le(n)}}S(Ki,{calculateShapes:()=>Ji,validateInput:()=>Yi,validateUpdateShape:()=>Zi});var Qi={};S(Qi,{assertParamsValid:()=>el,computeFlatOffset:()=>pl,computeOutShape:()=>nl,getNormalizedAxes:()=>ol,isSliceContinous:()=>hl,maskToAxes:()=>tl,parseSliceParams:()=>fl,sliceInfo:()=>ml,startForAxis:()=>cl,startIndicesWithElidedDims:()=>il,stopForAxis:()=>dl,stopIndicesWithElidedDims:()=>ll,stridesForAxis:()=>ul,stridesWithElidedDims:()=>rl});function el(e,t,n){const r=e.shape.length;ae(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),ae(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)ae(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function tl(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function nl(e,t,n){const r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function rl(e,t,n,r){const a=[...e];for(let e=a.length;e<r.length;e++)a.push(1);for(let e=0;e<n;e++)0===e?a[t]=1:(a.splice(t,0,1),a.pop());return a}function al(e,t,n){return n<=e?n:n-(t-1)}function sl(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function ol(e,t,n,r,a,s,o,i,l){const u=e.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=il(o,l,u,r,e),d=ll(i,l,u,a,e),h=rl(s,l,u,e)}else for(let t=0;t<u;t++)c[t]=cl(o,r,s,e,t,l),d[t]=dl(i,a,s,e,t,l),h[t]=ul(s,t,l);return{begin:c,end:d,strides:h}}function il(e,t,n,r,a){const s=[...a],o=sl(n,t);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=0;else{const o=al(t,n,a);let i=r[o];e&1<<o&&(i=0),s[a]=i}return s}function ll(e,t,n,r,a){const s=[...a],o=sl(n,t);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{const o=al(t,n,a);let i=r[o];e&1<<o&&(i=Number.MAX_SAFE_INTEGER),s[a]=i}for(let e=0;e<s.length;e++){const t=a[e];s[e]<0&&(s[e]+=t),s[e]=J(0,s[e],a[e])}return s}function ul(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function cl(e,t,n,r,a,s){let o=t[a];const i=n[a]||1;(e&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[a];return o<0&&(o+=l),o=J(0,o,l-1),o}function dl(e,t,n,r,a,s){let o=t[a];const i=n[a]||1;(e&1<<a||s&1<<a||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[a];return o<0&&(o+=l),o=i>0?J(0,o,l):J(-1,o,l-1),o}function hl(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function pl(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function fl(e,t,n){let r;const a=e.shape.length;let s;return r="number"==typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),r.forEach((e=>{ae(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"==typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:(ae(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,s]}function ml(e,t,n,r,a,s,o,i,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=o&&0!=(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};for(let e=0;e<d.dims;e++)c&&0!=(1<<e&i)&&d.numAddAxisAfterEllipsis++,1<<e&o&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0;const A=[],g=[];for(let t=0;t<e.length;++t){if(0===h.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(h.shrinkAxisMask&1<<t),r=e[t];if(-1===r){A.push(n?1:-1);continue}const a=[h.beginMask&1<<t,h.endMask&1<<t],s=[h.strides[t]>0?0:-1,h.strides[t]>0?r:r-1];if(n&&h.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[t];const o=!!(h.beginMask&1<<t&&h.endMask&1<<t);if(h.beginValid&&h.endValid){if(n){const e=h.begin[t]<0?r+h.begin[t]:h.begin[t];if(h.begin[t]=e,h.end[t]=h.begin[t]+1,e<0||e>=r)throw Error(`slice index ${h.begin[t]} of dimension ${t} out of bounds.`)}else h.begin[t]=Al(h.begin[t],0,h.strides[t],r,a,s),h.end[t]=Al(h.end[t],1,h.strides[t],r,a,s);const e=1===h.strides[t]&&0===h.begin[t]&&h.end[t]===r;p=p&&e,f=f&&(0===t&&1===h.strides[t]||e)}else p=p&&1===h.strides[t]&&o,f=f&&(0===t&&1===h.strides[t]||o);let i,l=!1;if(h.beginValid&&h.endValid?(i=h.end[t]-h.begin[t],l=!0):n?(i=1,l=!0):o&&r>=0&&(i=h.strides[t]<0?-r:r,l=!0),l){let e;e=0===i||i<0!=h.strides[t]<0?0:Math.trunc(i/h.strides[t])+(i%h.strides[t]!=0?1:0),A.push(e)}else A.push(-1)}for(let e=0;e<h.finalShapeGatherIndices.length;++e){const t=h.finalShapeGatherIndices[e];t>=0?g.push(A[t]):-2===t&&g.push(1)}return{finalShapeSparse:g.filter(((e,t)=>-2!==h.finalShapeGatherIndices[t])),finalShape:g,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function Al(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{const t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}var gl={};S(gl,{Serializable:()=>yl,SerializationMap:()=>xl,registerClass:()=>bl});var yl=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},xl=class{constructor(){this.classNameMap={}}static getMap(){return null==xl.instance&&(xl.instance=new xl),xl.instance}static register(e){xl.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function bl(e){ae(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),ae("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),ae(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),xl.register(e)}var vl={};S(vl,{TEST_EPSILON_FLOAT16:()=>wl,encodeStrings:()=>Ml,expectArrayBuffersEqual:()=>_l,expectArraysClose:()=>kl,expectArraysEqual:()=>El,expectNumbersClose:()=>Nl,expectPromiseToFail:()=>Cl,expectValuesInRange:()=>Rl,testEpsilon:()=>Sl});var wl=.1;function kl(e,t,n){return null==n&&(n=Sl()),Il(e,t,((e,t)=>Tl(e,t,n)))}function Sl(){return 32===Is.backend.floatPrecision()?.001:wl}function Il(e,t,n){let r=!0;if((Ie(e)||Ie(t))&&(r=!1),Ie(e)&&Ie(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=$s(e),r=$s(t);if(!ce(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const a=Ie(e)?e:ie(e),s=Ie(t)?t:ie(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.\nActual:   ${a}.\nExpected: ${s}.`);for(let e=0;e<s.length;++e){const t=a[e],r=s[e];if(!n(t,r))throw new Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${r}.\nActual:   ${a}.\nExpected: ${s}.`)}}function Cl(e,t){e().then((()=>t.fail()),(()=>t()))}function El(e,t){const n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return Ne(e)||Ne(e[0])||Ne(t)||Ne(t[0])?Il(e,n,((e,t)=>e==t)):Il(e,t,((e,t)=>Tl(e,t,0)))}function Nl(e,t,n){if(null==n&&(n=Sl()),!Tl(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`)}function Tl(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Rl(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function _l(e,t){const n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let e=0;e<r.length;e++)if(n[e]!==r[e])throw new Error(`Expected ArrayBuffer value at ${e} to be ${r[e]} but got ${n[e]} instead`)}function Ml(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?Ml(n):e[t]=Wa(n)}return e}var $l="3.19.0";var Fl=Ls({add_:function(e,t){let n=Ds(e,"a","add"),r=Ds(t,"b","add");[n,r]=As(n,r);const a={a:n,b:r};return Is.runKernel(tt,a)}});var Ol=Ls({floorDiv_:function(e,t){let n=Ds(e,"a","floorDiv"),r=Ds(t,"b","floorDiv");[n,r]=As(n,r);const a={a:n,b:r};return Is.runKernel(on,a)}});var Dl=Ls({div_:function(e,t){let n=Ds(e,"a","div"),r=Ds(t,"b","div");if([n,r]=As(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Ol(n,r);const a={a:n,b:r};return Is.runKernel(qt,a,{})}});var zl=Ls({mul_:function(e,t){let n=Ds(e,"a","mul"),r=Ds(t,"b","mul");[n,r]=As(n,r);const a={a:n,b:r};return Is.runKernel(Hn,a)}});var Pl=Ls({abs_:function(e){const t=Ds(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Is.runKernel(It,e)}{const e={x:t};return Is.runKernel(Je,e)}}});var Ll=Ls({acos_:function(e){const t={x:Ds(e,"x","acos")};return Is.runKernel(Qe,t)}});var Bl=Ls({acosh_:function(e){const t={x:Ds(e,"x","acosh")};return Is.runKernel(et,t)}});var Wl=Ls({addN_:function(e){ae(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),ae(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>Ds(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!ce(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return Is.runKernel(nt,r)}});var Ul=Ls({all_:function(e,t=null,n=!1){const r={x:Ds(e,"x","all","bool")},a={axis:t,keepDims:n};return Is.runKernel(rt,r,a)}});var Vl=Ls({any_:function(e,t=null,n=!1){const r={x:Ds(e,"x","any","bool")},a={axis:t,keepDims:n};return Is.runKernel(at,r,a)}});var jl=Ls({argMax_:function(e,t=0){const n={x:Ds(e,"x","argMax")},r={axis:t};return Is.runKernel(st,n,r)}});var Gl=Ls({argMin_:function(e,t=0){const n={x:Ds(e,"x","argMin")},r={axis:t};return Is.runKernel(ot,n,r)}});var Hl=Ls({asin_:function(e){const t={x:Ds(e,"x","asin")};return Is.runKernel(it,t)}});var ql=Ls({asinh_:function(e){const t={x:Ds(e,"x","asinh")};return Is.runKernel(lt,t)}});var Xl=Ls({atan_:function(e){const t={x:Ds(e,"x","atan")};return Is.runKernel(ut,t)}});var Kl=Ls({atan2_:function(e,t){let n=Ds(e,"a","atan2"),r=Ds(t,"b","atan2");[n,r]=As(n,r);const a={a:n,b:r};return Is.runKernel(dt,a)}});var Zl=Ls({atanh_:function(e){const t={x:Ds(e,"x","atanh")};return Is.runKernel(ct,t)}});function Yl(e,t,n,r,a="NHWC",s){return eu(e,[...t,e[3]],n,s,r,null,null,uu(a))}function Jl(e,t,n,r,a,s,o="channelsLast"){const[i,l]=ru(t);let u;if("channelsLast"===o)u=[i,l,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);u=[i,l,e[1],e[1]]}return eu(e,u,n,r,a,s,!1,o)}function Ql(e,t,n,r,a,s,o="NDHWC"){const[i,l,u]=au(t);let c,d;if("NDHWC"===o)d="channelsLast",c=[i,l,u,e[4],e[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",c=[i,l,u,e[1],e[1]]}return tu(e,c,n,r,a,!1,d,s)}function eu(e,t,n,r,a,s,o=!1,i="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,u,c]=e}const[h,p,,f]=t,[m,A]=ru(n),[g,y]=ru(r),x=su(h,g),b=su(p,y),{padInfo:v,outHeight:w,outWidth:k}=function(e,t,n,r,a,s,o,i,l){let u,c,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,a){null==r&&(r=nu(e,t,n));const s=e[0],o=e[1],i=ou((s-t+2*r)/n+1,a),l=ou((o-t+2*r)/n+1,a);return[i,l]}([t,n],s,r,e,i);c=a[0],d=a[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/a);const e=Math.max(0,(c-1)*r+s-t),i=Math.max(0,(d-1)*a+o-n),l=Math.floor(e/2),h=e-l,p=Math.floor(i/2);u={top:l,bottom:h,left:p,right:i-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/r),d=Math.ceil((n-o+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const h="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=ou((t-s+h+p)/r+1,i),d=ou((n-o+f+m)/a+1,i)}}return{padInfo:u,outHeight:c,outWidth:d}}(a,u,c,m,A,x,b,s,i),S=o?f*d:f;let I;return"channelsFirst"===i?I=[l,S,w,k]:"channelsLast"===i&&(I=[l,w,k,S]),{batchSize:l,dataFormat:i,inHeight:u,inWidth:c,inChannels:d,outHeight:w,outWidth:k,outChannels:S,padInfo:v,strideHeight:m,strideWidth:A,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:b,dilationHeight:g,dilationWidth:y,inShape:e,outShape:I,filterShape:t}}function tu(e,t,n,r,a,s=!1,o="channelsLast",i){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c,d]=e}const[p,f,m,,A]=t,[g,y,x]=au(n),[b,v,w]=au(r),k=su(p,b),S=su(f,v),I=su(m,w),{padInfo:C,outDepth:E,outHeight:N,outWidth:T}=function(e,t,n,r,a,s,o,i,l,u,c){let d,h,p,f;if("number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,a,s){null==a&&(a=nu(e,t,r));const o=e[0],i=e[1],l=e[2],u=ou((o-t+2*a)/r+1,s),c=ou((i-t+2*a)/r+1,s),d=ou((l-t+2*a)/r+1,s);return[u,c,d,n]}([t,n,r,1],i,1,a,e,c);h=s[0],p=s[1],f=s[2]}else if("same"===e){h=Math.ceil(t/a),p=Math.ceil(n/s),f=Math.ceil(r/o);const e=(h-1)*a+i-t,c=(p-1)*s+l-n,m=(f-1)*o+u-r,A=Math.floor(e/2),g=e-A,y=Math.floor(c/2),x=c-y,b=Math.floor(m/2);d={top:y,bottom:x,left:b,right:m-b,front:A,back:g,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((t-i+1)/a),p=Math.ceil((n-l+1)/s),f=Math.ceil((r-u+1)/o)}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(a,u,c,d,g,y,x,k,S,I,i),R=s?A*h:A;let _;return"channelsFirst"===o?_=[l,R,E,N,T]:"channelsLast"===o&&(_=[l,E,N,T,R]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:E,outHeight:N,outWidth:T,outChannels:R,padInfo:C,strideDepth:g,strideHeight:y,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:S,effectiveFilterWidth:I,dilationDepth:b,dilationHeight:v,dilationWidth:w,inShape:e,outShape:_,filterShape:t}}function nu(e,t,n,r=1){const a=su(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function ru(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function au(e){return"number"==typeof e?[e,e,e]:e}function su(e,t){return t<=1?e:e+(e-1)*(t-1)}function ou(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function iu(e){const[t,n,r]=ru(e);return 1===t&&1===n&&1===r}function lu(e,t){return iu(e)||iu(t)}function uu(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function cu(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)ae(de(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{ae(de(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}var du=Ls({reshape_:function(e,t){const n={x:Ds(e,"x","reshape","string_or_numeric")},r={shape:t};return Is.runKernel(cr,n,r)}});var hu=Ls({avgPool_:function(e,t,n,r,a){const s=Ds(e,"x","avgPool","float32");ae(lu(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let o=s,i=!1;3===s.rank&&(i=!0,o=du(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===o.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`)),cu("avgPool",r,a);const l={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a};let c=Is.runKernel(ht,l,u);return c=zo(c,s.dtype),i?du(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var pu=Ls({avgPool3d_:function(e,t,n,r,a,s="NDHWC"){const o=Ds(e,"x","avgPool3d","float32");let i=o,l=!1;4===o.rank&&(l=!0,i=du(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ae(5===i.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`)),ae("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),cu("avgPool3d",r,a);const u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let d=Is.runKernel(ft,u,c);return d=zo(d,i.dtype),l?du(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var fu=Ls({concat_:function(e,t=0){ae(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=zs(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Po(n[0]);const r=n,a={axis:t};return Is.runKernel(Ct,r,a)}});var mu=Ls({sigmoid_:function(e){const t={x:Ds(e,"x","sigmoid","float32")};return Is.runKernel(Er,t)}});var Au=Ls({slice_:function(e,t,n){const r=Ds(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:t,size:n};return Is.runKernel(kr,a,s)}});var gu=Ls({tanh_:function(e){const t={x:Ds(e,"x","tanh","float32")};return Is.runKernel(qr,t)}});var yu=Ls({basicLSTMCell_:function(e,t,n,r,a,s){const o=Ds(e,"forgetBias","basicLSTMCell"),i=Ds(t,"lstmKernel","basicLSTMCell"),l=Ds(n,"lstmBias","basicLSTMCell"),u=Ds(r,"data","basicLSTMCell"),c=Ds(a,"c","basicLSTMCell"),d=Ds(s,"h","basicLSTMCell"),h=fu([u,d],1),p=ii(h,i),f=Fl(p,l),m=f.shape[0],A=f.shape[1]/4,g=[m,A],y=Au(f,[0,0],g),x=Au(f,[0,A],g),b=Au(f,[0,2*A],g),v=Au(f,[0,3*A],g),w=Fl(zl(mu(y),gu(x)),zl(c,mu(Fl(o,b))));return[w,zl(gu(w),mu(v))]}});var xu=Ls({batchToSpaceND_:function(e,t,n){const r=Ds(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));ae(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),ae(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),ae(r.shape[0]%a==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));const s={x:r},o={blockShape:t,crops:n};return Is.runKernel(gt,s,o)}});var bu=Ls({batchNorm_:function(e,t,n,r,a,s){null==s&&(s=.001);const o=Ds(e,"x","batchNorm"),i=Ds(t,"mean","batchNorm"),l=Ds(n,"variance","batchNorm");let u,c;null!=a&&(u=Ds(a,"scale","batchNorm")),null!=r&&(c=Ds(r,"offset","batchNorm")),ae(i.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),ae(null==c||i.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),ae(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d=function(e){let t;return t=0===e.rank||1===e.rank?du(e,[1,1,1,e.size]):2===e.rank?du(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?du(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(o),h={x:d,scale:u,offset:c,mean:i,variance:l},p={varianceEpsilon:s},f=Is.runKernel(ln,h,p);return du(f,o.shape)}});var vu=Ls({batchNorm2d_:function(e,t,n,r,a,s){const o=Ds(e,"x","batchNorm"),i=Ds(t,"mean","batchNorm"),l=Ds(n,"variance","batchNorm");let u,c;return null!=a&&(u=Ds(a,"scale","batchNorm")),null!=r&&(c=Ds(r,"offset","batchNorm")),ae(2===o.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`)),ae(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`)),ae(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&ae(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&ae(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),bu(o,i,l,c,u,s)}});var wu=Ls({batchNorm3d_:function(e,t,n,r,a,s){const o=Ds(e,"x","batchNorm"),i=Ds(t,"mean","batchNorm"),l=Ds(n,"variance","batchNorm");let u,c;return null!=a&&(u=Ds(a,"scale","batchNorm")),null!=r&&(c=Ds(r,"offset","batchNorm")),ae(3===o.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`)),ae(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`)),ae(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&ae(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&ae(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),bu(o,i,l,c,u,s)}});var ku=Ls({batchNorm4d_:function(e,t,n,r,a,s){const o=Ds(e,"x","batchNorm"),i=Ds(t,"mean","batchNorm"),l=Ds(n,"variance","batchNorm");let u,c;return null!=a&&(u=Ds(a,"scale","batchNorm")),null!=r&&(c=Ds(r,"offset","batchNorm")),ae(4===o.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`)),ae(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`)),ae(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&ae(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&ae(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),bu(o,i,l,c,u,s)}});var Su=Ls({bincount_:function(e,t,n){const r=Ds(e,"x","bincount"),a=Ds(t,"weights","bincount");ae("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),ae(n>=0,(()=>`size must be non-negative, but got ${n}.`)),ae(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));const s={x:r,weights:a},o={size:n};return Is.runKernel(yt,s,o)}});var Iu=Ls({broadcastArgs_:function(e,t){const n=Ds(e,"s0","broadcastArgs","int32"),r=Ds(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const a={s0:n,s1:r};return Is.runKernel(bt,a)}});var Cu=Ls({broadcastTo_:function(e,t){let n=Ds(e,"broadcastTo","x");const r=n.shape;if(t.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=du(n,e)}const a=n.shape,s=Array.from(t);for(let e=t.length-1;e>=0;e--)if(a[e]===t[e])s[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return Po(n);const o={x:n},i={reps:s};return Is.runKernel(Xr,o,i)}});var Eu=Ls({ceil_:function(e){const t={x:Ds(e,"x","ceil","float32")};return Is.runKernel(wt,t)}});var Nu=Ls({clipByValue_:function(e,t,n){const r=Ds(e,"x","clipByValue");ae(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`));const a={x:r},s={clipValueMin:t,clipValueMax:n};return Is.runKernel(kt,a,s)}});var Tu=Ls({concat1d_:function(e){return fu(e,0)}});var Ru=Ls({concat2d_:function(e,t){return fu(e,t)}});var _u=Ls({concat3d_:function(e,t){return fu(e,t)}});var Mu=Ls({concat4d_:function(e,t){return fu(e,t)}});var $u=Ls({conv2d_:function(e,t,n,r,a="NHWC",s=[1,1],o){const i=Ds(e,"x","conv2d","float32"),l=Ds(t,"filter","conv2d","float32");let u=i,c=!1;3===i.rank&&(c=!0,u=du(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ae(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),ae(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),cu("conv2d",r,o);const d="NHWC"===a?u.shape[3]:u.shape[1];ae(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),ae(lu(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=Is.runKernel(Et,h,p);return c?du(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var Fu=Ls({conv1d_:function(e,t,n,r,a="NWC",s=1,o){const i=Ds(e,"x","conv1d"),l=Ds(t,"filter","conv1d");let u=i,c=!1;2===i.rank&&(c=!0,u=du(i,[1,i.shape[0],i.shape[1]])),ae(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),ae(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),cu("conv1d",r,o),ae(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),ae(lu(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),ae("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));const d=du(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=du(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=$u(h,d,[1,n],r,"NHWC",[1,s],o);return du(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});var Ou=Ls({conv2DBackpropInput_:function(e,t,n,r,a,s="NHWC",o){ae(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let i=e,l=t,u=!1;3===t.rank&&(u=!0,l=du(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),ae(4===i.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`)),ae(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),ae(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===s?i[3]:i[1],d="NHWC"===s?l.shape[3]:l.shape[1];ae(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),ae(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),cu("conv2dDerInput",a,o);const h={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,inputShape:i},f=Is.runKernel(Tt,h,p);return u?du(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var Du=Ls({conv2dTranspose_:function(e,t,n,r,a,s){const o=Ds(e,"x","conv2dTranspose"),i=Ds(t,"filter","conv2dTranspose");return Ou(n,o,i,r,a,"NHWC",s)}});var zu=Ls({conv3d_:function(e,t,n,r,a="NDHWC",s=[1,1,1]){const o=Ds(e,"x","conv3d"),i=Ds(t,"filter","conv3d");let l=o,u=!1;4===o.rank&&(u=!0,l=du(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ae(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),ae(5===i.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`)),ae(l.shape[4]===i.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`)),ae(lu(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),ae("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`));const c={x:l,filter:i},d={strides:n,pad:r,dataFormat:a,dilations:s},h=Is.runKernel(Rt,c,d);return u?du(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var Pu=Ls({conv3DBackpropInput_:function(e,t,n,r,a){ae(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,o=t,i=!1;4===t.rank&&(i=!0,o=du(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);const l=s[4],u=o.shape[4];ae(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),ae(5===o.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`)),ae(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),ae(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),ae(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:o,filter:n},d={pad:a,strides:r,inputShape:s},h=Is.runKernel(Mt,c,d);return i?du(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var Lu=Ls({conv3dTranspose_:function(e,t,n,r,a){const s=Ds(e,"x","conv3dTranspose"),o=Ds(t,"filter","conv3dTranspose");return Pu(n,s,o,r,a)}});var Bu=Ls({cos_:function(e){const t={x:Ds(e,"x","cos","float32")};return Is.runKernel($t,t)}});var Wu=Ls({cosh_:function(e){const t={x:Ds(e,"x","cosh","float32")};return Is.runKernel(Ft,t)}});var Uu=Ls({cumprod_:function(e,t=0,n=!1,r=!1){const a={x:Ds(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return Is.runKernel(Ot,a,s)}});var Vu=Ls({cumsum_:function(e,t=0,n=!1,r=!1){const a={x:Ds(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return Is.runKernel(Dt,a,s)}});var ju=Ls({denseBincount_:function(e,t,n,r=!1){const a=Ds(e,"x","denseBincount"),s=Ds(t,"weights","denseBincount");ae("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),ae(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),ae(n>=0,(()=>`size must be non-negative, but got ${n}.`)),ae(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));const o={x:a,weights:s},i={size:n,binaryOutput:r};return Is.runKernel(Pt,o,i)}});var Gu=Ls({depthToSpace_:function(e,t,n="NHWC"){const r=Ds(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],o="NHWC"===n?r.shape[3]:r.shape[1];ae(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),ae(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),ae(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),ae(o%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`));const i={x:r},l={blockSize:t,dataFormat:n};return Is.runKernel(Lt,i,l)}});var Hu=Ls({depthwiseConv2d_:function(e,t,n,r,a="NHWC",s=[1,1],o){const i=Ds(e,"x","depthwiseConv2d","float32"),l=Ds(t,"filter","depthwiseConv2d","float32");let u=i,c=!1;3===i.rank&&(c=!0,u=du(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ae(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),ae(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const d="NHWC"===a?u.shape[3]:u.shape[1];ae(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),cu("depthwiseConv2d",r,o);const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},f=Is.runKernel(Bt,h,p);return c?du(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var qu=Ls({diag_:function(e){const t={x:Ds(e,"x","diag")};return Is.runKernel(Vt,t)}});var Xu=Ls({dilation2d_:function(e,t,n,r,a=[1,1],s="NHWC"){const o=Ds(e,"x","dilation2d"),i=Ds(t,"filter","dilation2d");ae(3===o.rank||4===o.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`)),ae(3===i.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`)),ae("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=o,u=!1;3===o.rank&&(l=du(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0);const c={x:l,filter:i},d={strides:n,pad:r,dilations:a},h=Is.runKernel(jt,c,d);return u?du(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});var Ku=Ls({equal_:function(e,t){let n=Ds(e,"a","equal","string_or_numeric"),r=Ds(t,"b","equal","string_or_numeric");[n,r]=As(n,r),Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(Jt,a)}});var Zu=Ls({where_:function(e,t,n){const r=Ds(t,"a","where"),a=Ds(n,"b","where"),s=Ds(e,"condition","where","bool"),o=Pi(Pi(s.shape,r.shape),a.shape),i={condition:Cu(s,o),t:Cu(r,o),e:Cu(a,o)};return Is.runKernel(vr,i)}});var Yu=Ls({zerosLike_:function(e){const t={x:Ds(e,"x","zerosLike")};return Is.runKernel(na,t)}});var Ju=Ls({divNoNan_:function(e,t){let n=Ds(e,"a","div"),r=Ds(t,"b","div");[n,r]=As(n,r);const a=Dl(n,r),s=Yu(a),o=Ku(r,s);return Zu(o,s,a)}});var Qu=Ls({dot_:function(e,t){const n=Ds(e,"t1","dot"),r=Ds(t,"t2","dot");ae(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(ae(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){const e=du(n,[1,-1]),t=du(r,[-1,1]),a=ii(e,t);return du(a,[])}if(1===n.rank&&2===r.rank){const e=du(n,[1,-1]),t=du(r,[r.shape[0],r.shape[1]]),a=ii(e,t);return du(a,[a.size])}if(2===n.rank&&1===r.rank){const e=du(r,[-1,1]),t=ii(n,e);return du(t,[t.size])}{const e=du(r,[r.shape[0],r.shape[1]]);return ii(n,e)}}});var ec=Ls({einsum_:function(e,...t){const n=t.map(((e,t)=>Ds(e,`tensors${t}`,"einsum"))),r={equation:e};return Is.runKernel(Xt,n,r)}});var tc=Ls({elu_:function(e){const t={x:Ds(e,"x","elu","float32")};return Is.runKernel(Kt,t)}});var nc=Ls({erf_:function(e){let t=Ds(e,"x","erf");ae("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=zo(t,"float32"));const n={x:t};return Is.runKernel(Yt,n)}});function rc(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function ac(e,t,n){const r=e.length+t.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?a.push(e[s++]):a.push(t[o++]);return a}function sc(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function oc(e,t){return ac(e,t.map((e=>1)),t)}function ic(e,t,n){ae(rc(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function lc(e,t){if(rc(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function uc(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function cc(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}var dc=Ls({max_:function(e,t=null,n=!1){const r={x:Ds(e,"x","max")},a={reductionIndices:t,keepDims:n};return Is.runKernel($n,r,a)}});var hc=Ls({min_:function(e,t=null,n=!1){const r={x:Ds(e,"x","min")},a={axis:t,keepDims:n};return Is.runKernel(Wn,r,a)}});var pc=Ls({pow_:function(e,t){let n=Ds(e,"base","pow"),r=Ds(t,"exp","pow");[n,r]=As(n,r);const a={a:n,b:r};return Is.runKernel(rr,a)}});function fc(e,t){if((Ie(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Ie(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ws(e,[],[],t)}var mc=Ls({sqrt_:function(e){const t={x:Ds(e,"x","sqrt","float32")};return Is.runKernel(Tr,t)}});var Ac=Ls({square_:function(e){const t=Ds(e,"x","square");return Is.runKernel("Square",{x:t},{})}});var gc=Ls({sum_:function(e,t=null,n=!1){let r=Ds(e,"x","sum");"bool"===r.dtype&&(r=zo(r,"int32"));const a={x:r},s={axis:t,keepDims:n};return Is.runKernel(Rr,a,s)}});function yc(e,t,n=null){if(0===e.rank)return Pl(e);if(1!==e.rank&&null===n)return yc(du(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return gc(Pl(e),n);if(t===1/0)return dc(Pl(e),n);if(t===-1/0)return hc(Pl(e),n);if("euclidean"===t||2===t)return mc(gc(pc(Pl(e),fc(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return dc(gc(Pl(e),n[0]),n[1]-1);if(t===1/0)return dc(gc(Pl(e),n[1]),n[0]);if(t===-1/0)return hc(gc(Pl(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return mc(gc(Ac(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var xc=Ls({norm_:function(e,t="euclidean",n=null,r=!1){const a=yc(e=Ds(e,"x","norm"),t,n);let s=a.shape;if(r){const t=ye(n,e.shape);s=oc(a.shape,t)}return du(a,s)}});var bc=Ls({euclideanNorm_:function(e,t=null,n=!1){return xc(e,"euclidean",t,n)}});var vc=Ls({exp_:function(e){const t={x:Ds(e,"x","exp")};return Is.runKernel(Qt,t)}});var wc=Ls({expandDims_:function(e,t=0){const n=Ds(e,"x","expandDims","string_or_numeric");ae(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:t};return Is.runKernel(en,r,a)}});var kc=Ls({expm1_:function(e){const t={x:Ds(e,"x","expm1")};return Is.runKernel(tn,t)}});var Sc=Ls({tile_:function(e,t){const n=Ds(e,"x","tile","string_or_numeric");ae(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},a={reps:t};return Is.runKernel(Xr,r,a)}});var Ic=Ls({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const a=Do([e,t],r),s=e<=t?e:t;for(let e=0;e<s;++e)a.set(1,e,e);const o=du(a.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return Sc(wc(o,0),[n[0],1,1]);if(2===n.length)return Sc(wc(wc(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Sc(wc(wc(wc(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function Cc(e,t,n){const r={shape:e,value:t,dtype:n};return Is.runKernel(rn,{},r)}var Ec=Ls({floor_:function(e){const t={x:Ds(e,"x","floor","float32")};return Is.runKernel(sn,t)}});var Nc=Ls({gather_:function(e,t,n=0,r=0){const a={x:Ds(e,"x","gather"),indices:Ds(t,"indices","gather","int32")},s={axis:n,batchDims:r};return Is.runKernel(un,a,s)}});var Tc=Ls({greater_:function(e,t){let n=Ds(e,"a","greater","string_or_numeric"),r=Ds(t,"b","greater","string_or_numeric");[n,r]=As(n,r),Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(dn,a)}});var Rc=Ls({greaterEqual_:function(e,t){let n=Ds(e,"a","greaterEqual","string_or_numeric"),r=Ds(t,"b","greaterEqual","string_or_numeric");[n,r]=As(n,r),Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(hn,a)}});var _c=Ls({isFinite_:function(e){const t={x:Ds(e,"x","isFinite")};return Is.runKernel(An,t)}});var Mc=Ls({isInf_:function(e){const t={x:Ds(e,"x","isInf")};return Is.runKernel(gn,t)}});var $c=Ls({isNaN_:function(e){const t={x:Ds(e,"x","isNaN")};return Is.runKernel(yn,t)}});var Fc=Ls({leakyRelu_:function(e,t=.2){const n={x:Ds(e,"x","leakyRelu")},r={alpha:t};return Is.runKernel(xn,n,r)}});var Oc=Ls({less_:function(e,t){let n=Ds(e,"a","less","string_or_numeric"),r=Ds(t,"b","less","string_or_numeric");[n,r]=As(n,r),Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(bn,a)}});var Dc=Ls({lessEqual_:function(e,t){let n=Ds(e,"a","lessEqual","string_or_numeric"),r=Ds(t,"b","lessEqual","string_or_numeric");[n,r]=As(n,r),Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(vn,a)}});function zc(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return Is.runKernel(wn,{},r)}var Pc=Ls({localResponseNormalization_:function(e,t=5,n=1,r=1,a=.5){const s=Ds(e,"x","localResponseNormalization");ae(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),ae(de(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let o=s,i=!1;3===s.rank&&(i=!0,o=du(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},u={depthRadius:t,bias:n,alpha:r,beta:a},c=Is.runKernel(_n,l,u);return i?du(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var Lc=Ls({log_:function(e){const t={x:Ds(e,"x","log","float32")};return Is.runKernel(kn,t)}});var Bc=Ls({log1p_:function(e){const t={x:Ds(e,"x","log1p")};return Is.runKernel(Sn,t)}});function Wc(e){return ae(Me(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const r=Ds(t,"x","tf.grad","string_or_numeric"),a=null!=n?Ds(n,"dy","tf.grad"):null;return Is.tidy((()=>{const{value:t,grads:n}=Is.gradients((()=>e(r)),[r],a);return null!=a&&se(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),qc(n),n[0]}))}}function Uc(e){return ae(Me(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{ae(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const r=zs(t,"args","tf.grads","string_or_numeric"),a=null!=n?Ds(n,"dy","tf.grads"):null;return Is.tidy((()=>{const{value:t,grads:n}=Is.gradients((()=>e(...r)),r,a);return null!=a&&se(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),qc(n),n}))}}function Vc(e){return ae(Me(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{ae(t instanceof Qa,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),ae(null==n||n instanceof Qa,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:r,value:a}=Is.gradients((()=>e(t)),[t],n);return qc(r),{grad:r[0],value:a}}}function jc(e){return ae(Me(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{ae(Array.isArray(t)&&t.every((e=>e instanceof Qa)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),ae(null==n||n instanceof Qa,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const r=Is.gradients((()=>e(...t)),t,n);return null!=n&&se(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),qc(r.grads),r}}function Gc(e,t){ae(Me(e),(()=>"The f passed in variableGrads(f) must be a function")),ae(null==t||Array.isArray(t)&&t.every((e=>e instanceof ts)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Is.registeredVariables)t.push(Is.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,a=t.length;ae((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));const{value:s,grads:o}=Is.gradients(e,t,null,!0);ae(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),ae(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));const i={};return t.forEach(((e,t)=>{null!=o[t]&&(i[e.name]=o[t])})),null!=r&&r.forEach((e=>i[e.name]=null)),{value:s,grads:i}}function Hc(e){return Is.customGrad(e)}function qc(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var Xc=Ls({softplus_:function(e){const t={x:Ds(e,"x","softplus")};return Is.runKernel(Nr,t)}});var Kc=Ls({logSigmoid_:function(e){const t=Ds(e,"x","logSigmoid");return Hc((e=>({value:_i(Xc(_i(e))),gradFunc:t=>zl(t,mu(_i(e)))})))(t)}});var Zc=Ls({sub_:function(e,t){let n=Ds(e,"a","sub"),r=Ds(t,"b","sub");[n,r]=As(n,r);const a={a:n,b:r};return Is.runKernel(Gr,a)}});var Yc=Ls({logSoftmax_:function(e,t=-1){const n=Ds(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Hc(((e,n)=>{const r=dc(e,t,!0),a=Zc(e,r),s=Zc(zo(a,"float32"),Lc(gc(vc(a),t,!0)));n([s]);return{value:s,gradFunc:(e,n)=>{const[r]=n,a=vc(r);return Zc(e,zl(gc(e,t,!0),a))}}}))(n)}});var Jc=Ls({logSumExp_:function(e,t=null,n=!1){const r=Ds(e,"x","logSumExp"),a=ye(t,r.shape),s=dc(r,a,!0),o=Zc(r,s),i=vc(o),l=gc(i,a),u=Lc(l),c=Fl(du(s,u.shape),u);if(n){const e=oc(c.shape,a);return du(c,e)}return c}});var Qc=Ls({logicalAnd_:function(e,t){const n=Ds(e,"a","logicalAnd","bool"),r=Ds(t,"b","logicalAnd","bool");Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(In,a)}});var ed=Ls({logicalNot_:function(e){const t={x:Ds(e,"x","logicalNot","bool")};return Is.runKernel(Cn,t)}});var td=Ls({logicalOr_:function(e,t){const n=Ds(e,"a","logicalOr","bool"),r=Ds(t,"b","logicalOr","bool");Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(En,a)}});var nd=Ls({logicalXor_:function(e,t){const n=Ds(e,"a","logicalXor","bool"),r=Ds(t,"b","logicalXor","bool");return Pi(n.shape,r.shape),Qc(td(e,t),ed(Qc(e,t)))}}),rd=2147483648;var ad=Ls({searchSorted_:function(e,t,n="left"){const r=Ds(e,"sortedSequence","searchSorted"),a=Ds(t,"values","searchSorted"),s=r.shape[r.shape.length-1],o=a.shape[a.shape.length-1],i=du(r,[-1,s]),l=du(a,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(le(l.shape)>=rd)throw new Error("values tensor size must less than 2147483648");if(i.shape[1]>=rd)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${i.shape[1]}`);const u={sortedSequence:i,values:l},c={side:n};return Is.runKernel(br,u,c)}});function sd(e,t){return ad(e,t,"left")}var od=Ls({maxPool_:function(e,t,n,r,a){const s=Ds(e,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=du(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===o.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`)),ae(lu(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),cu("maxPool",r,a);const l={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=Is.runKernel(On,l,u);return i?du(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var id=Ls({maxPool3d_:function(e,t=[1,1,1],n,r,a,s="NDHWC"){const o=Ds(e,"x","maxPool3d");let i=o,l=!1;4===o.rank&&(l=!0,i=du(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ae(5===i.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`)),ae("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),cu("maxPool3d",r,a);const u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=Is.runKernel(zn,u,c);return l?du(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var ld=Ls({maxPoolWithArgmax_:function(e,t,n,r,a=!1){const s={x:Ds(e,"x","maxPoolWithArgmax")},o={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},i=Is.runKernel(Ln,s,o);return{result:i[0],indexes:i[1]}}});var ud=Ls({maximum_:function(e,t){let n=Ds(e,"a","maximum"),r=Ds(t,"b","maximum");[n,r]=As(n,r),"bool"===n.dtype&&(n=zo(n,"int32"),r=zo(r,"int32")),Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(Fn,a)}});var cd=Ls({mean_:function(e,t=null,n=!1){const r={x:Ds(e,"x","mean")},a={axis:t,keepDims:n};return Is.runKernel(Bn,r,a)}});function dd(e,t="float32"){if("complex64"===t){const t=dd(e,"float32"),n=dd(e,"float32");return Bs(t,n)}const n=Pe(le(e),t);return Is.makeTensor(n,e,t)}function hd(e,t="float32"){if("complex64"===t){const t=hd(e,"float32"),n=dd(e,"float32");return Bs(t,n)}const n=ze(le(e),t);return Is.makeTensor(n,e,t)}function pd(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=Ds(e,"x","meshgrid",e instanceof Qa?e.dtype:"float32");if(void 0===t)return[r];let a=Ds(t,"y","meshgrid",t instanceof Qa?t.dtype:"float32");const s=le(r.shape),o=le(a.shape);return"xy"===n?(r=du(r,[1,-1]),a=du(a,[-1,1]),[ii(hd([o,1],r.dtype),r),ii(a,hd([1,s],a.dtype))]):(r=du(r,[-1,1]),a=du(a,[1,-1]),[ii(r,hd([1,o],r.dtype)),ii(hd([s,1],a.dtype),a)])}var fd=Ls({minimum_:function(e,t){let n=Ds(e,"a","minimum"),r=Ds(t,"b","minimum");[n,r]=As(n,r),"bool"===n.dtype&&(n=zo(n,"int32"),r=zo(r,"int32")),Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(Un,a)}});var md=Ls({mirrorPad_:function(e,t,n){ae("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=Ds(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");ae(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const a="reflect"===n?1:0;for(let e=0;e<r.rank;e++)ae(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),ae(t[e][0]>=0&&t[e][0]<=r.shape[e]-a&&t[e][1]>=0&&t[e][1]<=r.shape[e]-a,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-a} or less than 0 for input of shape ${r.shape}`));const s={paddings:t,mode:n},o={x:r};return Is.runKernel(Vn,o,s)}});var Ad=Ls({mod_:function(e,t){let n=Ds(e,"a","mod"),r=Ds(t,"b","mod");[n,r]=As(n,r);const a={a:n,b:r};return Is.runKernel(jn,a)}});var gd=Ls({moments_:function(e,t=null,n=!1){const r=ye(t,(e=Ds(e,"x","moments")).shape),a=cd(e,r,n);let s=a.shape;n||(s=oc(a.shape,r));const o=Ac(Zc(zo(e,"float32"),du(a,s)));return{mean:a,variance:cd(o,r,n)}}});var yd=Ls({multiRNNCell_:function(e,t,n,r){const a=Ds(t,"data","multiRNNCell"),s=zs(n,"c","multiRNNCell"),o=zs(r,"h","multiRNNCell");let i=a;const l=[];for(let t=0;t<e.length;t++){const n=e[t](i,s[t],o[t]);l.push(n[0]),l.push(n[1]),i=n[1]}const u=[],c=[];for(let e=0;e<l.length;e+=2)u.push(l[e]),c.push(l[e+1]);return[u,c]}});var xd=Ls({multinomial_:function(e,t,n,r=!1){const a=Ds(e,"logits","multinomial"),s=a.size,o=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const i={logits:1===o?du(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=Is.runKernel(Gn,i,l);return 1===o?du(u,[u.size]):u}});var bd=Ls({notEqual_:function(e,t){let n=Ds(e,"a","notEqual","string_or_numeric"),r=Ds(t,"b","notEqual","string_or_numeric");[n,r]=As(n,r),Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(Xn,a)}});var vd=Ls({onesLike_:function(e){const t={x:Ds(e,"x","onesLike")};return Is.runKernel(Jn,t)}});var wd=Ls({outerProduct_:function(e,t){const n=Ds(e,"v1","outerProduct"),r=Ds(t,"v2","outerProduct");ae(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const a=du(n,[-1,1]),s=du(r,[1,-1]);return ii(a,s)}});var kd=Ls({pad_:function(e,t,n=0){const r=Ds(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:t,constantValue:n},s={x:r};return Is.runKernel(tr,s,a)}});var Sd=Ls({pad1d_:function(e,t,n=0){return ae(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),kd(e,[t],n)}});var Id=Ls({pad2d_:function(e,t,n=0){return ae(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),kd(e,t,n)}});var Cd=Ls({pad3d_:function(e,t,n=0){return ae(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),kd(e,t,n)}});var Ed=Ls({pad4d_:function(e,t,n=0){return ae(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),kd(e,t,n)}});var Nd=Ls({spaceToBatchND_:function(e,t,n){const r=Ds(e,"x","spaceToBatchND");ae(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),ae(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),ae(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]==0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const a={x:r},s={blockShape:t,paddings:n};return Is.runKernel(_r,a,s)}});var Td=Ls({pool_:function(e,t,n,r,a,s,o){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");const i=Ds(e,"x","maxPool");let l=i,u=!1;3===i.rank&&(u=!0,l=du(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ae(lu(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));const c=Jl(l.shape,t,s,a,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),a=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],a[t]]))}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),o=t.map(((e,t)=>(e-s[t]%e)%e)),i=a.map(((e,t)=>e+o[t])),l=t.map(((e,t)=>[r[t],i[t]])),u=t.map(((e,t)=>[0,o[t]]));return[l,u]}([c.inHeight,c.inWidth],d,h),A=p?r:"valid",g=p?l:Nd(l,d,f),y=("avg"===n?()=>hu(g,t,s,A,o):()=>od(g,t,s,A,o))(),x=p?y:xu(y,d,m);return u?du(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});var Rd=Ls({prelu_:function(e,t){const n={x:Ds(e,"x","prelu"),alpha:Ds(t,"alpha","prelu")};return Is.runKernel(ar,n)}});var _d=Ls({prod_:function(e,t=null,n=!1){let r=Ds(e,"x","prod");"bool"===r.dtype&&(r=zo(r,"int32"));const a={x:r},s={axis:t,keepDims:n};return Is.runKernel(sr,a,s)}});var Md=Ls({rand_:function(e,t,n){const r=le(e);let a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let e=0;e<r;e++)a[e]=t();return Is.makeTensor(a,e,n)}}),$d=I(z()),Fd=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=$d.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}};var Od=Ls({randomGamma_:function(e,t,n=1,r="float32",a){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const s=new class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const a=r||Math.random();this.randu=$d.alea(a.toString()),this.randn=new Fd(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}(t,n,r,a),o=Do(e,r);for(let e=0;e<o.values.length;e++)o.values[e]=s.nextValue();return o.toTensor()}});var Dd=Ls({randomNormal_:function(e,t=0,n=1,r,a){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const s=new Fd(t,n,r,!1,a),o=Do(e,r);for(let e=0;e<o.values.length;e++)o.values[e]=s.nextValue();return o.toTensor()}});var zd=Ls({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return Dd(e,0,1,t,n)}});var Pd=Ls({randomUniform_:function(e,t=0,n=1,r="float32",a){const s=Do(e,r),o=new class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=$d.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}(t,n,null,a);for(let e=0;e<s.values.length;e++)s.values[e]=o.nextValue();return s.toTensor()}});function Ld(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const a={start:e,stop:t,step:n,dtype:r};return Is.runKernel(or,{},a)}var Bd=Ls({reciprocal_:function(e){const t={x:Ds(e,"x","reciprocal")};return Is.runKernel(lr,t)}});var Wd=Ls({relu_:function(e){const t={x:Ds(e,"x","relu")};return Is.runKernel(ur,t)}});var Ud=Ls({relu6_:function(e){const t={x:Ds(e,"x","relu6")};return Is.runKernel(mr,t)}});var Vd=Ls({reverse_:function(e,t){const n={x:Ds(e,"x","reverse")},r={dims:t};return Is.runKernel(Ar,n,r)}});var jd=Ls({reverse1d_:function(e){const t=Ds(e,"x","reverse");return ae(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),Vd(t,0)}});var Gd=Ls({reverse2d_:function(e,t){const n=Ds(e,"x","reverse");return ae(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),Vd(n,t)}});var Hd=Ls({reverse3d_:function(e,t){const n=Ds(e,"x","reverse");return ae(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),Vd(n,t)}});var qd=Ls({reverse4d_:function(e,t){const n=Ds(e,"x","reverse");return ae(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),Vd(n,t)}});var Xd=Ls({round_:function(e){const t={x:Ds(e,"x","round")};return Is.runKernel(gr,t)}});var Kd=Ls({rsqrt_:function(e){const t={x:Ds(e,"x","rsqrt","float32")};return Is.runKernel(yr,t)}});var Zd=Ls({selu_:function(e){const t={x:Ds(e,"x","selu")};return Is.runKernel(wr,t)}});var Yd=Ls({separableConv2d_:function(e,t,n,r,a,s=[1,1],o="NHWC"){const i=Ds(e,"x","separableConv2d"),l=Ds(t,"depthwiseFilter","separableConv2d"),u=Ds(n,"pointwiseFilter","separableConv2d");let c=i,d=!1;if(3===i.rank&&(d=!0,c=du(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ae(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),ae(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),ae(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),ae(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),ae(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const h=l.shape[2],p=l.shape[3];ae(u.shape[2]===h*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`));const f=Hu(c,l,r,a,o,s),m=$u(f,u,1,"valid",o);return d?du(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});var Jd=async function(e,t){const n=Ds(e,"x","setdiff1d"),r=Ds(t,"y","setdiff1d");ae(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),ae(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),ae(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const a=await n.data(),s=await r.data(),o=new Set(s);let i=0;for(let e=0;e<a.length;e++)o.has(a[e])||i++;const l=new Za([i],n.dtype),u=new Za([i],"int32");for(let e=0,t=0;e<a.length;e++)o.has(a[e])||(l.values[t]=a[e],u.values[t]=e,t++);return[l.toTensor(),u.toTensor()]};var Qd=Ls({sign_:function(e){const t={x:Ds(e,"x","sign")};return Is.runKernel(Cr,t)}});var eh=Ls({sin_:function(e){const t={x:Ds(e,"x","sin","float32")};return Is.runKernel(Sr,t)}});var th=Ls({sinh_:function(e){const t={x:Ds(e,"x","sinh")};return Is.runKernel(Ir,t)}});var nh=Ls({slice1d_:function(e,t,n){const r=Ds(e,"x","slice1d");return ae(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),Au(r,[t],[n])}});var rh=Ls({slice2d_:function(e,t,n){const r=Ds(e,"x","slice2d");return ae(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),Au(r,t,n)}});var ah=Ls({slice3d_:function(e,t,n){const r=Ds(e,"x","slice3d");return ae(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),Au(r,t,n)}});var sh=Ls({slice4d_:function(e,t,n){const r=Ds(e,"x","slice4d");return ae(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),Au(r,t,n)}});var oh=Ls({softmax_:function(e,t=-1){const n=Ds(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},a={dim:t};return Is.runKernel($r,r,a)}});var ih=Ls({fft_:function(e){ae("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Is.runKernel(nn,t)}});var lh=Ls({ifft_:function(e){ae("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Is.runKernel(fn,t)}});var uh=Ls({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const a=du(e,[n,t]);r=lh(a)}else{const a=[n,2*(t-1)],s=du(Mi(e),[n,t]),o=du(Ri(e),[n,t]),i=Vd(Au(s,[0,1],[n,t-2]),1),l=zl(Vd(Au(o,[0,1],[n,t-2]),1),fc(-1)),u=fu([s,i],1),c=fu([o,l],1),d=du(Bs(u,c),[a[0],a[1]]);r=lh(d)}if(r=Mi(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=du(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});var ch=Ls({split_:function(e,t,n=0){const r={x:Ds(e,"x","split")},a={numOrSizeSplits:t,axis:n};return Is.runKernel(Mr,r,a)}});var dh=Ls({rfft_:function(e,t){ae("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let a;if(null!=t&&t<n){const r=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,a=Au(e,r,s),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,a=fu([e,dd(r)],e.shape.length-1),n=t}else a=e;const s=Yu(a),o=du(Bs(a,s),[r,n]),i=ih(o),l=Math.floor(n/2)+1,u=Mi(i),c=Ri(i),d=ch(u,[l,n-l],u.shape.length-1),h=ch(c,[l,n-l],c.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,du(Bs(d[0],h[0]),p)}});var hh=Ls({squaredDifference_:function(e,t){let n=Ds(e,"a","squaredDifference"),r=Ds(t,"b","squaredDifference");[n,r]=As(n,r),Pi(n.shape,r.shape);const a={a:n,b:r};return Is.runKernel(Lr,a,{})}});var ph=Ls({squeeze_:function(e,t){const n=Ds(e,"x","squeeze","string_or_numeric");return du(n,xe(n.shape,t).newShape)}});var fh=Ls({stack_:function(e,t=0){const n=zs(e,"tensors","stack","string_or_numeric");ae(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&ae(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:t};return Is.runKernel(er,r,a)}});var mh=Ls({step_:function(e,t=0){const n={x:Ds(e,"x","step")},r={alpha:t};return Is.runKernel(ra,n,r)}});var Ah=Ls({stridedSlice_:function(e,t,n,r,a=0,s=0,o=0,i=0,l=0){const u={x:Ds(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};return Is.runKernel(Wr,u,c)}});var gh=Ls({tan_:function(e){const t={x:Ds(e,"x","tan","float32")};return Is.runKernel(Hr,t)}});function yh(e,t){oe(e);const n=$s(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ws(e,null,n,t)}function xh(e,t,n){if(oe(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=$s(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ws(e,t,r,n)}function bh(e,t,n){if(oe(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=$s(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ws(e,t,r,n)}function vh(e,t,n){if(oe(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=$s(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ws(e,t,r,n)}function wh(e,t,n){if(oe(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=$s(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Ws(e,t=t||r,r,n)}var kh=Ls({topk_:function(e,t=1,n=!0){const r=Ds(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);const s={x:r},o={k:t,sorted:n},[i,l]=Is.runKernel(Kr,s,o);return{values:i,indices:l}}});var Sh=Ls({truncatedNormal_:function(e,t=0,n=1,r,a){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new Fd(t,n,r,!0,a),o=Do(e,r);for(let e=0;e<o.values.length;e++)o.values[e]=s.nextValue();return o.toTensor()}});var Ih=Ls({unique_:function(e,t=0){const n=Ds(e,"x","unique","string_or_numeric");ae(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},a={axis:t},[s,o]=Is.runKernel(Jr,r,a);return{values:s,indices:o}}});var Ch=Ls({unsortedSegmentSum_:function(e,t,n){const r=Ds(e,"x","unsortedSegmentSum"),a=Ds(t,"segmentIds","unsortedSegmentSum","int32");ae(de(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},o={numSegments:n};return Is.runKernel(ea,s,o)}});var Eh=Ls({unstack_:function(e,t=0){const n=Ds(e,"x","unstack","string_or_numeric");ae(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},a={axis:t};return Is.runKernel(Qr,r,a)}});function Nh(e,t){return ad(e,t,"right")}function Th(e,t=!0,n,r){return Is.makeVariable(e,t,n,r)}function Rh(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const r=Do(e,"int32"),a=Do([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const s=r.indexToLoc(n[t]),o=t*e.length;a.values.set(s,o)}return a.toTensor()}var _h=async function(e){const t=Ds(e,"condition","whereAsync","bool"),n=await t.data(),r=Rh(t.shape,n);return e!==t&&t.dispose(),r};var Mh=async function(e,t,n){const r=Ds(e,"tensor","boolMask"),a=Ds(t,"mask","boolMask","bool"),s=null==n?0:n,o=a.rank,i=r.shape;ae(o>0,(()=>"mask cannot be scalar")),se(i.slice(s,s+o),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let e=s;e<s+o;e++)l*=i[e];const u=i.slice(0,s).concat([l],i.slice(s+o)),c=du(r,u),d=du(a,[-1]),h=await _h(d),p=ph(h,[1]),f=Nc(c,p,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f};var $h=Ls({movingAverage_:function(e,t,n,r,a=!0){const s=Ds(e,"v","movingAverage"),o=Ds(t,"x","movingAverage"),i=Ds(n,"decay","movingAverage");gs(s,o),ae(ce(s.shape,o.shape),(()=>"Shape mismatch in v and x"));const l=fc(1),u=Zc(l,i);let c=zl(Zc(o,s),u);if(a){ae(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=Ds(r,"step","movingAverage");c=Dl(c,Zc(l,pc(i,e)))}return Fl(s,c)}});var Fh=Ls({scatterND_:function(e,t,n){const r=Ds(e,"indices","scatterND","int32"),a=Ds(t,"updates","scatterND");Yi(a,r,n);const s={indices:r,updates:a},o={shape:n};return Is.runKernel(xr,s,o)}});var Oh=Ls({sparseToDense_:function(e,t,n,r=0){const a=Ds(e,"sparseIndices","sparseToDense","int32"),s=Ds(t,"sparseValues","sparseToDense","string_or_numeric"),o=Ds(r,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const o=t.size;if(0!==t.rank&&(1!==t.rank||o!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,s,n,o);const i={sparseIndices:a,sparseValues:s,defaultValue:o},l={outputShape:n};return Is.runKernel(Pr,i,l)}});var Dh=Ls({gatherND_:function(e,t){const n=Ds(t,"indices","gatherND","int32"),r={params:Ds(e,"x","gatherND","string_or_numeric"),indices:n};return Is.runKernel(cn,r)}});var zh=Ls({dropout_:function(e,t,n,r){const a=Ds(e,"x","dropout");if(ae("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),ae(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof Qa?a.clone():a;const s=function(e,t){if(null==t)return e.shape.slice();if(ce(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),o=1-t,i=Dl(Ec(Fl(Pd(s,0,1,"float32",r),o)),o);return zl(a,i)}});function Ph(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Lh(e,t,n){const r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){const o=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(o)}return yh(a,"float32")}var Bh=async function(e,t,n=1){const r=Ds(e,"predictions","inTopK"),a=Ds(t,"targets","inTopK");ae(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),ae(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),se(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];ae(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));const o=await r.data(),i=await a.data(),[l,u]=[o.length/s,s],c=be("bool",l);for(let e=0;e<l;e++){const t=e*u,r=o.subarray(t,t+u),a=[];for(let e=0;e<r.length;e++)a.push({value:r[e],index:e});a.sort(((e,t)=>t.value-e.value)),c[e]=0;for(let t=0;t<n;t++)if(a[t].index===i[e]){c[e]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),Us(c,a.shape,"bool")},Wh={};S(Wh,{conv2d:()=>qh,depthwiseConv2d:()=>Zh,matMul:()=>Yh});var Uh=Ls({conv2DBackpropFilter_:function(e,t,n,r,a,s="NHWC",o){let i=e;3===e.rank&&(i=du(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=du(t,[1,t.shape[0],t.shape[1],t.shape[2]])),ae(4===i.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`)),ae(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),ae(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===s?i.shape[3]:i.shape[1],c="NHWC"===s?l.shape[3]:l.shape[1];ae(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),ae(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),cu("conv2dDerFilter",a,o);const d={x:i,dy:l},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:n};return Is.runKernel(Nt,d,h)}});function Vh(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return zl(e,mh(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function jh(e,t){let n=t;const r=zi(e.shape,t.shape);return r.length>0&&(n=gc(n,r)),du(n,e.shape)}function Gh(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Wd(e);if("elu"===t)return tc(e);if("relu6"===t)return Ud(e);if("prelu"===t)return Rd(e,n);if("leakyrelu"===t)return Fc(e,r);if("sigmoid"===t)return mu(e);throw new Error(`Unknown fused activation ${t}.`)}var Hh=(e,t)=>!(e>0)||"linear"===t;var qh=Ls({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",!1===Hh(Is.state.gradientDepth,l)){ae("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let d=$u(e,t,n,r,a,s,o);return null!=i&&(d=Fl(d,i)),Gh(d,l,u,c)}const d=Ds(e,"x","conv2d","float32"),h=Ds(t,"filter","conv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=du(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ae(4===p.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`)),ae(4===h.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`)),cu("fused conv2d",r,o);const m="NHWC"===a?p.shape[3]:p.shape[1];ae(h.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`)),ae(lu(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));const A=eu(p.shape,h.shape,n,s,r,o);let g,y;if(null!=i&&(g=Ds(i,"bias","fused conv2d"),[g]=As(g,d),"NHWC"===a?Pi(A.outShape,g.shape):(ae(g.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`)),ae(0===g.shape.length||g.shape[0]===A.outChannels||1===g.shape[0],(()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${A.outChannels})`)))),null!=u){const e=u.shape;if(ae(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)ae(1===e[0]||e[0]===A.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${A.outChannels}).`));else if(3===e.length)try{Pi(e,A.outShape)}catch(t){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${A.outShape}).`;throw Error(n)}y=Ds(u,"prelu weights","fused conv2d")}const x=(e,t)=>{ae("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));const[o,i,u,c]=t,d=Vh(e,u,l);ae(iu(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));const h=[Ou(i.shape,d,o,n,r),Uh(i,d,o.shape,n,r)];if(null!=c){const e=jh(c,d);h.push(e)}return h},b={x:p,filter:h,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:c};if(null==i){return Hc(((e,t,n)=>{let r=Is.runKernel(ia,b,v);return n([t,e,r]),f&&(r=du(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}))(p,h)}return Hc(((e,t,n,r)=>{let a=Is.runKernel(ia,b,v);return r([t,e,a,n]),f&&(a=du(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}))(p,h,g)}});var Xh=Ls({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a,s=[1,1],o){let i=e;3===e.rank&&(i=du(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=du(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:i,dy:l},c={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:n};return Is.runKernel(Wt,u,c)}});var Kh=Ls({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a,s=[1,1],o){let i=t,l=!1;3===t.rank&&(l=!0,i=du(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:i,filter:n},c={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:e},d=Is.runKernel(Ut,u,c);return l?du(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});var Zh=Ls({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===Hh(Is.state.gradientDepth,l)){let d=Hu(e,t,n,r,a,s,o);return null!=i&&(d=Fl(d,i)),Gh(d,l,u,c)}const d=Ds(e,"x","depthwiseConv2d","float32"),h=Ds(t,"filter","depthwiseConv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=du(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ae(4===p.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`)),ae(4===h.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`)),ae(p.shape[3]===h.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`)),null==s&&(s=[1,1]),ae(lu(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),cu("fused depthwiseConv2d",r,o);const m=eu(p.shape,h.shape,n,s,r,o,!0);let A,g;null!=i&&(A=Ds(i,"bias","fused conv2d"),[A]=As(A,d),Pi(m.outShape,A.shape)),null!=u&&(g=Ds(u,"prelu weights","fused depthwiseConv2d"));const y=(e,t)=>{ae(iu(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));const[a,i,u,c]=t,d=Vh(e,u,l),h=Kh(i.shape,d,a,n,r,s,o),p=Xh(i,d,a.shape,n,r,s,o);if(null!=c){return[h,p,jh(A,d)]}return[h,p]},x={x:p,filter:h,bias:A,preluActivationWeights:g},b={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:c};if(null==i){return Hc(((e,t,n)=>{let r=Is.runKernel(la,x,b);return n([t,e,r]),f&&(r=du(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}}))(p,h)}return Hc(((e,t,n,r)=>{let a=Is.runKernel(la,x,b);return r([t,e,a,n]),f&&(a=du(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:y}}))(p,h,A)}});var Yh=Ls({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(!1===Hh(Is.state.gradientDepth,s)){let l=ii(e,t,n,r);return null!=a&&(l=Fl(l,a)),Gh(l,s,o,i)}let l=Ds(e,"a","fused matMul"),u=Ds(t,"b","fused matMul");[l,u]=As(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),A=le(f),g=le(m);ae(c===d,(()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));const y=Pi(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),x=du(l,n?[A,c,h]:[A,h,c]),b=du(u,r?[g,p,d]:[g,d,p]);let v,w;null!=a&&(v=Ds(a,"bias","fused matMul"),[v]=As(v,l),Pi(y,v.shape)),null!=o&&(w=Ds(o,"prelu weights","fused matMul"));const k=(e,t)=>{const[o,i,l,u]=t,c=Vh(du(e,l.shape),l,s);let d,h;if(n||r?!n&&r?(d=ii(c,i,!1,!1),h=ii(c,o,!0,!1)):n&&!r?(d=ii(i,c,!1,!0),h=ii(o,c,!1,!1)):(d=ii(i,c,!0,!0),h=ii(c,o,!0,!0)):(d=ii(c,i,!1,!0),h=ii(o,c,!0,!1)),null!=a){return[d,h,jh(u,c)]}return[d,h]},S={a:x,b:b,bias:v,preluActivationWeights:w},I={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:i};if(null==a){return Hc(((e,t,n)=>{const r=Is.runKernel(oa,S,I);return n([e,t,r]),{value:du(r,y),gradFunc:k}}))(x,b)}return Hc(((e,t,n,r)=>{const a=Is.runKernel(oa,S,I);return r([e,t,a,n]),{value:du(a,y),gradFunc:k}}))(x,b,v)}});var Jh=Ls({hammingWindow_:function(e){return Lh(e,.54,.46)}});var Qh=Ls({hannWindow_:function(e){return Lh(e,.5,.5)}});var ep=Ls({frame_:function(e,t,n,r=!1,a=0){let s=0;const o=[];for(;s+t<=e.size;)o.push(Au(e,s,t)),s+=n;if(r)for(;s<e.size;){const r=s+t-e.size,i=fu([Au(e,s,t-r),Cc([r],a)]);o.push(i),s+=n}return 0===o.length?xh([],[0,t]):du(fu(o),[o.length,t])}});var tp=Ls({stft_:function(e,t,n,r,a=Qh){null==r&&(r=Ph(t));const s=ep(e,t,n),o=zl(s,a(t));return dh(o,r)}});var np=Ls({cropAndResize_:function(e,t,n,r,a="bilinear",s=0){const o=Ds(e,"image","cropAndResize"),i=Ds(t,"boxes","cropAndResize","float32"),l=Ds(n,"boxInd","cropAndResize","int32"),u=i.shape[0];ae(4===o.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`)),ae(2===i.rank&&4===i.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`)),ae(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`)),ae(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),ae(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),ae("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));const c={image:o,boxes:i,boxInd:l},d={method:a,extrapolationValue:s,cropSize:r};return Is.runKernel(zt,c,d)}});var rp=Ls({flipLeftRight_:function(e){const t=Ds(e,"image","flipLeftRight","float32");ae(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return Is.runKernel(an,n,{})}});var ap=Ls({grayscaleToRGB_:function(e){const t=Ds(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];ae(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),ae(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Sc(t,a)}});var sp=Ls({rotateWithOffset_:function(e,t,n=0,r=.5){const a=Ds(e,"image","rotateWithOffset","float32");ae(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));const s={image:a},o={radians:t,fillValue:n,center:r};return Is.runKernel(sa,s,o)}});function op(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=e.shape[0];return n=Math.min(n,o),ae(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),ae(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),ae(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),ae(1===t.rank,(()=>"scores must be a 1D tensor")),ae(t.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`)),ae(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}var ip=Ls({nonMaxSuppression_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){const s=Ds(e,"boxes","nonMaxSuppression","float32"),o=Ds(t,"scores","nonMaxSuppression","float32"),i=op(s,o,n,r,a),l={maxOutputSize:n=i.maxOutputSize,iouThreshold:r=i.iouThreshold,scoreThreshold:a=i.scoreThreshold};return Is.runKernel(Kn,{boxes:s,scores:o},l)}});function lp(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,s=0,o=!1;for(;r<a;){s=r+(a-r>>>1);const i=n(t,e[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}(e,t,n||up)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function up(e,t){return e>t?1:e<t?-1:0}function cp(e,t,n,r,a){return pp(e,t,n,r,a,0)}function dp(e,t,n,r,a,s){return pp(e,t,n,r,a,0,!1,s,!0)}function hp(e,t,n,r,a,s){return pp(e,t,n,r,a,s,!0)}function pp(e,t,n,r,a,s,o=!1,i=!1,l=!1){const u=[];for(let e=0;e<t.length;e++)t[e]>a&&u.push({score:t[e],boxIndex:e,suppressBeginIndex:0});u.sort(Ap);const c=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=t;if(n<a)break;let i=!1;for(let n=d.length-1;n>=o;--n){const o=fp(e,s,d[n]);if(o>=r){i=!0;break}if(t.score=t.score*mp(r,c,o),t.score<=a)break}t.suppressBeginIndex=d.length,i||(t.score===n?(d.push(s),h.push(t.score)):t.score>a&&lp(u,t,Ap))}const p=d.length,f=n-p;i&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return o&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function fp(e,t,n){const r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),p=(i-s)*(l-o),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(s,u),A=Math.max(o,c),g=Math.min(i,d),y=Math.min(l,h),x=Math.max(g-m,0)*Math.max(y-A,0);return x/(p+f-x)}function mp(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function Ap(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}var gp=async function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){const s=Ds(e,"boxes","nonMaxSuppressionAsync"),o=Ds(t,"scores","nonMaxSuppressionAsync"),i=op(s,o,n,r,a);n=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:d}=cp(u,c,n,r,a);return s!==e&&s.dispose(),o!==t&&o.dispose(),yh(d,"int32")};var yp=Ls({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){const o=Ds(e,"boxes","nonMaxSuppression"),i=Ds(t,"scores","nonMaxSuppression"),l=op(o,i,n,r,a,s),u={boxes:o,scores:i},c={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:a=l.scoreThreshold,softNmsSigma:s=l.softNmsSigma},d=Is.runKernel(Yn,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}});var xp=async function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){const o=Ds(e,"boxes","nonMaxSuppressionAsync"),i=Ds(t,"scores","nonMaxSuppressionAsync"),l=op(o,i,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const u=await Promise.all([o.data(),i.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=hp(c,d,n,r,a,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:yh(h,"int32"),selectedScores:yh(p)}};var bp=Ls({nonMaxSuppressionPadded_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){const o=Ds(e,"boxes","nonMaxSuppression"),i=Ds(t,"scores","nonMaxSuppression"),l=op(o,i,n,r,a,null),u={boxes:o,scores:i},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},d=Is.runKernel(Zn,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}});var vp=async function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){const o=Ds(e,"boxes","nonMaxSuppressionAsync"),i=Ds(t,"scores","nonMaxSuppressionAsync"),l=op(o,i,n,r,a,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:m}=dp(h,p,u,c,d,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:yh(f,"int32"),validOutputs:fc(m,"int32")}};var wp=Ls({resizeBilinear_:function(e,t,n=!1,r=!1){const a=Ds(e,"images","resizeBilinear");ae(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),ae(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),ae(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=du(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Is.runKernel(pr,i,l);return o?du(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var kp=Ls({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const a=Ds(e,"images","resizeNearestNeighbor");ae(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),ae(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),ae("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),ae(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,o=!1;3===a.rank&&(o=!0,s=du(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,i={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Is.runKernel(dr,i,l);return o?du(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var Sp=Ls({threshold_:function(e,t="binary",n=!1,r=.5){const a=Ds(e,"image","threshold"),s=a.shape[0]*a.shape[1];let o,i,l,u,c=zl(yh([r]),255);if(ae(3===a.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`)),ae(3===a.shape[2]||1===a.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`)),ae("int32"===a.dtype||"float32"===a.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`)),ae("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===a.shape[2]){[o,i,l]=ch(a,[1,1,1],-1);const e=zl(o,.2989),t=zl(i,.587),n=zl(l,.114);u=Fl(Fl(e,t),n)}else u=e;if("otsu"===t){c=function(e,t){let n,r,a,s,o,i,l=yh([-1]),u=yh([0]),c=yh([0]);for(let d=0;d<e.size-1;d++){n=Au(e,0,d+1),r=Au(e,d+1),o=Dl(gc(n),t),i=Dl(gc(r),t);const h=gc(zl(n,Ld(0,n.size)));a=Dl(h,gc(n));const p=Cc(r.shape,n.size),f=Fl(Ld(0,r.size),p),m=zl(r,f);s=Dl(gc(m),gc(r));const A=Zc(a,s),g=Zc(a,s),y=zl(o,i);c=zl(zl(y,A),g);const x=Tc(c,u);u=Zu(x,c,u),l=Zu(x,yh([d]),l)}return l}(Su(zo(Xd(u),"int32"),Us([]),256),s)}const d=n?Dc(u,c):Tc(u,c);return zo(zl(d,255),"int32")}});var Ip=Ls({transform_:function(e,t,n="nearest",r="constant",a=0,s){const o=Ds(e,"image","transform","float32"),i=Ds(t,"transforms","transform","float32");ae(4===o.rank,(()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`)),ae(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),ae(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const l={image:o,transforms:i},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return Is.runKernel(Zr,l,u)}});var Cp=Ls({bandPart_:function(e,t,n){ae(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),ae(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const r=Ds(e,"a","bandPart");ae(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const a=r.shape,[s,o]=r.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);t<0&&(t=s),n<0&&(n=o);const i=du(Ld(0,s,1,"int32"),[-1,1]),l=Ld(0,o,1,"int32"),u=Zc(i,l),c=Qc(Dc(u,fc(+t,"int32")),Rc(u,fc(-n,"int32"))),d=dd([s,o],r.dtype);return du(fh(Eh(du(r,[-1,s,o])).map((e=>Zu(c,e,d)))),a)}});var Ep=Ls({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,ae(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)ae(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=ch(e,e.shape[0],0).map((e=>ph(e,[0])));ae(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let t=0;t<e.length;++t)n.push(Is.tidy((()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){const t=zl(gc(zl(n[r],e)),n[r]);e=Zc(e,t)}return Dl(e,xc(e,"euclidean"))})));return t?fh(n,0):n}});function Np(e,t=!1){return Is.tidy((()=>{ae(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let a=Ic(n),s=Po(e);const o=xh([[1]],[1,1]);let i=Po(o);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=s,l=i,u=a;[i,s,a]=Is.tidy((()=>{const t=Au(s,[e,e],[n-e,1]),l=xc(t),u=Au(s,[e,e],[1,1]),c=Zu(Tc(u,0),xh([[-1]]),xh([[1]])),d=Zc(u,zl(c,l)),h=Dl(t,d);i=1===h.shape[0]?Po(o):fu([o,Au(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=_i(Dl(ii(c,d),l)),f=Au(s,[e,0],[n-e,r]),m=zl(p,i),A=$i(i);if(0===e)s=Zc(f,ii(m,ii(A,f)));else{const t=Zc(f,ii(m,ii(A,f)));s=fu([Au(s,[0,0],[e,r]),t],0)}const g=$i(m),y=Au(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=Zc(y,ii(ii(y,i),g));else{const t=Zc(y,ii(ii(y,i),g));a=fu([Au(a,[0,0],[n,e]),t],1)}return[i,s,a]})),yi([t,l,u])}return!t&&n>r&&(a=Au(a,[0,0],[n,r]),s=Au(s,[0,0],[r,r])),[a,s]}))}var Tp,Rp,_p=Ls({qr_:function(e,t=!1){if(ae(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Np(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Eh(du(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach((e=>{const[n,r]=Np(e,t);a.push(n),s.push(r)}));return[du(fh(a,0),e.shape),du(fh(s,0),e.shape)]}}});(Rp=Tp||(Tp={}))[Rp.NONE=0]="NONE",Rp[Rp.MEAN=1]="MEAN",Rp[Rp.SUM=2]="SUM",Rp[Rp.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS";var Mp=Ls({computeWeightedLoss_:function(e,t,n=Tp.SUM_BY_NONZERO_WEIGHTS){const r=Ds(e,"losses","computeWeightedLoss");let a=null;null!=t&&(a=Ds(t,"weights","computeWeightedLoss"));const s=null==a?r:zl(r,a);if(n===Tp.NONE)return s;if(n===Tp.SUM)return gc(s);if(n===Tp.MEAN){if(null==a)return cd(s);{const e=r.size/a.size,t=Dl(gc(s),gc(a));return e>1?Dl(t,fc(e)):t}}if(n===Tp.SUM_BY_NONZERO_WEIGHTS){if(null==a)return Dl(gc(s),fc(r.size));{const e=zl(a,hd(r.shape)),t=zo(gc(bd(e,fc(0))),"float32");return Dl(gc(s),t)}}throw Error(`Unknown reduction: ${n}`)}});var $p=Ls({absoluteDifference_:function(e,t,n,r=Tp.SUM_BY_NONZERO_WEIGHTS){const a=Ds(e,"labels","absoluteDifference"),s=Ds(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=Ds(n,"weights","absoluteDifference")),se(a.shape,s.shape,"Error in absoluteDifference: ");const i=Pl(Zc(a,s));return Mp(i,o,r)}});var Fp=Ls({cosineDistance_:function(e,t,n,r,a=Tp.SUM_BY_NONZERO_WEIGHTS){const s=Ds(e,"labels","cosineDistance"),o=Ds(t,"predictions","cosineDistance");let i=null;null!=r&&(i=Ds(r,"weights","cosineDistance")),se(s.shape,o.shape,"Error in cosineDistance: ");const l=fc(1),u=Zc(l,gc(zl(s,o),n,!0));return Mp(u,i,a)}});var Op=Ls({hingeLoss_:function(e,t,n,r=Tp.SUM_BY_NONZERO_WEIGHTS){let a=Ds(e,"labels","hingeLoss");const s=Ds(t,"predictions","hingeLoss");let o=null;null!=n&&(o=Ds(n,"weights","hingeLoss")),se(a.shape,s.shape,"Error in hingeLoss: ");const i=fc(1);a=Zc(zl(fc(2),a),i);const l=Wd(Zc(i,zl(a,s)));return Mp(l,o,r)}});var Dp=Ls({huberLoss_:function(e,t,n,r=1,a=Tp.SUM_BY_NONZERO_WEIGHTS){const s=Ds(e,"labels","huberLoss"),o=Ds(t,"predictions","huberLoss");let i=null;null!=n&&(i=Ds(n,"weights","huberLoss")),se(s.shape,o.shape,"Error in huberLoss: ");const l=fc(r),u=Pl(Zc(o,s)),c=fd(u,l),d=Zc(u,c),h=Fl(zl(fc(.5),Ac(c)),zl(l,d));return Mp(h,i,a)}});var zp=Ls({logLoss_:function(e,t,n,r=1e-7,a=Tp.SUM_BY_NONZERO_WEIGHTS){const s=Ds(e,"labels","logLoss"),o=Ds(t,"predictions","logLoss");let i=null;null!=n&&(i=Ds(n,"weights","logLoss")),se(s.shape,o.shape,"Error in logLoss: ");const l=fc(1),u=fc(r),c=_i(zl(s,Lc(Fl(o,u)))),d=zl(Zc(l,s),Lc(Fl(Zc(l,o),u))),h=Zc(c,d);return Mp(h,i,a)}});var Pp=Ls({meanSquaredError_:function(e,t,n,r=Tp.SUM_BY_NONZERO_WEIGHTS){const a=Ds(e,"labels","meanSquaredError"),s=Ds(t,"predictions","meanSquaredError");let o=null;null!=n&&(o=Ds(n,"weights","meanSquaredError")),se(a.shape,s.shape,"Error in meanSquaredError: ");const i=hh(a,s);return Mp(i,o,r)}});var Lp=Ls({sigmoidCrossEntropy_:function(e,t,n,r=0,a=Tp.SUM_BY_NONZERO_WEIGHTS){let s=Ds(e,"multiClassLabels","sigmoidCrossEntropy");const o=Ds(t,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=Ds(n,"weights","sigmoidCrossEntropy")),se(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=fc(r),t=fc(1),n=fc(.5);s=Fl(zl(s,Zc(t,e)),zl(n,e))}const l=function(e,t){const n=Ds(e,"labels","sigmoidCrossEntropyWithLogits"),r=Ds(t,"logits","sigmoidCrossEntropyWithLogits");se(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=Wd(r),s=zl(r,n),o=Bc(vc(_i(Pl(r))));return Fl(Zc(a,s),o)}(s,o);return Mp(l,i,a)}});var Bp=Ls({softmaxCrossEntropy_:function(e,t,n,r=0,a=Tp.SUM_BY_NONZERO_WEIGHTS){let s=Ds(e,"onehotLabels","softmaxCrossEntropy");const o=Ds(t,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=Ds(n,"weights","softmaxCrossEntropy")),se(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const e=fc(r),t=fc(1),n=fc(s.shape[1]);s=Fl(zl(s,Zc(t,e)),Dl(e,n))}const l=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Hc(((e,t,r)=>{const a=Jc(t,[n],!0),s=Zc(zo(t,"float32"),a);r([e,s]);const o=_i(zl(s,e));return{value:gc(o,[n]),gradFunc:(e,t)=>{const[r,a]=t,s=oc(e.shape,[n]);return[zl(du(e,s),Zc(zo(r,"float32"),vc(a))),zl(du(e,s),Zc(vc(a),zo(r,"float32")))]}}}))(e,t)}(s,o);return Mp(l,i,a)}});var Wp=Ls({sparseFillEmptyRows_:function(e,t,n,r){const a=Ds(e,"indices","sparseFillEmptyRows","int32"),s=Ds(t,"values","sparseFillEmptyRows"),o=Ds(n,"denseShape","sparseFillEmptyRows","int32"),i=Ds(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==i.rank)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const l={indices:a,values:s,denseShape:o,defaultValue:i},u=Is.runKernel(Fr,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});var Up=Ls({sparseReshape_:function(e,t,n){const r=Ds(e,"inputIndices","sparseReshape","int32"),a=Ds(t,"inputShape","sparseReshape","int32"),s=Ds(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:r,inputShape:a,newShape:s},i=Is.runKernel(Or,o);return{outputIndices:i[0],outputShape:i[1]}}});var Vp=Ls({sparseSegmentMean_:function(e,t,n){const r=Ds(e,"data","sparseSegmentMean"),a=Ds(t,"indices","sparseSegmentMean","int32"),s=Ds(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const o={data:r,indices:a,segmentIds:s};return Is.runKernel(Dr,o)}});var jp=Ls({sparseSegmentSum_:function(e,t,n){const r=Ds(e,"data","sparseSegmentSum"),a=Ds(t,"indices","sparseSegmentSum","int32"),s=Ds(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const o={data:r,indices:a,segmentIds:s};return Is.runKernel(zr,o)}});var Gp=Ls({stringNGrams_:function(e,t,n,r,a,s,o,i){const l=Ds(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=Ds(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:o,preserveShortSequences:i},d={data:l,dataSplits:u},h=Is.runKernel(Ur,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}});var Hp=Ls({stringSplit_:function(e,t,n=!0){const r=Ds(e,"input","stringSplit","string"),a=Ds(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);const s={skipEmpty:n},o={input:r,delimiter:a},i=Is.runKernel(Vr,o,s);return{indices:i[0],values:i[1],shape:i[2]}}});var qp=Ls({stringToHashBucketFast_:function(e,t){const n=Ds(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return Is.runKernel(jr,a,r)}}),Xp={fft:ih,ifft:lh,rfft:dh,irfft:uh},Kp={hammingWindow:Jh,hannWindow:Qh,frame:ep,stft:tp},Zp={flipLeftRight:rp,grayscaleToRGB:ap,resizeNearestNeighbor:kp,resizeBilinear:wp,rotateWithOffset:sp,cropAndResize:np,nonMaxSuppression:ip,nonMaxSuppressionAsync:gp,nonMaxSuppressionWithScore:yp,nonMaxSuppressionWithScoreAsync:xp,nonMaxSuppressionPadded:bp,nonMaxSuppressionPaddedAsync:vp,threshold:Sp,transform:Ip},Yp={bandPart:Cp,gramSchmidt:Ep,qr:_p},Jp={absoluteDifference:$p,computeWeightedLoss:Mp,cosineDistance:Fp,hingeLoss:Op,huberLoss:Dp,logLoss:zp,meanSquaredError:Pp,sigmoidCrossEntropy:Lp,softmaxCrossEntropy:Bp},Qp={sparseFillEmptyRows:Wp,sparseReshape:Up,sparseSegmentMean:Vp,sparseSegmentSum:jp},ef={stringNGrams:Gp,stringSplit:Hp,stringToHashBucketFast:qp},tf=class extends yl{minimize(e,t=!1,n){const{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return yi(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Gc(e,t)}dispose(){null!=this.iterations_&&yi(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:fc(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(tf,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var nf=class extends tf{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Is.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Is.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:gi((()=>Yu(r).variable(false)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:gi((()=>Yu(r).variable(false)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const s=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;gi((()=>{const e=Fl(zl(s,this.rho),zl(Ac(a),1-this.rho)),t=zl(Dl(mc(Fl(o,this.epsilon)),mc(Fl(s,this.epsilon))),a),n=Fl(zl(o,this.rho),zl(Ac(t),1-this.rho));s.assign(e),o.assign(n);const i=Fl(zl(t,-this.learningRate),r);r.assign(i)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(yi(this.accumulatedGrads.map((e=>e.variable))),yi(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};nf.className="Adadelta",bl(nf);var rf=class extends tf{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Is.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:gi((()=>Cc(r.shape,this.initialAccumulatorValue).variable(e)))}}const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const s=this.accumulatedGrads[n].variable;gi((()=>{const e=Fl(s,Ac(a));s.assign(e);const t=Fl(zl(Dl(a,mc(Fl(e,Is.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&yi(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};rf.className="Adagrad",bl(rf);var af=class extends tf{constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],gi((()=>{this.accBeta1=fc(t).variable(),this.accBeta2=fc(n).variable()})),null==r&&(this.epsilon=Is.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);gi((()=>{const n=Zc(1,this.accBeta1),r=Zc(1,this.accBeta2);t.forEach(((t,a)=>{const s=Is.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:gi((()=>Yu(s).variable(false)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:gi((()=>Yu(s).variable(false)))});const o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,u=Fl(zl(i,this.beta1),zl(o,1-this.beta1)),c=Fl(zl(l,this.beta2),zl(Ac(o),1-this.beta2)),d=Dl(u,n),h=Dl(c,r);i.assign(u),l.assign(c);const p=Fl(zl(Dl(d,Fl(mc(h),this.epsilon)),-this.learningRate),s);s.assign(p)})),this.accBeta1.assign(zl(this.accBeta1,this.beta1)),this.accBeta2.assign(zl(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&yi(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&yi(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),gi((()=>{this.accBeta1.assign(pc(this.beta1,this.iterations_+1)),this.accBeta2.assign(pc(this.beta2,this.iterations_+1))}));const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};af.className="Adam",bl(af);var sf=class extends tf{constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],gi((()=>{this.iteration=fc(0).variable(),this.accBeta1=fc(t).variable()})),null==r&&(this.epsilon=Is.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);gi((()=>{const n=Zc(1,this.accBeta1),r=Dl(-this.learningRate,Fl(zl(this.iteration,this.decay),1));t.forEach(((t,a)=>{const s=Is.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:Yu(s).variable(false)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:Yu(s).variable(false)});const o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;const i=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,u=Fl(zl(i,this.beta1),zl(o,1-this.beta1)),c=zl(l,this.beta2),d=Pl(o),h=ud(c,d);i.assign(u),l.assign(h);const p=Fl(zl(Dl(r,n),Dl(u,Fl(h,this.epsilon))),s);s.assign(p)})),this.iteration.assign(Fl(this.iteration,1)),this.accBeta1.assign(zl(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&yi(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&yi(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};sf.className="Adamax",bl(sf);var of=class extends tf{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=Is.registeredVariables[t];gi((()=>{const e=Fl(zl(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=xi(fc(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};of.className="SGD",bl(of);var lf=class extends of{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=fc(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Is.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:gi((()=>Yu(r).variable(e)))}}const a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&gi((()=>{let e;const t=Fl(zl(this.m,a),s);e=this.useNesterov?Fl(zl(this.c,Fl(s,zl(t,this.m))),r):Fl(zl(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&yi(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};lf.className="Momentum",bl(lf);var uf=class extends tf{constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Is.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Is.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:gi((()=>Yu(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:gi((()=>Yu(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:gi((()=>Yu(r).variable(a)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;gi((()=>{const e=Fl(zl(o,this.decay),zl(Ac(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,a=Fl(zl(t,this.decay),zl(s,1-this.decay)),l=Dl(zl(s,this.learningRate),mc(Zc(e,Fl(Ac(a),this.epsilon)))),u=Fl(zl(i,this.momentum),l);o.assign(e),t.assign(a),i.assign(u);const c=Zc(r,u);r.assign(c)}else{const e=Fl(zl(o,this.decay),zl(Ac(s),1-this.decay)),t=Fl(zl(i,this.momentum),Dl(zl(s,this.learningRate),mc(Fl(e,this.epsilon))));o.assign(e),i.assign(t);const n=Zc(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&yi(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&yi(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&yi(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};uf.className="RMSProp",bl(uf);var cf=class{static sgd(e){return new of(e)}static momentum(e,t,n=!1){return new lf(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new uf(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new af(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new nf(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new sf(e,t,n,r,a)}static adagrad(e,t=.1){return new rf(e,t)}},df={sgd:cf.sgd,momentum:cf.momentum,adadelta:cf.adadelta,adagrad:cf.adagrad,rmsprop:cf.rmsprop,adamax:cf.adamax,adam:cf.adam},hf="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function pf(){return new Promise((e=>hf((()=>e()))))}var ff={};function mf(e,t){const n=e[0].length;e.forEach(((e,t)=>{ae(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),ae(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)ae(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function Af(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}S(ff,{ERF_A1:()=>Nf,ERF_A2:()=>Tf,ERF_A3:()=>Rf,ERF_A4:()=>_f,ERF_A5:()=>Mf,ERF_P:()=>Ef,PARALLELIZE_THRESHOLD:()=>gf,SELU_SCALE:()=>Cf,SELU_SCALEALPHA:()=>If,applyActivation:()=>Gh,assertAndGetBroadcastShape:()=>Pi,assertAxesAreInnerMostDims:()=>ic,assertParamsConsistent:()=>mf,assignToTypedArray:()=>Pf,axesAreInnerMostDims:()=>rc,calculateShapes:()=>Ji,checkEinsumDimSizes:()=>Gf,checkPadOnDimRoundingMode:()=>cu,combineLocations:()=>ac,complexWithEvenIndex:()=>Of,complexWithOddIndex:()=>Df,computeConv2DInfo:()=>eu,computeConv3DInfo:()=>tu,computeDefaultPad:()=>nu,computeDilation2DInfo:()=>Yl,computeOptimalWindowSize:()=>yf,computeOutAndReduceShapes:()=>sc,computeOutShape:()=>Af,computePool2DInfo:()=>Jl,computePool3DInfo:()=>Ql,convertConv2DDataFormat:()=>uu,decodeEinsumEquation:()=>Vf,eitherStridesOrDilationsAreOne:()=>lu,expandShapeToKeepDim:()=>oc,exponent:()=>Bf,exponents:()=>Lf,fromStringArrayToUint8:()=>pm,fromUint8ToStringArray:()=>hm,getAxesPermutation:()=>lc,getBroadcastDims:()=>Di,getComplexWithIndex:()=>zf,getEinsumComputePath:()=>Hf,getEinsumPermutation:()=>jf,getFusedBiasGradient:()=>jh,getFusedDyActivation:()=>Vh,getImageCenter:()=>xf,getInnerMostAxes:()=>cc,getPermuted:()=>vf,getReductionAxes:()=>zi,getReshaped:()=>bf,getReshapedPermuted:()=>wf,getSliceBeginCoords:()=>kf,getSliceSize:()=>Sf,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Zf,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Yf,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Jf,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>tm,getSparseReshapeInputOutputMismatchErrorMessage:()=>rm,getSparseReshapeInputOutputMultipleErrorMessage:()=>nm,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Qf,getSparseReshapeNegativeOutputDimErrorMessage:()=>em,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>im,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>am,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>sm,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>om,getUndoAxesPermutation:()=>uc,isIdentityPermutation:()=>qf,log:()=>ca,mergeRealAndImagArrays:()=>$f,prepareAndValidate:()=>Xi,prepareSplitSize:()=>Kf,segment_util:()=>lm,shouldFuse:()=>Hh,slice_util:()=>Qi,splitRealAndImagArrays:()=>Ff,tupleValuesAreOne:()=>iu,upcastType:()=>fs,validateInput:()=>Yi,validateUpdateShape:()=>Zi,warn:()=>ua});var gf=30;function yf(e){return e<=gf?e:$e(e,Math.floor(Math.sqrt(e)))}function xf(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function bf(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function vf(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],a=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function wf(e,t,n,r=!0){const a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?a.push(t[n-1]*e[n]):a.push(e[n]/t[n-1]):a.push(e[n]);return a}function kf(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Sf(e,t,n){const r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var If=1.7580993408473768,Cf=1.0507009873554805,Ef=.3275911,Nf=.254829592,Tf=-.284496736,Rf=1.421413741,_f=-1.453152027,Mf=1.061405429;function $f(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Ff(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Of(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function Df(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function zf(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Pf(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Lf(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){const s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function Bf(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}var Wf="->",Uf=/->/g;function Vf(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Uf,"").length)/Wf.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,a]=e.split(Wf);ae(-1===r.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const s=r.split(","),o=s.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let e=0;e<a.length;++e){const t=a[e];if(!s.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===i.indexOf(t)&&i.push(t)}for(let e=0;e<r.length;++e){const t=r[e];-1===i.indexOf(t)&&","!==t&&i.push(t)}const l=new Array(s.length);for(let e=0;e<o;++e){if(new Set(s[e].split("")).size!==s[e].length)throw new Error(`Found duplicate axes in input component ${s[e]}. Support for duplicate axes in input is not implemented yet.`);l[e]=[];for(let t=0;t<s[e].length;++t)l[e].push(i.indexOf(s[e][t]))}const u=i.length,c=[];for(let e=a.length;e<u;++e)c.push(e);return{allDims:i,summedDims:c,idDims:l}}function jf(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Gf(e,t,n){const r=new Array(e);for(let e=0;e<n.length;++e){const a=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=a[n]:ae(r[t[e][n]]===a[n],(()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(a)}, but got dimension ${a[n]}`))}}function Hf(e,t){const n=e,r=[];let a=0;0===e.length&&n.push(-1),a=e.length+1;for(let e=0;e<a;++e)r.push([]);const s=[];for(let e=0;e<n.length;++e){const a=Xf(t,n[e]);for(const t of a)-1===s.indexOf(t)&&(r[e].push(t),s.push(t))}return{path:n,steps:r}}function qf(e){return e.every(((e,t)=>e===t))}function Xf(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function Kf(e,t,n=0){let r=[];if("number"==typeof t)ae(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{ae(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));const a=t.indexOf(-1);if(-1!==a){const r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}ae(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Zf(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Yf(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Jf(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Qf(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function em(e,t){return`size ${e} must be non-negative, not ${t}`}function tm(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function nm(e,t){return`Input to reshape is a SparseTensor with ${le(e)}\n  dense values, but the requested shape requires a multiple of ${le(t)}. inputShape=${e} outputShape= ${t}`}function rm(e,t){return`Input to reshape is a tensor with ${le(e)} dense values, but the requested shape has ${le(t)}. inputShape=${e} outputShape=${t}`}function am(){return"segment ids must be >= 0"}function sm(){return"segment ids are not increasing"}function om(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function im(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var lm={};function um(e,t){let n,r=!1;for(e<=gf?(n=e,r=!0):n=$e(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=$e(e,n+1);return n}function cm(e,t,n){const r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function dm(e,t,n,r){const a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const o=e.shape[n],i=[];let l=1,u=1,c=1;for(let t=0;t<r;++t)i.push(e.shape[t]),l*=e.shape[t];for(let t=r;t<n;t++)i.push(e.shape[t]),u*=e.shape[t];for(let e=r;e<a;e++)i.push(t.shape[e]);for(let t=n+1;t<s;t++)i.push(e.shape[t]),c*=e.shape[t];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:i}}function hm(e){try{return e.map((e=>Ua(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function pm(e){return e.map((e=>Wa(e)))}S(lm,{collectGatherOpShapeInfo:()=>dm,computeOutShape:()=>cm,segOpComputeOptimalWindowSize:()=>um});var fm={};S(fm,{nonMaxSuppressionV3Impl:()=>cp,nonMaxSuppressionV4Impl:()=>dp,nonMaxSuppressionV5Impl:()=>hp,whereImpl:()=>Rh});var mm={kernelName:Je,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(e,mh(zo(n,"float32"),-1))}}},Am={kernelName:Qe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Ac(zo(n,"float32")),r=mc(Zc(fc(1),t));return _i(Dl(e,r))}}}},gm={kernelName:et,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=mc(Zc(Ac(zo(n,"float32")),1));return Dl(e,t)}}}},ym={kernelName:tt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Pi(n.shape,r.shape);return{a:()=>{let t=e;const r=zi(n.shape,a);return r.length>0&&(t=gc(t,r)),du(t,n.shape)},b:()=>{let t=e;const n=zi(r.shape,a);return n.length>0&&(t=gc(t,n)),du(t,r.shape)}}}},xm={kernelName:nt,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},bm={kernelName:st,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Yu(n)}}},vm={kernelName:ot,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Yu(n)}}},wm={kernelName:it,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dl(e,mc(Zc(fc(1),Ac(zo(n,"float32")))))}}},km={kernelName:lt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=mc(Fl(fc(1),Ac(zo(n,"float32"))));return Dl(e,t)}}}},Sm={kernelName:dt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Pi(n.shape,r.shape);return{a:()=>{const t=Fl(Ac(n),Ac(r));let s=zl(e,Dl(r,t));const o=zi(n.shape,a);return o.length>0&&(s=gc(s,o)),du(s,n.shape)},b:()=>{const t=Fl(Ac(n),Ac(r));let s=_i(zl(e,Dl(n,t)));const o=zi(r.shape,a);return o.length>0&&(s=gc(s,o)),du(s,r.shape)}}}},Im={kernelName:ut,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dl(e,Fl(Ac(zo(n,"float32")),1))}}},Cm={kernelName:ct,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dl(e,Zc(fc(1),Ac(zo(n,"float32"))))}}};var Em=Ls({avgPool3dGrad_:function(e,t,n,r,a,s){const o=Ds(e,"dy","avgPool3dGrad"),i=Ds(t,"input","avgPool3dGrad");let l=o,u=i,c=!1;4===i.rank&&(c=!0,l=du(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=du(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),ae(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),ae(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),cu("avgPool3dGrad",a,s);const d={dy:l,input:u},h={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=Is.runKernel(mt,d,h);return c?du(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),Nm={kernelName:ft,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:s,pad:o,dimRoundingMode:i}=n;return{x:()=>Em(e,r,a,s,o,i)}}};var Tm=Ls({avgPoolGrad_:function(e,t,n,r,a){const s=Ds(e,"dy","avgPoolGrad"),o=Ds(t,"input","avgPoolGrad");ae(o.rank===s.rank,(()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`));let i=o,l=s,u=!1;3===o.rank&&(u=!0,i=du(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=du(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),ae(4===i.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`));const c={dy:l,input:i},d={filterSize:n,strides:r,pad:a},h=Is.runKernel(pt,c,d);return u?du(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Rm={kernelName:ht,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:s,pad:o}=n;return{x:()=>Tm(e,r,a,s,o)}}},_m={kernelName:At,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,a]=t,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>ii(e,a,!1,!1),b:()=>ii(e,r,!0,!1)}:s&&!o?{a:()=>ii(a,e,!1,!0),b:()=>ii(r,e,!1,!1)}:{a:()=>ii(a,e,!0,!0),b:()=>ii(e,r,!0,!0)}:{a:()=>ii(e,a,!1,!0),b:()=>ii(r,e,!0,!1)}}},Mm={kernelName:gt,gradFunc:(e,t,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>Nd(e,r,a)}}},$m={kernelName:xt,gradFunc:(e,t,n)=>{const r=n,a=r.inputShape,s=r.shape,o=Array.from(s);for(let e=a.length-1;e>=0;e--)if(a[e]===s[e])o[e]=1;else if(1!==a[e])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);const i=[];for(let e=0;e<o.length;e++)o[e]>1&&i.push(e);return{x:()=>gc(e,i,!0)}}},Fm={kernelName:vt,gradFunc:e=>({x:()=>e.clone()})},Om={kernelName:wt,gradFunc:e=>({x:()=>Yu(e)})},Dm={kernelName:kt,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>Zu(Qc(Rc(r,a),Dc(r,s)),e,Yu(e))}}},zm={kernelName:It,inputsToSave:["x"],gradFunc:mm.gradFunc},Pm={kernelName:Ct,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:a}=n,s=ye(a,t[0].shape)[0],o=r.map((e=>e[s]));return ch(e,o,s).map((e=>()=>e))}},Lm={kernelName:Et,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{dilations:s,strides:o,pad:i,dataFormat:l}=n;return ae(iu(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>Ou(r.shape,e,a,o,i,l),filter:()=>Uh(r,e,a.shape,o,i,l)}}},Bm={kernelName:Tt,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{strides:s,pad:o,dataFormat:i,dimRoundingMode:l}=n;return{dy:()=>$u(e,a,s,o,i,1,l),filter:()=>Uh(e,r,a.shape,s,o,i,l)}}};var Wm=Ls({conv3DBackpropFilter_:function(e,t,n,r,a){let s=e;4===e.rank&&(s=du(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;4===o.rank&&(o=du(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),ae(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),ae(5===o.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`)),ae(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),ae(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),ae(o.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`));const i={x:s,dy:o},l={strides:r,pad:a,filterShape:n};return Is.runKernel(_t,i,l)}}),Um={kernelName:Rt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:s}=n;ae(iu(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[o,i]=t;return{x:()=>Pu(o.shape,e,i,a,s),filter:()=>Wm(o,e,i.shape,a,s)}}},Vm={kernelName:$t,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(_i(eh(zo(n,"float32"))),e)}}},jm={kernelName:Ft,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(th(zo(n,"float32")),e)}}},Gm={kernelName:Dt,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a,exclusive:s,reverse:o}=n;return{x:()=>{const t=lc([a],r.rank);let n=Vu(e,a,s,!o);return null!=t&&(n=$i(n,t)),n}}}},Hm={kernelName:Bt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:o}=n,i=null==r?[1,1]:r;ae(iu(i),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[l,u]=t;return ae(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),ae(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),ae(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),ae(lu(a,i),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${i}'.`)),cu("depthwiseConv2d",s,o),{x:()=>Kh(l.shape,e,u,a,s,i,o),filter:()=>Xh(l,e,u.shape,a,s,i,o)}}},qm={kernelName:jt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,s={x:r,filter:a,dy:e},o={x:r,filter:a,dy:e};return{x:()=>Is.runKernel(Gt,s,n),filter:()=>Is.runKernel(Ht,o,n)}}},Xm={kernelName:Kt,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>Is.runKernel(Zt,r)}}},Km={kernelName:Yt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=zl(vc(_i(Ac(n))),2/Math.sqrt(Math.PI));return{x:()=>zl(e,r)}}},Zm={kernelName:Qt,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(e,n)}}},Ym={kernelName:en,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>du(e,n.shape)}}},Jm={kernelName:tn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(e,vc(n))}}},Qm={kernelName:sn,gradFunc:e=>({x:()=>Yu(e)})},eA={kernelName:on,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Pi(n.shape,r.shape);return{a:()=>{const t=Dl(e,zo(r,"float32")),s=zi(n.shape,a);return s.length>0?du(gc(t,s),n.shape):t},b:()=>{let t=zl(e,zo(n,"float32"));const s=zi(r.shape,a);s.length>0&&(t=du(gc(t,s),r.shape));const o=Ac(r);return _i(Dl(t,zo(o,"float32")))}}}},tA={kernelName:ln,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[a,s,o,i]=t,l=null==i?fc(1):i,u=zi(s.shape,a.shape),c=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)c.push(a.shape[e]);c.push(1)}const d=Zc(a,s),h=zl(e,l),p=Kd(Fl(o,fc(r))),f=zl(zl(zl(p,p),p),fc(-.5));return{x:()=>1===s.rank?du(zl(zl(e,Sc(du(p,[1,1,1,s.shape[0]]),c)),l),a.shape):du(zl(zl(e,p),l),a.shape),mean:()=>{let e=zl(zl(p,fc(-1)),h);return 1===s.rank&&(e=gc(e,u)),du(e,s.shape)},variance:()=>{let e=zl(zl(f,d),h);return 1===s.rank&&(e=gc(e,u)),du(e,s.shape)},scale:()=>{const t=zl(d,p);let n=zl(e,t);return 1===s.rank&&(n=gc(n,u)),du(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=gc(t,u)),du(t,s.shape)}}}},nA={kernelName:un,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,a]=t,{axis:s}=n,o=ye(s,r.shape)[0];return{x:()=>{const t=r.shape,n=a.size,i=t.slice(0,o),l=i.length,u=t.slice(s,t.length).slice(1),c=u.length,d=rA(0,l),h=rA(l+1,l+1+c),p=aA([i,[n],u]),f=du(e,p),m=du(a,[n]),A=aA([[l],d,h]),g=$i(f,A);let y=Ch(g,m,r.shape[o]);const x=uc(A);return y=$i(y,x),y},indices:()=>a}}};function rA(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function aA(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var sA={kernelName:hn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Yu(n),b:()=>Yu(r)}}},oA={kernelName:pn,gradFunc:e=>({x:()=>zo(e,"float32")})},iA={kernelName:An,gradFunc:e=>({x:()=>Yu(e)})},lA={kernelName:gn,gradFunc:e=>({x:()=>Yu(e)})},uA={kernelName:yn,gradFunc:e=>({x:()=>Yu(e)})},cA={kernelName:xn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:a}=n,s=Tc(r,0);return{x:()=>Zu(s,e,zl(e,a))}}},dA={kernelName:Sn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dl(e,Fl(n,1))}}},hA={kernelName:kn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dl(e,zo(n,"float32"))}}},pA={kernelName:Tn,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;return{logits:()=>{const t=vc(r);return Zc(e,zl(gc(e,a,!0),t))}}}};var fA=Ls({localResponseNormalizationBackprop_:function(e,t,n,r=5,a=1,s=1,o=.5){const i={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:s,beta:o};return Is.runKernel(Mn,i,l)}}),mA={kernelName:_n,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{depthRadius:s,bias:o,alpha:i,beta:l}=n;return{x:()=>fA(r,a,e,s,o,i,l)}}};function AA(e,t,n,r){return t.rank<n.rank&&(t=du(t,oc(t.shape,r))),e.rank<n.rank&&(e=du(e,oc(e.shape,r))),{x:()=>zl(e,zo(Ku(n,t),e.dtype))}}var gA={kernelName:$n,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:a}=r,s=t[0],o=AA(e,t[1],s,ye(a,s.shape));return{x:()=>o.x()}}},yA={kernelName:Fn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>zl(e,zo(Rc(n,r),"float32")),b:()=>zl(e,zo(Oc(n,r),"float32"))}}};var xA=Ls({maxPool3dGrad_:function(e,t,n,r,a,s,o){const i=Ds(e,"dy","maxPool3dGrad"),l=Ds(t,"input","maxPool3dGrad"),u=Ds(n,"output","maxPool3dGrad");let c=i,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=du(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=du(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=du(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),ae(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),ae(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),ae(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),cu("maxPool3dGrad",s,o);const f={dy:c,input:d,output:h},m={filterSize:r,strides:a,pad:s,dimRoundingMode:o},A=Is.runKernel(Pn,f,m);return p?du(A,[A.shape[1],A.shape[2],A.shape[3],A.shape[4]]):A}}),bA={kernelName:zn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=n;return{x:()=>xA(e,r,a,s,o,i,l)}}};var vA=Ls({maxPoolGrad_:function(e,t,n,r,a,s,o){const i=Ds(e,"dy","maxPoolGrad"),l=Ds(t,"input","maxPoolGrad"),u=Ds(n,"output","maxPoolGrad");ae(l.rank===i.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${i.rank})`)),ae(4===i.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`)),ae(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),cu("maxPoolGrad",s,o);const c={dy:i,input:l,output:u},d={filterSize:r,strides:a,pad:s,dimRoundingMode:o};return Is.runKernel(Dn,c,d)}}),wA={kernelName:tr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>Au(e,s,r.shape)}}};function kA(e,t,n){const r=e.shape.length,a=r-n.length,s=ff.getAxesPermutation(n,r);let o=e;null!=s&&(o=$i(e,s));const i=o.shape.slice(),l=i.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);i.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const a=du(t,r),s=Uu(e,n,!0,!1),o=Uu(e,n,!0,!0),i=zl(s,o);return zl(a,i)}(o.reshape(i),t,a);if(u=u.reshape(o.shape),null!=s){const e=ff.getUndoAxesPermutation(s);u=$i(u,e)}return u}var SA={kernelName:_r,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>xu(e,r,a)}}},IA={kernelName:Mr,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>fu(e,r)}}};var CA=[mm,Am,gm,ym,xm,bm,vm,wm,km,Sm,Im,Cm,Nm,Rm,_m,Mm,$m,Fm,Om,Dm,zm,Pm,Bm,Lm,Um,Vm,jm,Gm,Hm,qm,{kernelName:qt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Pi(n.shape,r.shape);return{a:()=>{const t=Dl(e,zo(r,"float32")),s=zi(n.shape,a);return s.length>0?du(gc(t,s),n.shape):t},b:()=>{let t=zl(e,zo(n,"float32"));const s=zi(r.shape,a);s.length>0&&(t=du(gc(t,s),r.shape));const o=Ac(r);return _i(Dl(t,zo(o,"float32")))}}}},Xm,Km,Zm,Ym,Jm,eA,Qm,tA,nA,sA,oA,iA,lA,uA,cA,dA,hA,pA,mA,gA,gA,yA,bA,{kernelName:On,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:s,strides:o,pad:i}=n;return{x:()=>vA(e,r,a,s,o,i)}}},{kernelName:Bn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n,s=ye(a,r.shape),o=le(sc(r.shape,s)[1]);return{x:()=>{const t=r.shape.slice();s.forEach((e=>{t[e]=1}));const n=du(e,t);return Dl(zl(n,hd(r.shape,"float32")),o)}}}},{kernelName:Wn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:a}=r,[s,o]=t,i=AA(e,o,s,ye(a,s.shape));return{x:()=>i.x()}}},{kernelName:Un,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>zl(e,zo(Dc(n,r),"float32")),b:()=>zl(e,zo(Tc(n,r),"float32"))}}},{kernelName:Vn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>Au(e,s,r.shape)}}},{kernelName:jn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Pi(n.shape,r.shape);return{a:()=>{const t=zi(n.shape,a);return t.length>0?du(gc(e,t),n.shape):e},b:()=>{const t=zl(e,_i(Ec(Dl(n,r)))),s=zi(r.shape,a);return s.length>0?du(gc(t,s),r.shape):t}}}},{kernelName:Hn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Pi(n.shape,r.shape);return{a:()=>{const t=zl(e,zo(r,"float32")),s=zi(n.shape,a);return s.length>0?du(gc(t,s),n.shape):t},b:()=>{const t=zl(e,zo(n,"float32")),s=zi(r.shape,a);return s.length>0?du(gc(t,s),r.shape):t}}}},{kernelName:qn,gradFunc:e=>({x:()=>_i(e)})},{kernelName:Qn,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>dd(n.shape,"float32")}}},{kernelName:Jn,gradFunc:e=>({x:()=>Yu(e)})},{kernelName:er,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return Eh(e,r).map((e=>()=>e))}},wA,wA,{kernelName:rr,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,a]=t,s=n,o=r,i=Pi(s.shape,o.shape);return{a:()=>{const t=zo(o,"float32");let n=zl(e,zl(t,pc(s,Zc(t,fc(1)))));const r=zi(s.shape,i);return r.length>0&&(n=gc(n,r)),du(n,s.shape)},b:()=>{const t=Tc(s,0),n=Zu(t,Lc(s),Yu(s));let r=zl(e,zl(a,n));const l=zi(o.shape,i);return l.length>0&&(r=gc(r,l)),du(r,o.shape)}}}},{kernelName:ar,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,a=Tc(n,0);return{x:()=>Zu(a,e,zl(e,r)),alpha:()=>{let t=Zu(a,Yu(e),zl(e,n));const s=zi(r.shape,e.shape);return s.length>0&&(t=gc(t,s)),du(t,r.shape)}}}},{kernelName:sr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;let s=[];return s=null==a?r.shape.map(((e,t)=>t)):"number"==typeof a?[a]:a,{x:()=>kA(r,e,s)}}},{kernelName:lr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dl(e,_i(Ac(n)))}}},{kernelName:mr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=zl(Dc(n,6),mh(n));return{x:()=>zl(e,zo(r,"float32"))}}},{kernelName:ur,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(e,zo(mh(n),"float32"))}}},{kernelName:cr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>du(e,n.shape)}}},{kernelName:pr,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>Is.runKernel(fr,a,n)}}},{kernelName:dr,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>Is.runKernel(hr,a,n)}}},{kernelName:Ar,gradFunc:(e,t,n)=>{const{dims:r}=n,a=ye(r,e.shape);return{x:()=>Vd(e,a)}}},{kernelName:gr,gradFunc:e=>({x:()=>Yu(e)})},{kernelName:yr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_i(Dl(e,zl(pc(n,1.5),2)))}}},{kernelName:vr,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>zo(Yu(n),"float32"),t:()=>zl(e,zo(n,e.dtype)),e:()=>zl(e,zo(ed(n),e.dtype))}}},{kernelName:wr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Tc(n,fc(0)),r=fc(If),a=fc(Cf),s=zl(e,a),o=zl(zl(e,r),vc(zo(n,"float32")));return Zu(t,s,o)}}}},{kernelName:Er,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(e,zl(n,Zc(fc(1),n)))}}},{kernelName:Cr,gradFunc:e=>({x:()=>Yu(e)})},{kernelName:Sr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(Bu(zo(n,"float32")),e)}}},{kernelName:Ir,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(Wu(zo(n,"float32")),e)}}},{kernelName:kr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:a,size:s}=n,o=r.shape,[i,l]=fl(r,a,s),u=[];for(let t=0;t<e.rank;t++)u.push([i[t],o[t]-i[t]-l[t]]);return{x:()=>kd(e,u)}}},{kernelName:$r,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:a}=n,s=zl(e,r);return{logits:()=>Zc(s,zl(gc(s,[a],true),r))}}},{kernelName:Nr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(e,mu(n))}}},SA,SA,IA,IA,{kernelName:Tr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dl(e,zl(mc(zo(n,"float32")),2))}}},{kernelName:Lr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=fc(2);return{a:()=>zl(e,zl(a,Zc(n,r))),b:()=>zl(e,zl(a,Zc(r,n)))}}},{kernelName:Br,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(e,zl(zo(n,"float32"),2))}}},{kernelName:ra,gradFunc:e=>({x:()=>Yu(e)})},{kernelName:Gr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Pi(n.shape,r.shape);return{a:()=>{let t=e;const r=zi(n.shape,a);return r.length>0&&(t=gc(t,r)),du(t,n.shape)},b:()=>{let t=e;const n=zi(r.shape,a);return n.length>0&&(t=gc(t,n)),du(_i(t),r.shape)}}}},{kernelName:Rr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,a=r.shape.slice(),{axis:s}=n;ye(s,r.shape).forEach((e=>{a[e]=1}));const o=du(e,a),i=zl(o,hd(r.shape,"float32"));return{x:()=>i}}},{kernelName:Hr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dl(e,Ac(Bu(n)))}}},{kernelName:qr,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>zl(Zc(fc(1),Ac(n)),e)}}},{kernelName:Xr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:a}=n;return{x:()=>{let t=Yu(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=Fl(t,Au(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=Fl(t,Au(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)t=Fl(t,Au(e,[n*r.shape[0],s*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let o=0;o<a[2];++o)for(let i=0;i<a[3];++i)t=Fl(t,Au(e,[n*r.shape[0],s*r.shape[1],o*r.shape[2],i*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},{kernelName:Yr,gradFunc:(e,t,n)=>{const r=n,{perm:a}=r,s=uc(a);return{x:()=>$i(e,s)}}},{kernelName:Qr,gradFunc:(e,t,n)=>{const r=n,{axis:a}=r;return{value:()=>fh(e,a)}}},{kernelName:ea,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=ud(t,Yu(t)),r=Nc(e,n);let a=Rc(t,fc(0,"int32"));const s=r.rank-a.rank;for(let e=0;e<s;++e)a=wc(a,e+1);a=Qc(a,hd(r.shape,"bool"));const o=Yu(r);return Zu(a,r,o)}(e,n)}}},{kernelName:na,gradFunc:e=>({x:()=>Yu(e)})}];for(const e of CA)ga(e);es().prototype.abs=function(){return this.throwIfDisposed(),Pl(this)},es().prototype.acos=function(){return this.throwIfDisposed(),Ll(this)},es().prototype.acosh=function(){return this.throwIfDisposed(),Bl(this)},es().prototype.add=function(e){return this.throwIfDisposed(),Fl(this,e)},es().prototype.all=function(e,t){return this.throwIfDisposed(),Ul(this,e,t)},es().prototype.any=function(e,t){return this.throwIfDisposed(),Vl(this,e,t)},es().prototype.argMax=function(e){return this.throwIfDisposed(),jl(this,e)},es().prototype.argMin=function(e){return this.throwIfDisposed(),Gl(this,e)},es().prototype.asScalar=function(){return this.throwIfDisposed(),ae(1===this.size,(()=>"The array must have only 1 element.")),du(this,[])},es().prototype.asType=function(e){return this.throwIfDisposed(),zo(this,e)},es().prototype.as1D=function(){return this.throwIfDisposed(),du(this,[this.size])},es().prototype.as2D=function(e,t){return this.throwIfDisposed(),du(this,[e,t])},es().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),du(this,[e,t,n])},es().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),du(this,[e,t,n,r])},es().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),du(this,[e,t,n,r,a])},es().prototype.asin=function(){return this.throwIfDisposed(),Hl(this)},es().prototype.asinh=function(){return this.throwIfDisposed(),ql(this)},es().prototype.atan=function(){return this.throwIfDisposed(),Xl(this)},es().prototype.atan2=function(e){return this.throwIfDisposed(),Kl(this,e)},es().prototype.atanh=function(){return this.throwIfDisposed(),Zl(this)},es().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),hu(this,e,t,n,r)},es().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),xu(this,e,t)},es().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),bu(this,e,t,n,r,a)},es().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Cu(this,e)},es().prototype.cast=function(e){return this.throwIfDisposed(),zo(this,e)},es().prototype.ceil=function(){return this.throwIfDisposed(),Eu(this)},es().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Nu(this,e,t)},es().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Qa&&(e=[e]),fu([this,...e],t)},es().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Fu(this,e,t,n,r,a,s)},es().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),Du(this,e,t,n,r,a)},es().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),$u(this,e,t,n,r,a,s)},es().prototype.cos=function(){return this.throwIfDisposed(),Bu(this)},es().prototype.cosh=function(){return this.throwIfDisposed(),Wu(this)},es().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Uu(this,e,t,n)},es().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Vu(this,e,t,n)},es().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Gu(this,e,t)},es().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Hu(this,e,t,n,r,a,s)},es().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),Xu(this,e,t,n,r,a)},es().prototype.divNoNan=function(e){return this.throwIfDisposed(),Ju(this,e)},es().prototype.div=function(e){return this.throwIfDisposed(),Dl(this,e)},es().prototype.dot=function(e){return this.throwIfDisposed(),Qu(this,e)},es().prototype.elu=function(){return this.throwIfDisposed(),tc(this)},es().prototype.equal=function(e){return this.throwIfDisposed(),Ku(this,e)},es().prototype.erf=function(){return this.throwIfDisposed(),nc(this)},es().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),bc(this,e,t)},es().prototype.exp=function(){return this.throwIfDisposed(),vc(this)},es().prototype.expandDims=function(e){return this.throwIfDisposed(),wc(this,e)},es().prototype.expm1=function(){return this.throwIfDisposed(),kc(this)},es().prototype.fft=function(){return this.throwIfDisposed(),ih(this)},es().prototype.flatten=function(){return this.throwIfDisposed(),du(this,[this.size])},es().prototype.floor=function(){return this.throwIfDisposed(),Ec(this)},es().prototype.floorDiv=function(e){return this.throwIfDisposed(),Ol(this,e)},es().prototype.gather=function(e,t){return this.throwIfDisposed(),Nc(this,e,t)},es().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Rc(this,e)},es().prototype.greater=function(e){return this.throwIfDisposed(),Tc(this,e)},es().prototype.ifft=function(){return this.throwIfDisposed(),lh(this)},es().prototype.irfft=function(){return this.throwIfDisposed(),uh(this)},es().prototype.isFinite=function(){return this.throwIfDisposed(),_c(this)},es().prototype.isInf=function(){return this.throwIfDisposed(),Mc(this)},es().prototype.isNaN=function(){return this.throwIfDisposed(),$c(this)},es().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Fc(this,e)},es().prototype.lessEqual=function(e){return this.throwIfDisposed(),Dc(this,e)},es().prototype.less=function(e){return this.throwIfDisposed(),Oc(this,e)},es().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Pc(this,e,t,n,r)},es().prototype.logSigmoid=function(){return this.throwIfDisposed(),Kc(this)},es().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Yc(this,e)},es().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Jc(this,e,t)},es().prototype.log=function(){return this.throwIfDisposed(),Lc(this)},es().prototype.log1p=function(){return this.throwIfDisposed(),Bc(this)},es().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Qc(this,e)},es().prototype.logicalNot=function(){return this.throwIfDisposed(),ed(this)},es().prototype.logicalOr=function(e){return this.throwIfDisposed(),td(this,e)},es().prototype.logicalXor=function(e){return this.throwIfDisposed(),nd(this,e)},es().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),ii(this,e,t,n)},es().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),od(this,e,t,n,r)},es().prototype.max=function(e,t){return this.throwIfDisposed(),dc(this,e,t)},es().prototype.maximum=function(e){return this.throwIfDisposed(),ud(this,e)},es().prototype.mean=function(e,t){return this.throwIfDisposed(),cd(this,e,t)},es().prototype.min=function(e,t){return this.throwIfDisposed(),hc(this,e,t)},es().prototype.minimum=function(e){return this.throwIfDisposed(),fd(this,e)},es().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),md(this,e,t)},es().prototype.mod=function(e){return this.throwIfDisposed(),Ad(this,e)},es().prototype.mul=function(e){return this.throwIfDisposed(),zl(this,e)},es().prototype.neg=function(){return this.throwIfDisposed(),_i(this)},es().prototype.norm=function(e,t,n){return this.throwIfDisposed(),xc(this,e,t,n)},es().prototype.notEqual=function(e){return this.throwIfDisposed(),bd(this,e)},es().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),li(this,e,t,n)},es().prototype.onesLike=function(){return this.throwIfDisposed(),vd(this)},es().prototype.pad=function(e,t){return this.throwIfDisposed(),kd(this,e,t)},es().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),Td(this,e,t,n,r,a,s)},es().prototype.pow=function(e){return this.throwIfDisposed(),pc(this,e)},es().prototype.prelu=function(e){return this.throwIfDisposed(),Rd(this,e)},es().prototype.prod=function(e,t){return this.throwIfDisposed(),_d(this,e,t)},es().prototype.reciprocal=function(){return this.throwIfDisposed(),Bd(this)},es().prototype.relu=function(){return this.throwIfDisposed(),Wd(this)},es().prototype.relu6=function(){return this.throwIfDisposed(),Ud(this)},es().prototype.reshapeAs=function(e){return this.throwIfDisposed(),du(this,e.shape)},es().prototype.reshape=function(e){return this.throwIfDisposed(),du(this,e)},es().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),wp(this,e,t,n)},es().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),kp(this,e,t,n)},es().prototype.reverse=function(e){return this.throwIfDisposed(),Vd(this,e)},es().prototype.rfft=function(){return this.throwIfDisposed(),dh(this)},es().prototype.round=function(){return this.throwIfDisposed(),Xd(this)},es().prototype.rsqrt=function(){return this.throwIfDisposed(),Kd(this)},es().prototype.selu=function(){return this.throwIfDisposed(),Zd(this)},es().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Yd(this,e,t,n,r,a,s)},es().prototype.sigmoid=function(){return this.throwIfDisposed(),mu(this)},es().prototype.sign=function(){return this.throwIfDisposed(),Qd(this)},es().prototype.sin=function(){return this.throwIfDisposed(),eh(this)},es().prototype.sinh=function(){return this.throwIfDisposed(),th(this)},es().prototype.slice=function(e,t){return this.throwIfDisposed(),Au(this,e,t)},es().prototype.softmax=function(e){return this.throwIfDisposed(),oh(this,e)},es().prototype.softplus=function(){return this.throwIfDisposed(),Xc(this)},es().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Nd(this,e,t)},es().prototype.split=function(e,t){return this.throwIfDisposed(),ch(this,e,t)},es().prototype.sqrt=function(){return this.throwIfDisposed(),mc(this)},es().prototype.square=function(){return this.throwIfDisposed(),Ac(this)},es().prototype.squaredDifference=function(e){return this.throwIfDisposed(),hh(this,e)},es().prototype.squeeze=function(e){return this.throwIfDisposed(),ph(this,e)},es().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Qa?[this,e]:[this,...e];return fh(n,t)},es().prototype.step=function(e){return this.throwIfDisposed(),mh(this,e)},es().prototype.stridedSlice=function(e,t,n,r,a,s,o,i){return this.throwIfDisposed(),Ah(this,e,t,n,r,a,s,o,i)},es().prototype.sub=function(e){return this.throwIfDisposed(),Zc(this,e)},es().prototype.sum=function(e,t){return this.throwIfDisposed(),gc(this,e,t)},es().prototype.tan=function(){return this.throwIfDisposed(),gh(this)},es().prototype.tanh=function(){return this.throwIfDisposed(),gu(this)},es().prototype.tile=function(e){return this.throwIfDisposed(),Sc(this,e)},es().prototype.toBool=function(){return this.throwIfDisposed(),zo(this,"bool")},es().prototype.toFloat=function(){return this.throwIfDisposed(),zo(this,"float32")},es().prototype.toInt=function(){return this.throwIfDisposed(),zo(this,"int32")},es().prototype.topk=function(e,t){return this.throwIfDisposed(),kh(this,e,t)},es().prototype.transpose=function(e){return this.throwIfDisposed(),$i(this,e)},es().prototype.unique=function(e){return this.throwIfDisposed(),Ih(this,e)},es().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Ch(this,e,t)},es().prototype.unstack=function(e){return this.throwIfDisposed(),Eh(this,e)},es().prototype.where=function(e,t){return this.throwIfDisposed(),Zu(e,this,t)},es().prototype.zerosLike=function(){return this.throwIfDisposed(),Yu(this)};var EA=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,EA.prototype)}},NA=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,NA.prototype)}},TA=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,TA.prototype)}},RA=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,RA.prototype)}},_A=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,_A.prototype)}},MA=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function $A(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function FA(e,t){if(!e)throw new _A(t)}function OA(e,t){let n=0;for(const r of e)r===t&&n++;return n}function DA(e){return 1===e.length?e[0]:e}function zA(e){return Array.isArray(e)?e:[e]}function PA(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function LA(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var BA={};function WA(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function UA(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>UA(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?UA(t):e[n]=t.value)}}}function VA(e,t={},n={},r="object",a=!1){if("string"==typeof e){const a=e;let s;if(a in n)s=n[a];else if(a in BA)s=BA[a];else if(s=t[a],null==s)throw new TA(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=e;if(null==s.className||null==s.config)throw new TA(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const o=s.className;let i,l;if(o in n?[i,l]=n[o]:o in BA?[i,l]=BA.className:o in t&&([i,l]=t[o]),null==i)throw new TA(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const t of Object.keys(BA))e[t]=BA[t];for(const t of Object.keys(n))e[t]=n[t];s.config.customObjects=e;const t=Object.assign({},BA);for(const e of Object.keys(n))BA[e]=n[e];UA(s.config);const r=l(i,s.config,n,a);return BA=Object.assign({},t),r}{const e=Object.assign({},BA);for(const e of Object.keys(n))BA[e]=n[e];const t=new i(s.config);return BA=Object.assign({},e),t}}}function jA(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function GA(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function HA(e){if(null==e)throw new TA(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function qA(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new TA(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function XA(e,t,n=0,r=1/0){return FA(n>=0),FA(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function KA(e,t){Array.isArray(e)?(wa.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>KA(e,`element ${n+1} of ${t}`)))):wa.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${ZA(e)}.`))}function ZA(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>ZA(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function YA(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var JA=0;function QA(){return JA++}var eg={};function tg(e=""){return e in eg||(eg[e]=0),eg[e]+=1,e+eg[e].toString()}var ng=["channelsFirst","channelsLast"],rg=["nearest","bilinear"],ag=["valid","same","causal"],sg=["max","avg"],og=["sum","mul","concat","ave"],ig=new Map;function lg(e){qA(ng,"DataFormat",e)}function ug(e){qA(ag,"PaddingMode",e)}function cg(e){qA(sg,"PoolMode",e)}var dg=[];function hg(e,t){dg.push(e);try{const e=t();return dg.pop(),e}catch(e){throw dg.pop(),e}}function pg(e){if(!gg(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===dg.length?"":dg.join("/")+"/")+e}function fg(e){if(!gg(e))throw new Error("Not a valid tensor name: '"+e+"'");ig.has(e)||ig.set(e,0);const t=ig.get(e);if(ig.set(e,ig.get(e)+1),t>0){const n=`${e}_${t}`;return ig.set(n,1),n}return e}var mg,Ag=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function gg(e){return!!e.match(Ag)}function yg(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function xg(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function bg(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function vg(e,t){if(t<e)throw new TA(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}function wg(){return null==mg&&(mg=Ni().epsilon()),mg}function kg(e,t){return zo(e,t)}function Sg(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),du(e,n)}function Ig(e,t,n){return gi((()=>{switch(e.rank){case 1:return nh(e,t,n);case 2:return rh(e,[t,0],[n,e.shape[1]]);case 3:return ah(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return sh(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Au(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Au(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new TA(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Cg(e,t,n){return gi((()=>{switch(e.rank){case 1:return nh(e,t,n);case 2:return rh(e,[0,t],[e.shape[0],n]);case 3:return ah(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return sh(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new TA(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Eg(e,t,n,r){return gi((()=>{switch(e.rank){case 1:return nh(e,t,n);case 2:switch(r){case 1:return Ig(e,t,n);case 2:return Cg(e,t,n);default:throw new TA(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ig(e,t,n);case 2:return ah(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Cg(e,t,n);default:throw new TA(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ig(e,t,n);case 2:return sh(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return sh(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Cg(e,t,n);default:throw new TA(`The axis is not within the rank of the tensor ${r}`)}default:throw new TA(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Ng(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),fu(e,t)}function Tg(e,t){switch(e.rank){case 1:return Tu([e,t]);case 2:return Ru([e,t],0);case 3:return _u([e,t],0);case 4:return Mu([e,t],0);default:throw new TA(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Rg(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new TA(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Sc(e,t)}function _g(e,t=0,n=1,r,a){return Dd(e,t,n,r,a)}function Mg(e,t,n,r){if(e.rank<2||t.rank<2)throw new RA(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new RA(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){const a=!1,s=!1;return Wh.matMul({a:e,b:t,transposeA:a,transposeB:s,bias:r?Og(e.rank,r,"channelsLast"):null,activation:n})}{const a=e.shape.slice(),s=a.pop();e=du(e,[-1,s]);const o=t.shape.slice(),i=o.pop(),l=o.pop(),u=[...o,i],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=du($i(t,c),[l,-1]);const d=[...a,...u],h=!1,p=!1;return du(Wh.matMul({a:e,b:t,transposeA:h,transposeB:p,bias:r?Og(e.rank,r,"channelsLast"):null,activation:n}),d)}}function $g(e,t,n){return gi((()=>(t=Array.isArray(t)?yh(t,"int32"):zo(t,"int32"),Nc(e,t,n))))}function Fg(e){return zl(e,e)}function Og(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new TA(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?du(t,[1,r[0],1,1,1]):du(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?du(t,[1,1,1,1,r[0]]):du(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?du(t,[1,r[0],1,1]):du(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?du(t,[1,1,1,r[0]]):du(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?du(t,[1,r[0],1]):du(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?du(t,[1,1,r[0]]):du(t,[1].concat(r))}else if(e<3)return t;throw new TA(`Unsupported input rank by biasAdd: ${t.rank}`)}function Dg(e,t,n){return gi((()=>(null==n&&(n="channelsLast"),lg(n),Fl(e,Og(e.rank,t,n)))))}function zg(e,t,n,r){return gi((()=>zh(e,t,n,r)))}function Pg(e,t,n=!1){return n?e():t()}var Lg=["fanIn","fanOut","fanAvg"],Bg=["normal","uniform","truncatedNormal"];var Wg=class extends gl.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Ug=class extends Wg{apply(e,t){return dd(e,t)}};Ug.className="Zeros",gl.registerClass(Ug);var Vg=class extends Wg{apply(e,t){return hd(e,t)}};Vg.className="Ones",gl.registerClass(Vg);var jg=class extends Wg{constructor(e){if(super(),"object"!=typeof e)throw new TA(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new TA(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return gi((()=>zl(fc(this.value),hd(e,t))))}getConfig(){return{value:this.value}}};jg.className="Constant",gl.registerClass(jg);var Gg=class extends Wg{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Pd(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Gg.className="RandomUniform",gl.registerClass(Gg);var Hg=class extends Wg{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new RA(`randomNormal does not support dType ${t}.`);return _g(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Hg.className="RandomNormal",gl.registerClass(Hg);var qg=class extends Wg{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new RA(`truncatedNormal does not support dType ${t}.`);return Sh(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};qg.className="TruncatedNormal",gl.registerClass(qg);var Xg=class extends Wg{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return gi((()=>{if(2!==e.length||e[0]!==e[1])throw new TA("Identity matrix initializer can only be used for 2D square matrices.");return zl(this.gain,Ic(e[0]))}))}getConfig(){return{gain:this.gain}}};Xg.className="Identity",gl.registerClass(Xg);var Kg=class extends Wg{constructor(e){if(super(),e.scale<0)throw new TA(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,qA(Lg,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){qA(Bg,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(lg(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=yg(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=yg(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=yg(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new RA(`${this.getClassName()} does not support dType ${t}.`);return Sh(e,0,n,t,this.seed)}{const n=Math.sqrt(3*s);return Pd(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Kg.className="VarianceScaling",gl.registerClass(Kg);var Zg=class extends Kg{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Kg.className}};Zg.className="GlorotUniform",gl.registerClass(Zg);var Yg=class extends Kg{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Kg.className}};Yg.className="GlorotNormal",gl.registerClass(Yg);var Jg=class extends Kg{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Kg.className}};Jg.className="HeNormal",gl.registerClass(Jg);var Qg=class extends Kg{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Kg.className}};Qg.className="HeUniform",gl.registerClass(Qg);var ey=class extends Kg{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Kg.className}};ey.className="LeCunNormal",gl.registerClass(ey);var ty=class extends Kg{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Kg.className}};ty.className="LeCunNormal",gl.registerClass(ty);var ny=class extends Wg{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new RA("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return gi((()=>{if(e.length<2)throw new RA("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const t=_g(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=Yp.gramSchmidt(t);return e[0]>e[1]&&(n=$i(n)),zl(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}};ny.className="Orthogonal",gl.registerClass(ny);var ry={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function ay(e,t={}){return VA(e,gl.SerializationMap.getMap().classNameMap,t,"initializer")}function sy(e){return WA(e)}function oy(e){if("string"==typeof e){const t=e in ry?ry[e]:e;if("GlorotNormal"===t)return new Yg;if("GlorotUniform"===t)return new Zg;if("HeNormal"===t)return new Jg;if("HeUniform"===t)return new Qg;if("LeCunNormal"===t)return new ey;if("LeCunUniform"===t)return new ty;{const e={};return e.className=t,e.config={},ay(e)}}return e instanceof Wg?e:ay(e)}function iy(e){return Array.isArray(e)&&Array.isArray(e[0])}function ly(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function uy(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new TA(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function cy(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new TA(`Expected exactly 1 Shape; got ${e.length}`)}return e}function dy(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var hy="Variable",py=class{constructor(e,t="float32",n="Variable",r=!0,a=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=QA(),n=null==n?hy:n,this.originalName=pg(n),this.name=fg(this.originalName),this.trainable_=r,this.constraint=a,this.val=Th(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function fy(e){return e.map((e=>e.read()))}function my(e){e.forEach((e=>{e[0].write(e[1])}))}var Ay=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},gy=class{constructor(e,t,n,r,a,s,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=QA(),null!=s&&(this.originalName=pg(s),this.name=fg(this.originalName)),this.rank=t.length}},yy=0,xy=class{constructor(e,t){this.callArgs=t,this.id=yy++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},by=0,vy=class extends gl.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=by++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=PA(e)+"_"+tg(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new NA(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new TA(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return DA(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return DA(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new EA(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new EA(`Layer ${this.name} is not connected, no input to return.`);return DA(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new EA(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new EA(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return DA(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=zA(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=zA(this.inputSpec);if(e.length!==t.length)throw new TA(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){const r=e[n],a=t[n];if(null==a)continue;const s=r.rank;if(null!=a.ndim&&s!==a.ndim)throw new TA(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new TA(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new TA(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&r.dtype!==a.dtype)throw new TA(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){const e=r.shape;for(const t in a.axes){const r=Number(t),s=a.axes[t],o=r>=0?e[r]:e[e.length+r];if(null!=s&&-1===[s,null].indexOf(o))throw new TA(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${s} but got shape ${e}.`)}}if(null!=a.shape)for(let e=0;e<a.shape.length;++e){const t=a.shape[e],s=r.shape[e];if(null!=t&&null!=s&&t!==s)throw new TA(`Input ${n} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=zA(e);let r=!0;for(const e of n)if(!(e instanceof gy)){r=!1;break}let a=!0;for(const e of n)if(e instanceof gy){a=!1;break}if(r===a)throw new TA("Arguments to apply() must be all SymbolicTensors or all Tensors");return hg(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of zA(e))t.push(n.shape);this.build(DA(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);const a=zA(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=DA(s),null!=this.activityRegularizer)throw new RA("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=zA(e);const t=[];for(const n of e)t.push(n.shape);return DA(t)}(e),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new gy(s,n,this,zA(e),t,this.name,r))):new gy(s,r,this,zA(e),t,this.name),this.addInboundNode(e,a,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new RA("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new EA(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new EA(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new NA(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return dy(this.weights)}build(e){this.built=!0}getWeights(e=!1){return fy(e?this.trainableWeights:this.weights)}setWeights(e){gi((()=>{const t=this.weights;if(t.length!==e.length)throw new TA(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=fy(t);for(let a=0;a<r.length;++a){const s=r[a],o=t[a],i=e[a];if(!wa.arraysEqual(s.shape,i.shape))throw new TA(`Layer weight shape ${s.shape} not compatible with provided weight shape ${i.shape}`);n.push([o,i])}my(n)}))}addWeight(e,t,n,r,a,s,o,i){if(-1!==this._addedWeightNames.indexOf(e))throw new TA(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=i?i():oy("zeros"));const l=r.apply(t,n),u=new py(l,n,e,s,o);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=zA(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}addInboundNode(e,t,n,r,a,s,o=null){const i=zA(e);t=zA(t),n=zA(n),r=zA(r),a=ly(a),s=ly(s);const l=[],u=[],c=[];for(const e of i)l.push(e.sourceLayer),u.push(e.nodeIndex),c.push(e.tensorIndex);new xy({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},o);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function wy(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=wy(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}var ky=class extends vy{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:tg("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new TA("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new TA("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new TA("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new gy(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new xy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new TA(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function Sy(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new TA("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;null==n&&(n="float32");return new ky({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}ky.className="InputLayer",gl.registerClass(ky);var Iy=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Iy)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new TA(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return zo(t,e.dtype)}catch(n){throw new TA(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof gy){if(null==this.id2Value[e.id])throw new TA(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new TA(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof gy){if(null==this.id2Value[e.id])throw new TA(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new TA(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&yi(this.id2Mask)}},Cy=new MA,Ey=new MA;function Ny(e,t,n,r){const a=null!=n&&n.training,s=Array.isArray(e),o=s?e:[e],i=o.map((e=>e.name)),l=[],u=t.names();for(const e of i)-1!==u.indexOf(e)?l.push(t.getValue(e)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=i.join(",")+"|"+t.names().sort().join(",");let d,h=Cy.get(c);if(null==h){const e=function(e,t){wa.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const a=Ry(e[0],t);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of e){const{sorted:e,recipientMap:o}=Ry(s,t);for(const t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(const e in o)null==r[e]&&(r[e]=new Set),o[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:Ty(r)}}(o,t);h=e.sorted,d=e.recipientCounts,Cy.put(c,h),Ey.put(c,d)}d={},a||Object.assign(d,Ey.get(c));const p=new Iy(t);for(let e=0;e<h.length;++e){if(null!=r){const e=mi().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const s=h[e],o=s.sourceLayer;if(o instanceof ky)continue;const u=[],c=[],f=[];let m=!1;for(const e of s.inputs){const n=p.getValue(e),r=p.getMask(e);u.push(n),c.push(r),null!=r&&(m=!0),a||(d[e.name]--,0!==d[e.name]||t.hasKey(e)||-1!==i.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||f.push(n))}m&&((n=n||{}).mask=c[0]);const A=zA(o.apply(u,n));let g=null;o.supportsMasking&&(g=o.computeMask(u,c));const y=_y(s),x=Array.isArray(y)?y:[y];for(let e=0;e<x.length;++e){p.hasKey(x[e])||p.add(x[e],A[e],Array.isArray(g)?g[0]:g);const t=i.indexOf(x[e].name);-1!==t&&(l[t]=A[e])}a||yi(f)}return p.disposeMasks(),s?l:l[0]}function Ty(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Ry(e,t){const n=new Set,r=[],a={};for(const e of t.names())n.add(e);const s=[],o=[];for(s.push(e);s.length>0;){const e=s[s.length-1];if(n.has(e.name)){s.pop();continue}const t=o[o.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&o.pop();else{o.push(s.length-1);for(const t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),n.has(t.name)||s.push(t)}}return{sorted:r,recipientMap:a}}function _y(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}qe().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=Cy&&Cy.setMaxEntries(e),null!=Ey&&Ey.setMaxEntries(e)}));var My={};function $y(e,t){return gi((()=>mc(gc(zl(e,e),t,!0))))}S(My,{maxNorm:()=>Vy,minMaxNorm:()=>Hy,nonNeg:()=>Gy,unitNorm:()=>jy});var Fy=class extends gl.Serializable{getConfig(){return{}}},Oy=class extends Fy{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return gi((()=>{const t=$y(e,this.axis),n=Nu(t,0,this.maxValue);return zl(e,Dl(n,Fl(wg(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Oy.className="MaxNorm",gl.registerClass(Oy);var Dy=class extends Fy{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return gi((()=>Dl(e,Fl(wg(),$y(e,this.axis)))))}getConfig(){return{axis:this.axis}}};Dy.className="UnitNorm",gl.registerClass(Dy);var zy=class extends Fy{apply(e){return Wd(e)}};zy.className="NonNeg",gl.registerClass(zy);var Py=class extends Fy{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return gi((()=>{const t=$y(e,this.axis),n=Fl(zl(this.rate,Nu(t,this.minValue,this.maxValue)),zl(1-this.rate,t));return zl(e,Dl(n,Fl(wg(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Py.className="MinMaxNorm",gl.registerClass(Py);var Ly={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function By(e){return WA(e)}function Wy(e,t={}){return VA(e,gl.SerializationMap.getMap().classNameMap,t,"constraint")}function Uy(e){if(null==e)return null;if("string"==typeof e){return Wy({className:e in Ly?Ly[e]:e,config:{}})}return e instanceof Fy?e:Wy(e)}function Vy(e){return new Oy(e)}function jy(e){return new Dy(e)}function Gy(){return new zy}function Hy(e){return new Py(e)}var qy={};function Xy(){return new Ug}function Ky(){return new Vg}function Zy(e){return new jg(e)}function Yy(e){return new Gg(e)}function Jy(e){return new Hg(e)}function Qy(e){return new qg(e)}function ex(e){return new Xg(e)}function tx(e){return new Kg(e)}function nx(e){return new Zg(e)}function rx(e){return new Yg(e)}function ax(e){return new Jg(e)}function sx(e){return new Qg(e)}function ox(e){return new ey(e)}function ix(e){return new ty(e)}function lx(e){return new ny(e)}S(qy,{constant:()=>Zy,glorotNormal:()=>rx,glorotUniform:()=>nx,heNormal:()=>ax,heUniform:()=>sx,identity:()=>ex,leCunNormal:()=>ox,leCunUniform:()=>ix,ones:()=>Ky,orthogonal:()=>lx,randomNormal:()=>Jy,randomUniform:()=>Yy,truncatedNormal:()=>Qy,varianceScaling:()=>tx,zeros:()=>Xy});var ux,cx,dx={};async function hx(e){if(null==e)return;const t=[],n=[],r=[];for(const a in e){const s=e[a];if("number"!=typeof s){const e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){const a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];yi(r)}}function px(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}S(dx,{Layer:()=>vy,RNN:()=>Nv,RNNCell:()=>Tv,activation:()=>Zw,add:()=>sk,alphaDropout:()=>Kk,average:()=>ok,averagePooling1d:()=>mk,averagePooling2d:()=>yk,averagePooling3d:()=>vk,avgPool1d:()=>Ak,avgPool2d:()=>xk,avgPool3d:()=>wk,avgPooling1d:()=>gk,avgPooling2d:()=>bk,avgPooling3d:()=>kk,batchNormalization:()=>hk,bidirectional:()=>Wk,concatenate:()=>ik,conv1d:()=>Ww,conv2d:()=>Uw,conv2dTranspose:()=>Vw,conv3d:()=>jw,conv3dTranspose:()=>Gw,convLstm2d:()=>zk,convLstm2dCell:()=>Pk,cropping2D:()=>qw,dense:()=>Yw,depthwiseConv2d:()=>Kw,dot:()=>dk,dropout:()=>Jw,elu:()=>Ow,embedding:()=>ak,flatten:()=>ek,gaussianDropout:()=>Xk,gaussianNoise:()=>qk,globalAveragePooling1d:()=>Sk,globalAveragePooling2d:()=>Ik,globalMaxPool1d:()=>Vk,globalMaxPool2d:()=>jk,globalMaxPooling1d:()=>Ck,globalMaxPooling2d:()=>Ek,gru:()=>_k,gruCell:()=>Mk,input:()=>Tb,inputLayer:()=>Fw,layerNormalization:()=>pk,leakyReLU:()=>zw,lstm:()=>$k,lstmCell:()=>Fk,masking:()=>Zk,maxPool1d:()=>Gk,maxPool2d:()=>Hk,maxPooling1d:()=>Nk,maxPooling2d:()=>Tk,maxPooling3d:()=>Rk,maximum:()=>lk,minimum:()=>uk,multiply:()=>ck,permute:()=>rk,prelu:()=>Pw,reLU:()=>Dw,repeatVector:()=>tk,reshape:()=>nk,rnn:()=>Lk,separableConv2d:()=>Hw,simpleRNN:()=>Ok,simpleRNNCell:()=>Dk,softmax:()=>Lw,spatialDropout1d:()=>Qw,stackedRNNCells:()=>Bk,thresholdedReLU:()=>Bw,timeDistributed:()=>Uk,upSampling2d:()=>Xw,zeroPadding2d:()=>fk}),(cx=ux||(ux={}))[cx.SILENT=0]="SILENT",cx[cx.VERBOSE=1]="VERBOSE";var fx=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},mx=class{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}},Ax=class extends fx{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const e in t){const r=t[e];if("number"==typeof r)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;const a=gi((()=>Fl(this.totals[e],zl(r,n))));this.totals[e]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:gi((()=>{const n=zl(Dl(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),xi(t[e])})))}},gx=class extends fx{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const a=this.history[r];for(let s=0;s<a.length;++s)if("number"!=typeof a[s]){const o=a[s];e.push(o.data()),t.push(r),n.push(s)}}const r=await Promise.all(e);for(let e=0;e<r.length;++e){this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}}},yx=class extends fx{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||pf,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");wa.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():wa.now();return(...s)=>{const o=null!=n?n():wa.now();return o-a<t||(a=o,r=e(...s)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await hx(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await hx(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await hx(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await hx(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await hx(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):wa.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await hx(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await hx(e),await this.trainEnd(e))}};function xx(e,t){if(null==e&&(e={}),e instanceof fx)return[e];if(Array.isArray(e)&&e[0]instanceof fx)return e;return zA(e).map((e=>new yx(e,t)))}var bx=class{constructor(){}static registerCallbackConstructor(e,t){wa.assert(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),bx.checkForDuplicate(t),null==bx.constructors[e]&&(bx.constructors[e]=[]),bx.constructors[e].push(t)}static checkForDuplicate(e){for(const t in bx.constructors){bx.constructors[+t].forEach((t=>{if(t===e)throw new TA("Duplicate callback constructor.")}))}}static clear(){bx.constructors={}}static createCallbacks(e){const t=[];for(const n in bx.constructors){const r=+n;e>=r&&t.push(...bx.constructors[r])}return t.map((e=>new e))}};function vx(e,t,n,r,a,s,o,i,l){const u=new gx,c=[new Ax,...bx.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const d=new mx(c);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:o,verbose:t,doValidation:i,metrics:l}),{callbackList:d,history:u}}function wx(e,t={},n=!1){return VA(e,gl.SerializationMap.getMap().classNameMap,t,"layer",n)}function kx(e,t){return gi((()=>{"float32"!==e.dtype&&(e=zo(e,"float32"));const n=gc(Fg(e),t,!0),r=Cc(n.shape,wg()),a=mc(ud(n,r));return Dl(e,a)}))}function Sx(e,t){return gi((()=>cd(Fg(Zc(t,e)),-1)))}function Ix(e,t){return gi((()=>cd(Pl(Zc(t,e)),-1)))}function Cx(e,t){return gi((()=>{const n=Zc(e,t),r=Nu(Pl(e),wg(),Number.MAX_VALUE),a=Pl(Dl(n,r));return zl(100,cd(a,-1))}))}function Ex(e,t,n=!1){return gi((()=>{if(n)t=oh(t);else{const e=gc(t,t.shape.length-1,!0);t=Dl(t,e)}return t=Nu(t,wg(),1-wg()),_i(gc(zl(zo(e,"float32"),Lc(t)),t.shape.length-1))}))}function Nx(e,t,n=!1){return gi((()=>{const r=zo(Ec(function(e){const t=[yg(e.shape)];return du(e,t)}(e)),"int32"),a=(t=Nu(t,wg(),1-wg())).shape;return Ex(du(li(r,a[a.length-1]),a),t,n)}))}function Tx(e,t){return gi((()=>{let n;return n=Nu(t,wg(),1-wg()),n=Lc(Dl(n,Zc(1,n))),cd(function(e,t){if(!wa.arraysEqual(e.shape,t.shape))throw new TA(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return gi((()=>{const n=Wd(t),r=_i(Pl(t));return Fl(Zc(n,zl(t,e)),Bc(vc(r)))}))}(e,n),-1)}))}function Rx(e,t){return gi((()=>{const n=kx(e,-1),r=kx(t,-1),a=zl(n,r);return _i(gc(a,-1))}))}bx.constructors={};var _x={meanSquaredError:Sx,meanAbsoluteError:Ix,meanAbsolutePercentageError:Cx,meanSquaredLogarithmicError:function(e,t){return gi((()=>{const n=Nu(t,wg(),Number.MAX_VALUE),r=Lc(Fl(1,n)),a=Nu(e,wg(),Number.MAX_VALUE),s=Lc(Fl(1,a));return cd(Fg(Zc(r,s)),-1)}))},squaredHinge:function(e,t){return gi((()=>{const n=ud(0,Zc(1,zl(e,t)));return cd(Fg(n),-1)}))},hinge:function(e,t){return gi((()=>{const n=ud(0,Zc(1,zl(e,t)));return cd(n,-1)}))},categoricalHinge:function(e,t){return gi((()=>{const n=gc(zl(e,t),-1),r=dc(zl(Zc(1,e),t),-1);return ud(0,Fl(1,Zc(r,n)))}))},logcosh:function(e,t){return gi((()=>{const n=Math.log(2),r=Zc(t,e),a=Zc(Fl(r,Xc(zl(-2,r))),n);return cd(a,-1)}))},categoricalCrossentropy:Ex,sparseCategoricalCrossentropy:Nx,binaryCrossentropy:Tx,kullbackLeiblerDivergence:function(e,t){return gi((()=>{const n=Nu(e,wg(),1),r=Nu(t,wg(),1);return gc(zl(e,Lc(Dl(n,r))),-1)}))},poisson:function(e,t){return gi((()=>{const n=Lc(Fl(wg(),t));return cd(Zc(t,zl(e,n)),-1)}))},cosineProximity:Rx};function Mx(e){if("string"==typeof e){if(e in _x)return _x[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new TA(t)}return e}function $x(e,t){return gi((()=>{const n=zl(.5,vd(t)),r=kg(Tc(t,n),e.dtype);return cd(Ku(e,r),-1)}))}function Fx(e,t){return gi((()=>kg(Ku(jl(e,-1),jl(t,-1)),"float32")))}function Ox(e,t){return gi((()=>zo(gc(Qc(Ku(e,1),Ku(t,1))),"float32")))}function Dx(e,t){return gi((()=>{const n=Ox(e,t),r=function(e,t){return gi((()=>zo(gc(Qc(Ku(e,0),Ku(t,1))),"float32")))}(e,t),a=Fl(n,r);return zo(Zu(Tc(a,0),Dl(n,a),0),"float32")}))}function zx(e,t){return gi((()=>{const n=Ox(e,t),r=function(e,t){return gi((()=>zo(gc(Qc(Ku(e,1),Ku(t,0))),"float32")))}(e,t),a=Fl(n,r);return zo(Zu(Tc(a,0),Dl(n,a),0),"float32")}))}function Px(e,t){return Tx(e,t)}function Lx(e,t){return e.rank===t.rank&&(e=ph(e,[e.rank-1])),(t=jl(t,-1)).dtype!==e.dtype&&(t=zo(t,e.dtype)),zo(Ku(e,t),"float32")}var Bx=Ex,Wx=Nx,Ux={binaryAccuracy:$x,categoricalAccuracy:Fx,precision:Dx,categoricalCrossentropy:Bx,sparseCategoricalCrossentropy:Wx,mse:Sx,MSE:Sx,mae:Ix,MAE:Ix,mape:Cx,MAPE:Cx,cosine:Rx};function Vx(e){if("string"==typeof e&&e in Ux)return Ux[e];if("string"!=typeof e&&null!=e)return e;throw new TA(`Unknown metric ${e}`)}function jx(e){if(FA(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(_x))if(_x[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(Ux))if(Ux[n]===e){t=n;break}return void 0!==t?t:e.name}}var Gx=1048576;function Hx(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!qx(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>Gx&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function qx(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!qx(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!qx(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function Xx(e,t,n,r=console.log){const a=function(e){let t=!0;const n=[],r=[];for(const t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(const e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(const n of e.layers){let e=!1;for(const a of n.inboundNodes)if(-1!==r.indexOf(a)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!a){s.push("Receives inputs"),o=[];for(const t in e.nodesByDepth)o.push(...e.nodesByDepth[t])}r("_".repeat(t)),Kx(s,n,r),r("=".repeat(t));const i=e.layers;for(let e=0;e<i.length;++e)a?Zx(i[e],n,r):Yx(i[e],n,o,r),r((e===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?dy(e.collectedTrainableWeights):dy(e.trainableWeights);return t}(e),u=dy(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function Kx(e,t,n=console.log){let r="";for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=e[n],r=r.slice(0,t[n]),r+=" ".repeat(t[n]-r.length);n(r)}function Zx(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}Kx([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function Yx(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(e){a="multiple"}const o=[];for(const t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){const n=t.inboundLayers[e].name,r=t.nodeIndices[e],a=t.tensorIndices[e];o.push(`${n}[${r}][${a}]`)}const i=e.name,l=e.getClassName(),u=0===o.length?"":o[0];Kx([`${i} (${l})`,s,a,e.countParams().toString(),u],t,r);for(let e=1;e<o.length;++e)Kx(["","","","",o[e]],t,r)}function Jx(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function Qx(e,t){if(null===e)return null;if("string"==typeof e)return LA(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];Jx(t,a,r)?n.push(r):n.push(Qx(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=LA(n);t[e]=Qx(r,e)}}return t}}function eb(e,t){if(null==e)return null;if("string"==typeof e)return PA(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];Jx(t,a,r)?n.push(r):n.push(eb(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],a=PA(n);t[a]="name"!==n&&"className"!==n||"string"!=typeof r?eb(r,n):r}return t}}var tb="3.19.0",nb=class extends vy{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=tg(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],GA(this.inputs).length!==this.inputs.length)throw new TA(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);GA(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;FA(0===n,"input layer has >1 nodes"),FA(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof ky))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},a={},s={},o=[],i=(e,t,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[a];if(-1!==n.indexOf(u))throw new NA(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(nb.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let e=0;e<c;e++){const r=u.inputTensors[e],a=u.inboundLayers[e],s=u.nodeIndices[e],o=u.tensorIndices[e];i(r,t,n,a,s,o)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);o.push(u)},l=[],u=[];for(const e of this.outputs)i(e,l,u);const c=o.slice().reverse();for(const e of c){n[e.id]=e,e.id in t||(t[e.id]=0);let s=t[e.id];const o=null==r[e.outboundLayer.id]?0:r[e.outboundLayer.id];s=Math.max(s,o),r[e.outboundLayer.id]=s,a[e.outboundLayer.id]=e.outboundLayer,t[e.id]=s;for(let r=0;r<e.inboundLayers.length;r++){const a=e.inboundLayers[r],o=e.nodeIndices[r],i=a.inboundNodes[o],l=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(s+1,l),n[i.id]=i}}const d={};for(const e in t){const r=t[e];r in d||(d[r]=[]),d[r].push(n[e])}const h={};for(const e in r){const t=r[e];t in h||(h[t]=[]),h[t].push(a[e])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(jA);this.layers=[];for(const e of p){const t=h[e];t.sort(((e,t)=>{const n=s[e.id],r=s[t.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof nb&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(jA);const f=this.inputs.slice(),m=[];for(const e of p)for(const t of d[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new NA(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=d;const A=this.layers.map((e=>e.name));for(const e of A){const t=A.filter((t=>t===e)).length;if(1!==t)throw new NA(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(A))}this.outboundNodes=[],this.inboundNodes=[],new xy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new TA("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;for(const e of this.layers)for(const t of e.weights){if(null!=n[t.originalName])throw new TA(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,r++}const a=[];for(const r in e){let s=r;if(null==n[r]){const e=r.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])a.push([n[s],e[r]]);else if(t)throw new TA(`Provided weight data has no target variable: ${r}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new TA(`${e.length} of ${r} weights are not set: ${e}`)}my(a)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${tb}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=eb(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return gi((()=>{e=zA(e);const n=new Iy;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Ny(this.outputs,n,t)}))}computeMask(e,t){return gi((()=>{let n;return e=zA(e),n=null==t?$A(null,e.length):zA(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=ly(e);if(t.length!==this.inputLayers.length)throw new TA(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let e=0;e<t.length;e++){const r=this.inputLayers[e],a=t[e];n[r.name+"_0_0"]=a}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(jA);if(r.length>1)for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(t.id))continue;const r=[];for(let t=0;t<e.inboundLayers.length;t++){const a=e.inboundLayers[t],s=e.nodeIndices[t],o=e.tensorIndices[t],i=n[`${a.name}_${s}_${o}`];r.push(i)}const a=ly(t.computeOutputShape(DA(r))),s=t.inboundNodes.indexOf(e);for(let e=0;e<a.length;e++){n[`${t.name}_${s}_${e}`]=a[e]}}}const a=[],s=[];for(let e=0;e<this.outputLayers.length;e++){const t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],a=`${t.name}_${n}_${r}`;s.push(a)}for(let e=0;e<s.length;e++){const t=s[e];FA(t in n),a.push(n[t])}return DA(a)}runInternalGraph(e,t){null==t&&(t=$A(null,e.length));const n={};for(let r=0;r<this.inputs.length;++r){const a=this.inputs[r],s=e[r],o=t[r];n[a.id]=[s,o]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(jA);for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,a=e.outputTensors,s=new Array;for(const e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,o,i,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===s.length){const[e,n]=s[0];null==u.mask&&(u.mask=n),i=zA(t.call(e,u)),l=zA(t.computeMask(e,n)),r=[e],o=[n]}else r=s.map((e=>e[0])),o=s.map((e=>e[1])),null==u.mask&&(u.mask=o),i=zA(t.call(r,u)),l=zA(t.computeMask(r,o));if(t.activityRegularizer)throw new RA("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){const t=a[e],r=i[e],s=l[e];n[t.id]=[r,s]}}}}const a=[],s=[],o=[];for(const e of this.outputs){FA(e.id in n,`Could not compute output ${e.name} : ${e.id}`);const[t,r]=n[e.id];o.push(t.shape),a.push(t),s.push(r)}return[a,s,o]}buildNodeConversionMap(e){const t={};let n;for(const e of this.layers){n=e instanceof nb?1:0;for(let r=0;r<e.inboundNodes.length;r++){const a=nb.nodeKey(e,r);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new TA(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new TA("Provide either a layer name or layer index");for(const t of this.layers)if(t.name===e)return t;throw new TA(`No such layer: ${e}`)}calculateLosses(){return gi((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=nb.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const e of this.layers){const r=e.getClassName(),a=e.getConfig(),s=[];for(let n=0;n<e.inboundNodes.length;n++){const r=e.inboundNodes[n],a=nb.nodeKey(e,n);let o={};if(this.containerNodes.has(a)){if(r.callArgs)try{JSON.stringify(r.callArgs),o=r.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${r.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(r.inboundLayers.length>0){const e=[];for(let n=0;n<r.inboundLayers.length;n++){const a=r.inboundLayers[n],s=r.nodeIndices[n],i=r.tensorIndices[n];let l=t[nb.nodeKey(a,s)];null==l&&(l=0),e.push([a.name,l,i,o])}s.push(e)}}}const o={};o.name=e.name,o.className=r,o.config=a,o.inboundNodes=s,n.push(o)}e.layers=n;const r=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e],a=this.inputLayersNodeIndices[e],s=nb.nodeKey(n,a);if(!this.containerNodes.has(s))continue;let o=t[s];null==o&&(o=0);const i=this.inputLayersTensorIndices[e];r.push([n.name,o,i])}e.inputLayers=r;const a=[];for(let e=0;e<this.outputLayers.length;e++){const n=this.outputLayers[e],r=this.outputLayersNodeIndices[e],s=nb.nodeKey(n,r);if(!this.containerNodes.has(s))continue;let o=t[s];null==o&&(o=0);const i=this.outputLayersTensorIndices[e];a.push([n.name,o,i])}return e.outputLayers=a,e}static fromConfig(e,t,n={},r=!1){const a={},s={};function o(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function i(e,t){const n=[];let r;for(const s of t){const i=s[0],l=s[1],u=s[2];if(r=null==s[3]?{}:s[3],!(i in a))return void o(e,t);const c=a[i];if(c.inboundNodes.length<=l)return void o(e,t);const d=c.inboundNodes[l];n.push(d.outputTensors[u])}n.length>0&&e.apply(DA(n),r)}function l(e){const n=e.name,s=wx(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(r),a[n]=s;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new TA(`Corrupted configuration, expected array for nodeData: ${e}`);o(s,e)}))}const u=t.name,c=t.layers;for(const e of c)l(e);for(;!HA(s);)for(const e of c){const t=a[e.name];if(t.name in s){const e=s[t.name];delete s[t.name];for(const n of e)i(t,n)}}const d=[],h=[],p=t.inputLayers;for(const e of p){const t=e[0],n=e[1],r=e[2];FA(t in a);const s=a[t].inboundNodes[n].outputTensors;d.push(s[r])}const f=t.outputLayers;for(const e of f){const t=e[0],n=e[1],r=e[2];FA(t in a);const s=a[t].inboundNodes[n].outputTensors;h.push(s[r])}return new e({inputs:d,outputs:h,name:u})}get stateful(){if(this._stateful)throw new TA("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){gi((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function rb(e,t){return function(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function ab(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=gi((()=>{if(1===e.shape.length)return Po(e);if(2===e.shape.length){if(e.shape[1]>1){return jl(e,1)}if(1===e.shape[1])return du(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());yi(t);const a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),yh(a,"float32")}return null}function sb(e,t){return zl(e,t)}function ob(e,t){let n,r;const a=t;n=a.xs,r=a.ys,wa.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const s=ib("input",e.inputNames,n),o=ib("output",e.outputNames,r),i=s[0].shape[0];wa.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),wa.assert(o.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let t=0;t<s.length;t++)wa.assert(s[t].shape[0]===i,(()=>`Batch size mismatch: input ${e.inputNames[t]} has ${s[t].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`));for(let t=0;t<o.length;t++)wa.assert(o[t].shape[0]===i,(()=>`Batch size mismatch: output ${e.outputNames[t]} has ${o[t].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`));return{xs:s,ys:o}}function ib(e,t,n){if(n instanceof Qa)return[n];if(Array.isArray(n))return wa.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const a of t){if(null==n[a])throw new TA(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function lb(e,t,n){const r=null!=n.batchesPerEpoch;if(wa.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),wa.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),wa.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),wa.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),wa.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const a=null!=n.validationData;let s,o;if(a)if(ub(n.validationData))wa.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new RA("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);s=e.xs,o=e.ys}const i=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=a?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=xx(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=vx(c,d,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,a,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const u={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){const{xs:r,ys:a}=ob(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await h.onBatchBegin(d,s);const o=[];if(null!=n.classWeight){const t=rb(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)o.push(await ab(a[e],null,t[e]))}const u=r.concat(a).concat(o),p=i(u);yi(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];s[t]=n,xi(n)}await h.onBatchEnd(d,s),px(s),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(a){let t;t=ub(n.validationData)?zA(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):zA(e.evaluate(s,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,u),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function ub(e){return"function"==typeof e.iterator}function cb(e){wa.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function db(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>Ig(e,t,n-t))):Ig(e,t,n-t)}function hb(e,t){return gi((()=>null==e?null:Array.isArray(e)?e.map((e=>hb(e,t))):$g(e,"int32"===t.dtype?t:zo(t,"int32"))))}function pb(e,t){const n=[];let r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}async function fb(e,t,n,r={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let a,s,o,i,l,u,c,d,h;e.isTraining=!0;try{const p=null==r.batchSize?32:r.batchSize;cb(p);const f=!1,m=await e.standardizeUserData(t,n,r.sampleWeight,r.classWeight,f,p);a=m[0],s=m[1],h=m[2];let A,g=!1;if(null!=r.validationData&&r.validationData.length>0){if(g=!0,2!==r.validationData.length)throw 3===r.validationData.length?new RA("validationData including sample weights is not supported yet."):new TA(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);l=r.validationData[0],u=r.validationData[1];const t=!0,n=await e.standardizeUserData(l,u,null,null,t,p);c=n[0],d=n[1],A=c.concat(d)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){g=!0;const e=Math.floor(a[0].shape[0]*(1-r.validationSplit)),t=a[0].shape[0];c=db(a,e,t),o=a,a=db(a,0,e),d=db(s,e,t),i=s,s=db(s,0,e),A=c.concat(d)}else null!=r.validationSteps&&(g=!0);const y=a.concat(s).concat(h);e.checkTrainableWeightsConsistency();const x=e.makeTrainFunction(),b=e.getDedupedMetricsNames();let v,w;g?(e.makeTestFunction(),v=e.testFunction,w=b.slice().concat(b.map((e=>"val_"+e)))):(v=null,A=[],w=b.slice());const k=xx(r.callbacks,r.yieldEvery),S=await async function(e,t,n,r,a,s,o,i,l,u,c,d,h,p,f){null==a&&(a=32),null==s&&(s=1),null==c&&(c=!0),null==h&&(h=0);let m=!1;if(null!=l&&null!=u&&(m=!0),null!=f&&(m=!0,null==p))throw new TA("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const A=e.checkNumSamples(n,a,p,"steps_per_epoch");let g;null!=A&&(g=vg(0,A)),null==o&&(o=1);const{callbackList:y,history:x}=vx(i,o,s,h,A,p,a,m,d);y.setModel(e),e.history=x,await y.onTrainBegin(),e.stopTraining_=!1;for(let o=h;o<s;++o){await y.onEpochBegin(o);const s={};if(null!=p)throw new RA("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new RA("batch shuffling is not implemneted yet");c&&wa.shuffle(g);const o=yh(g),i=pb(A,a);for(let c=0;c<i.length;++c){const d={};if(await y.onBatchBegin(c,d),gi((()=>{const h=i[c][0],p=i[c][1],f=Ig(o,h,p-h);d.batch=c,d.size=p-h;const A=hb(n,f),g=t(A);for(let e=0;e<r.length;++e){const t=r[e],n=g[e];d[t]=n,xi(n)}if(c===i.length-1&&m){const t=e.testLoop(l,u,a);for(let e=0;e<r.length;++e){const n=r[e],a=t[e];xi(a),s["val_"+n]=a}}})),await y.onBatchEnd(c,d),px(d),e.stopTraining_)break}o.dispose()}if(await y.onEpochEnd(o,s),e.stopTraining_)break}return await y.onTrainEnd(),await e.history.syncData(),e.history}(e,x,y,b,p,r.epochs,r.verbose,k,v,A,r.shuffle,w,r.initialEpoch,null,null);return S}finally{e.isTraining=!1,Ab(a,t),Ab(s,n),Ab(o,t),Ab(i,n),Ab(c,l),Ab(d,u),null!=h&&yi(h)}}function mb(e){const t=[];e instanceof Qa&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(Sg(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Ab(e,t){if(null==e)return;const n=[];if(t instanceof Qa)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const e in t){const r=t[e];n.push(r.id)}const r=[];if(e instanceof Qa)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const t in e){const a=e[t];-1===n.indexOf(a.id)&&r.push(a)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function gb(e){return Array.isArray(e)}function yb(e){return!function(e){return e instanceof Qa}(e)&&!gb(e)}function xb(e,t,n,r=!0,a=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(gb(e)&&e.length>0)t=!0;else if(yb(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new TA(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let s;if(yb(e)){s=[];for(const n of t){if(null==e[n])throw new TA(`No data provided for "${n}". Need data for each key in: ${t}`);s.push(e[n])}}else if(gb(e)){if(e.length!==t.length)throw new TA(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(t.length>1)throw new TA(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=mb(s),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const o=s[e];if(o.shape.length!==n[e].length)throw new TA(`Error when checking ${a}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${o.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!r)continue;const s=o.shape[t],i=n[e][t];if(null!=i&&i>=0&&s!==i)throw new TA(`${a} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${a} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function bb(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new TA(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new TA(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const o=s[e];if(o.shape.length!==n[e].length)throw new TA(`Error when checking ${a}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let s=0;s<n[e].length;++s){if(0===s&&!r)continue;const i=o.shape[s],l=n[e][s];if(null!=l&&l!==i)throw new TA(`Error when checking ${a}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}var vb=class extends nb{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new TA("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Xx(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>df.adagrad(.01),Adadelta:()=>df.adadelta(1,.95,wg()),Adam:()=>df.adam(.001,.9,.999,wg()),Adamax:()=>df.adamax(.002,.9,.999,wg(),0),RMSProp:()=>df.rmsprop(.001,.9,0,wg()),SGD:()=>df.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new TA(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof tf))throw new TA("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new TA(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>Mx(e)))}else{const n=Mx(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new TA(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(Mx(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],hg("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};hg("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,s;for(const o of t){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const t=this.internalOutputShapes[e];let a;1===t[t.length-1]||this.lossFunctions[e]===Tx?-1!==["accuracy","acc"].indexOf(o)?r=$x:-1!==["crossentropy","ce"].indexOf(o)&&(r=Px):this.lossFunctions[e]===Nx?-1!==["accuracy","acc"].indexOf(o)?r=Lx:-1!==["crossentropy","ce"].indexOf(o)&&(r=Wx):-1!==["accuracy","acc"].indexOf(o)?r=Fx:-1!==["crossentropy","ce"].indexOf(o)&&(r=Bx),-1!==["accuracy","acc"].indexOf(o)?a="acc":-1!==["crossentropy","ce"].indexOf(o)&&(a="ce"),s=r,n=""+a}else{const e=Vx(o);s=e,n=""+jx(o)}let t;hg(n,(()=>{t=s})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;cb(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const s=a[0].concat(a[1]);this.makeTestFunction();const o=this.testFunction;return DA(this.testLoop(o,s,r,n.verbose,n.steps))}finally{Ab(a[0],e),Ab(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,a=e.testFunction;let s=[];if(n.verbose>0)throw new RA("Verbose mode is not implemented yet.");wa.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const o="function"==typeof t.next?t:await t.iterator();let i=0,l=0;for(;!r||l<n.batches;){const t=await o.next();if(s=gi((()=>{if(t.value){const{xs:n,ys:r}=ob(e,t.value),o=n.concat(r),u=gi((()=>a(o)));if(yi(o),0===l)for(let e=0;e<u.length;++e)s.push(fc(0));const c=o[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=s[e];s[e]=gi((()=>Fl(s[e],zl(c,t)))),l>0&&yi(n)}yi(u),i+=c,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<s.length;++e){const t=s[e];s[e]=Dl(s[e],i),yi(t)}return DA(s)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(null!=n){if(a=null,null!=t)throw new TA(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new TA(`Either the input data should have a defined shape, or ${r} shoud be specified.`);a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new TA("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new Iy;if(e instanceof Qa&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new TA(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const t of this.inputs){const n=e[t.name];if(null==n)throw new TA(`No value is provided for the model's input ${t.name}`);s.add(t,n)}const o=Ny(a,s);return n?o:o[0]}retrieveSymbolicTensors(e){const t=$A(null,e.length);let n=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){const o=s.indexOf(e[r]);if(-1!==o&&(t[r]=a[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new TA(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return gi((()=>{const r=this.checkNumSamples(e);if(n)throw new RA("Verbose predictLoop() is not implemented yet.");const a=pb(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t){gi((()=>{const n=a[t][0],r=a[t][1],s=db(e,n,r),o=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)o.push({key:this.inputs[e],value:s[e]});else o.push({key:this.inputs[0],value:s});const i=new Iy(o);return Ny(this.outputs,i)})).forEach(((e,t)=>s[t].push(e)))}return DA(s.map((e=>fu(e,0))))}))}predict(e,t={}){const n=mb(e);bb(n,this.inputNames,this.feedInputShapes,!1);try{const r=null==t.batchSize?32:t.batchSize;return cb(r),this.predictLoop(n,r)}finally{Ab(n,e)}}predictOnBatch(e){bb(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new NA("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let e=0;e<this.feedOutputShapes.length;++e){const t=this.feedOutputShapes[e];this.feedLossFns[e]===Nx?a.push(t.slice(0,t.length-1).concat([1])):a.push(t)}if(function(e,t,n){const r=GA(e.map((e=>e.shape[0])));r.sort();const a=GA(t.map((e=>e.shape[0])));if(a.sort(),r.length>1)throw new TA(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(a.length>1)throw new TA(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(r.length>0&&a.length>0&&!wa.arraysEqual(r,a))throw new TA(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}(e=xb(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=xb(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){const r=[Sx,Tx,Ex];for(let a=0;a<e.length;++a){const s=e[a],o=t[a],i=n[a];if(null!=o){if(o===Ex&&1===s.shape[s.shape.length-1])throw new TA(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const e=s.shape.slice(1),t=i.slice(1);for(let n=0;n<e.length;++n){const r=e[n],a=t[n];if(null!=a&&r!==a)throw new TA(`A target Tensor with shape ${s.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new TA(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){const[o,i]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=rb(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await ab(i[t],null,e[t]))}return[o,i,l]}testLoop(e,t,n,r=0,a){return gi((()=>{const s=this.checkNumSamples(t,n,a,"steps"),o=[];if(r>0)throw new RA("Verbose mode is not implemented yet.");if(null!=a)throw new RA("steps mode in testLoop() is not implemented yet");{const r=pb(s,n),a=yh(vg(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],i=r[n][1],l=Ig(a,s,i-s),u=hb(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)o.push(fc(0));for(let e=0;e<c.length;++e){const t=c[e];o[e]=Fl(o[e],zl(i-s,t))}}for(let e=0;e<o.length;++e)o[e]=Dl(o[e],s)}return o}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let a=r;if(OA(e,r)>1){a+=`_${OA(e.slice(0,n),r)}`}t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const o=new Iy(e),i=Ny(this.outputs,o,{training:!0});let l;for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(r[e],i[e]);null!=a[e]&&(n=sb(n,a[e]));const s=cd(n);t.push(s),l=0===e?n:Fl(l,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{const t=this.metricsTensors[e][0],a=this.metricsTensors[e][1];n=cd(t(r[a],i[a]))}xi(n),s.push(n)}return l=cd(l),this.calculateLosses().forEach((e=>{l=Fl(l,e)})),l}),!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>gi((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});const o=new Iy(s),i=Ny(this.outputs,o);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],s=cd(r(a[e],i[e]));n=0===e?s:Fl(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=cd(n(a[r],i[r]));t.push(s)}return t}))}async fit(e,t,n={}){return fb(this,e,t,n)}async fitDataset(e,t){return lb(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),o=[];for(const e of s){const t=await e.data();o.push(t[0])}return yi(s),Ab(n[0],e),Ab(n[1],t),DA(o)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let e=0;e<r.length;++e)n&&!r[e].trainable||t.push({name:r[e].originalName,tensor:a[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=mi().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-mi().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=PA(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>PA(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=PA(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[PA(jx(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>PA(jx(e))));{const e={};for(const t in this.metrics)e[t]=PA(jx(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=wx(Qx(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=LA(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>LA(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=LA(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>LA(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=LA(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"==typeof e){const t=Bo.getSaveHandlers(e);if(0===t.length)throw new TA(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new TA(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new TA("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await Bo.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${tb}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:a}=await Bo.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...a),n.data=Bo.concatenateArrayBuffers([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;Hx(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){Hx(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};vb.className="Model",gl.registerClass(vb);var wb=class extends vb{};async function kb(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);const r=wx(Qx(n),t);if(null!=e.weightsManifest){const t=await Bo.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map((e=>e.originalName))),n={};for(const e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),yi(t)}return r}async function Sb(e,t){if(null==t&&(t={}),"string"==typeof e){const n=Bo.getLoadHandlers(e,t);if(0===n.length)n.push(Bo.browserHTTPRequest(e,t));else if(n.length>1)throw new TA(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){null==n&&(n={});if(null==e.load)throw new TA("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await e.load();let a=r.modelTopology;null!=a.model_config&&(a=a.model_config);const s=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&s,i=wx(Qx(a),t,o),l=r.trainingConfig;null!=l&&i.loadTrainingConfig(l);null!=r.userDefinedMetadata&&i.setUserDefinedMetadata(r.userDefinedMetadata);if(null!=r.weightData){if(null==r.weightSpecs)throw new TA("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=function(e,t){const n=Bo.decodeWeights(e,t),r={},a=[];return t.forEach((e=>{"optimizer"===e.group?a.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);i.loadWeights(e,s),null!=i.optimizer&&t.length>0&&await i.optimizer.setWeights(t),yi(e),yi(t.map((e=>e.tensor)))}return i}(e,void 0,t)}wb.className="Functional",gl.registerClass(wb);var Ib=class extends vb{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:tg("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new TA(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Ib||e instanceof vb;let n;if(t){if(n=e,1!==n.outputs.length)throw new TA("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new TA("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new TA("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=Sy({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new TA(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new TA("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=wy(this.outputs[0])}this.inboundNodes=[],new xy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:$A(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(cy(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new vb({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new NA("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new NA("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new NA("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new NA("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let a,s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new TA("Legacy serialization format not supported yet.");a=t}else wa.assert(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),a=t.layers,delete t.layers,s=t;const o=new e(s);if(!(o instanceof Ib))throw new RA(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const e of a){const t=wx(e,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),o.add(t)}return o}set stopTraining(e){if(null==this.model)throw new TA("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new TA("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function Cb(e){return new vb(e)}function Eb(e){return new Ib(e)}function Nb(e,t){return null==t&&(t={}),Sb(e,t)}function Tb(e){return Sy(e)}function Rb(e,t){bx.registerCallbackConstructor(e,t)}Ib.className="Sequential",gl.registerClass(Ib);var _b=class extends gl.Serializable{getConfig(){return{}}},Mb=class extends _b{apply(e,t=1){return function(e,t=1){if(1!==t)throw new RA(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return tc(e)}(e,t)}};Mb.className="elu",gl.registerClass(Mb);var $b=class extends _b{apply(e){return Zd(e)}};$b.className="selu",gl.registerClass($b);var Fb=class extends _b{apply(e){return Wd(e)}};Fb.className="relu",gl.registerClass(Fb);var Ob=class extends _b{apply(e){return gi((()=>fd(6,Wd(e))))}};Ob.className="relu6",gl.registerClass(Ob);var Db=class extends _b{apply(e){return e}};Db.className="linear",gl.registerClass(Db);var zb=class extends _b{apply(e){return mu(e)}};zb.className="sigmoid",gl.registerClass(zb);var Pb=class extends _b{apply(e){return function(e){return gi((()=>{const t=Fl(.5,zl(.2,e));return Nu(t,0,1)}))}(e)}};Pb.className="hardSigmoid",gl.registerClass(Pb);var Lb=class extends _b{apply(e){return Xc(e)}};Lb.className="softplus",gl.registerClass(Lb);var Bb=class extends _b{apply(e){return function(e){return gi((()=>Dl(e,Fl(Pl(e),1))))}(e)}};Bb.className="softsign",gl.registerClass(Bb);var Wb=class extends _b{apply(e){return gu(e)}};Wb.className="tanh",gl.registerClass(Wb);var Ub=class extends _b{apply(e,t=-1){return oh(e,t)}};Ub.className="softmax",gl.registerClass(Ub);var Vb=class extends _b{apply(e,t=-1){return Yc(e,t)}};Vb.className="logSoftmax",gl.registerClass(Vb);var jb=class extends _b{apply(e,t=1){return gi((()=>zl(mu(zl(e,t)),e)))}};jb.className="swish",gl.registerClass(jb);var Gb=class extends _b{apply(e){return gi((()=>zl(e,gu(Xc(e)))))}};function Hb(e){return e.getClassName()}function qb(e,t={}){return VA(e,gl.SerializationMap.getMap().classNameMap,t,"activation")}function Xb(e){if(null==e){const e={className:"linear",config:{}};return qb(e)}if("string"==typeof e){const t={};return t.className=e,t.config={},qb(t)}return e instanceof _b?e:qb(e)}function Kb(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}Gb.className="mish",gl.registerClass(Gb);var Zb=class extends gl.Serializable{},Yb=class extends Zb{constructor(e){super(),Kb(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return gi((()=>{let t=dd([1]);return this.hasL1&&(t=Fl(t,gc(zl(this.l1,Pl(e))))),this.hasL2&&(t=Fl(t,gc(zl(this.l2,Fg(e))))),du(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Yb.className="L1L2",gl.registerClass(Yb);var Jb={l1l2:"L1L2"};function Qb(e){return WA(e)}function ev(e,t={}){return VA(e,gl.SerializationMap.getMap().classNameMap,t,"regularizer")}function tv(e){if(null==e)return null;if("string"==typeof e){return ev({className:e in Jb?Jb[e]:e,config:{}})}return e instanceof Zb?e:ev(e)}var nv=class extends vy{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=uy(e);let n=Wd(e);return null!=this.maxValue&&(n=Nu(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};nv.className="ReLU",gl.registerClass(nv);var rv=class extends vy{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=uy(e);return Fc(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};rv.className="LeakyReLU",gl.registerClass(rv);var av=class extends vy{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=oy(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=tv(e.alphaRegularizer),this.alphaConstraint=Uy(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new TA(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=cy(e)).slice(1);if(null!=this.sharedAxes)for(const e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new Ay({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=uy(e),Rd(e,this.alpha.read())}getConfig(){const e={alphaInitializer:sy(this.alphaInitializer),alphaRegularizer:Qb(this.alphaRegularizer),alphaConstraint:By(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};av.className="PReLU",gl.registerClass(av);var sv=class extends vy{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new RA(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=uy(e);return tc(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};sv.className="ELU",gl.registerClass(sv);var ov=class extends vy{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=uy(e);return zl(n,zo(Tc(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};ov.className="ThresholdedReLU",gl.registerClass(ov);var iv=class extends vy{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Ub).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=uy(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function lv(e,t,n){if("number"==typeof e)return $A(e,t);if(e.length!==t)throw new TA(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let a=0;a<t;++a){const s=e[a];if((r=s)!==parseInt(r.toString(),10))throw new TA(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e;var r}function uv(e,t,n,r,a=1){if(null==e)return e;let s;return s="same"===n?e:e-(t+(t-1)*(a-1))+1,Math.floor((s+r-1)/r)}function cv(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+bg([n-t,0]);else{if("same"!==r)throw new TA(`Unsupport padding mode: ${r}.`);e*=t}return e}function dv(e,t){return gi((()=>(lg(t),"channelsFirst"===t?$i(e,[0,2,3,1]):e)))}function hv(e,t){return gi((()=>(lg(t),"channelsFirst"===t?$i(e,[0,2,3,4,1]):e)))}function pv(e,t,n,r=[1,1],a="valid",s,o,i=null){return gi((()=>{if(null==s&&(s="channelsLast"),lg(s),3!==e.rank&&4!==e.rank)throw new TA(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new TA(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=dv(e,s);if("causal"===a)throw new RA("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Wh.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===s&&(l=$i(l,[0,3,1,2])),l}))}iv.className="Softmax",gl.registerClass(iv);var fv=class extends vy{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",fv.verifyArgs(t),this.rank=e,KA(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new RA(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=lv(t.kernelSize,e,"kernelSize"),this.strides=lv(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,ug(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,lg(this.dataFormat),this.activation=Xb(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=oy(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Uy(t.biasConstraint),this.biasRegularizer=tv(t.biasRegularizer),this.activityRegularizer=tv(t.activityRegularizer),this.dilationRate=lv(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new TA(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new TA(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new TA(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(FA("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!XA(e.kernelSize,"number",1,3))throw new TA(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Hb(this.activation),useBias:this.useBias,biasInitializer:sy(this.biasInitializer),biasRegularizer:Qb(this.biasRegularizer),activityRegularizer:Qb(this.activityRegularizer),biasConstraint:By(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},mv=class extends fv{constructor(e,t){super(e,t),this.kernel=null,mv.verifyArgs(t),this.filters=t.filters,KA(this.filters,"filters"),this.kernelInitializer=oy(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Uy(t.kernelConstraint),this.kernelRegularizer=tv(t.kernelRegularizer)}build(e){e=cy(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new TA(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return gi((()=>{let t;e=uy(e);const n=null==this.bias?null:this.bias.read(),r=YA(this.activation.getClassName());if(null!=r&&2===this.rank)t=pv(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,a="valid",s,o=1){return gi((()=>{if(null==s&&(s="channelsLast"),lg(s),3!==e.shape.length)throw new TA(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new TA(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new TA(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(e=$i(e,[0,2,1])),"causal"===a)throw new RA("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=Fu(e,t,r,"same"===a?"same":"valid","NWC",o);return null!=n&&(i=Dg(i,n)),i}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=pv(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new RA("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],a="valid",s,o){return gi((()=>{if(null==s&&(s="channelsLast"),lg(s),4!==e.rank&&5!==e.rank)throw new TA(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new TA(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let i=hv(e,s);if("causal"===a)throw new RA("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=zu(i,t,r,"same"===a?"same":"valid","NDHWC",o),null!=n&&(i=Dg(i,n)),"channelsFirst"===s&&(i=$i(i,[0,4,1,2,3])),i}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=cy(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){const r=uv(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:sy(this.kernelInitializer),kernelRegularizer:Qb(this.kernelRegularizer),kernelConstraint:By(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new TA(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},Av=class extends mv{constructor(e){super(2,e),Av.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!XA(e.kernelSize,"number",1,2))throw new TA(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};Av.className="Conv2D",gl.registerClass(Av);var gv=class extends mv{constructor(e){super(3,e),gv.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new TA(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};gv.className="Conv3D",gl.registerClass(gv);var yv=class extends Av{constructor(e){if(super(e),this.inputSpec=[new Ay({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new TA(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=cy(e)).length)throw new TA("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new TA("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ay({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return gi((()=>{let t=uy(e);if(4!==t.shape.length)throw new TA(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const o=n[a],i=n[s],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[r,cv(o,c,l,this.padding),cv(i,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=$i(t,[0,2,3,1]));let p=Du(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=$i(p,[0,3,1,2])),null!=this.bias&&(p=Dg(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=cy(e)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=cv(t[r],i,s,this.padding),t[a]=cv(t[a],l,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}};yv.className="Conv2DTranspose",gl.registerClass(yv);var xv=class extends gv{constructor(e){if(super(e),this.inputSpec=[new Ay({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new TA(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=cy(e)).length)throw new TA("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new TA("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ay({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return gi((()=>{let t=uy(e);if(5!==t.shape.length)throw new TA(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let a,s,o;"channelsFirst"===this.dataFormat?(o=2,a=3,s=4):(o=1,a=2,s=3);const i=n[o],l=n[a],u=n[s],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],A=[r,cv(i,p,c,this.padding),cv(l,f,d,this.padding),cv(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=$i(t,[0,2,3,4,1]));let g=Lu(t,this.kernel.read(),A,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(g=$i(g,[0,4,1,2,3])),null!==this.bias&&(g=Dg(g,this.bias.read(),this.dataFormat)),null!==this.activation&&(g=this.activation.apply(g)),g}))}computeOutputShape(e){const t=(e=cy(e)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const o=this.kernelSize[0],i=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=cv(t[r],u,o,this.padding),t[a]=cv(t[a],c,i,this.padding),t[s]=cv(t[s],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}};xv.className="Conv3DTranspose",gl.registerClass(xv);var bv=class extends mv{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new TA("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new TA("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new TA(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=oy(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=tv(t.depthwiseRegularizer),this.depthwiseConstraint=Uy(t.depthwiseConstraint),this.pointwiseInitializer=oy(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=tv(t.pointwiseRegularizer),this.pointwiseConstraint=Uy(t.pointwiseConstraint)}build(e){if((e=cy(e)).length<this.rank+2)throw new TA(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new TA(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let e=0;e<this.rank;++e)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Ay({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return gi((()=>{let t;if(e=uy(e),1===this.rank)throw new RA("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=$i(e,[0,2,3,1])),t=Yd(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=Dg(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=$i(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=sy(this.depthwiseInitializer),e.pointwiseInitializer=sy(this.pointwiseInitializer),e.depthwiseRegularizer=Qb(this.depthwiseRegularizer),e.pointwiseRegularizer=Qb(this.pointwiseRegularizer),e.depthwiseConstraint=By(this.depthwiseConstraint),e.pointwiseConstraint=By(this.pointwiseConstraint),e}};bv.className="SeparableConv";var vv=class extends bv{constructor(e){super(2,e)}};vv.className="SeparableConv2D",gl.registerClass(vv);var wv=class extends mv{constructor(e){super(1,e),wv.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!XA(e.kernelSize,"number",1,1))throw new TA(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};wv.className="Conv1D",gl.registerClass(wv);var kv=class extends vy{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return gi((()=>{if(e=uy(e),"channelsLast"===this.dataFormat){const t=Eg(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Eg(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Eg(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Eg(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};kv.className="Cropping2D",gl.registerClass(kv);var Sv=class extends vy{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,lg(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,qA(rg,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return gi((()=>{let t=uy(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=$i(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?Zp.resizeNearestNeighbor(t,[e,r]):Zp.resizeBilinear(t,[e,r]);return $i(a,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?Zp.resizeNearestNeighbor(t,[e,r]):Zp.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};Sv.className="UpSampling2D",gl.registerClass(Sv);var Iv=class extends fv{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=oy(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Uy(e.depthwiseConstraint),this.depthwiseRegularizer=tv(e.depthwiseRegularizer)}build(e){if((e=cy(e)).length<4)throw new TA(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new TA(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return gi((()=>{let t=function(e,t,n=[1,1],r="valid",a,s){return gi((()=>{null==a&&(a="channelsLast"),lg(a);let o=dv(e,a);if(4!==e.rank)throw new TA(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new TA(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=Hu(o,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(o=$i(o,[0,3,1,2])),o}))}(e=uy(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=Dg(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=cy(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=uv(t,this.kernelSize[0],this.padding,this.strides[0]),s=uv(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=sy(this.depthwiseInitializer),e.depthwiseRegularizer=Qb(this.depthwiseRegularizer),e.depthwiseConstraint=By(this.depthwiseRegularizer),e}};function Cv(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new TA("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function Ev(e,t,n,r=!1,a,s,o=!1,i=!1){return gi((()=>{const l=t.shape.length;if(l<3)throw new TA(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(vg(2,l));if(t=$i(t,u),null!=s)throw new RA("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&((a=zo(zo(a,"bool"),"float32")).rank===l-1&&(a=wc(a,-1)),a=$i(a,u)),r&&(t=Vd(t,0),null!=a&&(a=Vd(a,0)));const c=[];let d,h=n;const p=t.shape[0],f=Eh(t);let m,A;null!=a&&(m=Eh(a));for(let t=0;t<p;++t){const n=f[t],r=gi((()=>e(n,h)));if(null==a)d=r[0],h=r[1];else{const e=gi((()=>{const e=m[t],n=Zc(vd(e),e);return{output:Fl(zl(r[0],e),zl(h[0],n)),newStates:h.map(((t,a)=>Fl(zl(r[1][a],e),zl(t,n))))}}));d=e.output,h=e.newStates}i&&c.push(d)}if(i){A=fh(c,1)}return[d,A,h]}))}Iv.className="DepthwiseConv2D",gl.registerClass(Iv);var Nv=class extends vy{constructor(e){let t;if(super(e),null==e.cell)throw new TA("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new Dv({cells:e.cell}):e.cell,null==t.stateSize)throw new TA("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ay({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return vg(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){iy(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return gi((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new RA("Constants support is not implemented in RNN yet.");iy(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Ay({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!wa.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),a))throw new TA(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map((e=>new Ay({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){gi((()=>{if(!this.stateful)throw new EA("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new TA("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>dd([n,e]))):this.states_=[dd([n,this.cell.stateSize])];else if(null==e)yi(this.states_),null!=this.keptStates&&(yi(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>dd([n,e]))):this.states_[0]=dd([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new TA(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):yi(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!wa.arraysEqual(r.shape,s))throw new TA(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>xi(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=Cv(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],o=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Ay({shape:e.shape}));o=o.concat(this.stateSpec)}null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof gy){const n=[e].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,t);return this.inputSpec=a,i}return super.apply(e,t)}call(e,t){return gi((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let a=null==t?null:t.initialState;e=uy(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new TA(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},i=Ev(((e,t)=>{const n=this.cell.call([e].concat(t),o);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=i[0],u=i[1],c=i[2];this.stateful&&this.resetStates(c,r);const d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return gi((()=>{let t=dd(e.shape);return t=gc(t,[1,2]),t=Sg(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?Rg(t,[1,e]):t)):this.cell.stateSize>1?[Rg(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Nv.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){const r=wx(t.cell,n);return new e(Object.assign(t,{cell:r}))}};Nv.className="RNN",gl.registerClass(Nv);var Tv=class extends vy{},Rv=class extends Tv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,KA(this.units,"units"),this.activation=Xb(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=oy(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oy(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oy(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=tv(e.kernelRegularizer),this.recurrentRegularizer=tv(e.recurrentRegularizer),this.biasRegularizer=tv(e.biasRegularizer),this.kernelConstraint=Uy(e.kernelConstraint),this.recurrentConstraint=Uy(e.recurrentConstraint),this.biasConstraint=Uy(e.biasConstraint),this.dropout=xg([1,bg([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=xg([1,bg([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=cy(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return gi((()=>{if(2!==e.length)throw new TA(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zv({ones:()=>vd(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zv({ones:()=>vd(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;a=Mg(null!=s?zl(e,s):e,this.kernel.read()),null!=this.bias&&(a=Dg(a,this.bias.read())),null!=o&&(n=zl(n,o));let i=Fl(a,Mg(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Hb(this.activation),useBias:this.useBias,kernelInitializer:sy(this.kernelInitializer),recurrentInitializer:sy(this.recurrentInitializer),biasInitializer:sy(this.biasInitializer),kernelRegularizer:Qb(this.kernelRegularizer),recurrentRegularizer:Qb(this.recurrentRegularizer),biasRegularizer:Qb(this.biasRegularizer),activityRegularizer:Qb(this.activityRegularizer),kernelConstraint:By(this.kernelConstraint),recurrentConstraint:By(this.recurrentConstraint),biasConstraint:By(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}};Rv.className="SimpleRNNCell",gl.registerClass(Rv);var _v=class extends Nv{constructor(e){e.cell=new Rv(e),super(e)}call(e,t){return gi((()=>{null!=this.cell.dropoutMask&&(yi(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(yi(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}};_v.className="SimpleRNN",gl.registerClass(_v);var Mv=class extends Tv{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new TA("GRUCell does not support reset_after parameter set to true.");this.units=e.units,KA(this.units,"units"),this.activation=Xb(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Xb(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=oy(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oy(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oy(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=tv(e.kernelRegularizer),this.recurrentRegularizer=tv(e.recurrentRegularizer),this.biasRegularizer=tv(e.biasRegularizer),this.kernelConstraint=Uy(e.kernelConstraint),this.recurrentConstraint=Uy(e.recurrentConstraint),this.biasConstraint=Uy(e.biasConstraint),this.dropout=xg([1,bg([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=xg([1,bg([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=cy(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return gi((()=>{if(2!==e.length)throw new TA(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zv({ones:()=>vd(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zv({ones:()=>vd(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let o,i,l;0<this.dropout&&this.dropout<1&&(e=zl(e,a[0]));let u=Mg(e,this.kernel.read());this.useBias&&(u=Dg(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=zl(r,s[0]));const c=this.recurrentKernel.read(),[d,h]=ch(c,[2*this.units,this.units],c.rank-1),p=Mg(r,d),[f,m,A]=ch(u,3,u.rank-1),[g,y]=ch(p,2,p.rank-1);o=this.recurrentActivation.apply(Fl(f,g)),i=this.recurrentActivation.apply(Fl(m,y));const x=Mg(zl(i,r),h);l=this.activation.apply(Fl(A,x));const b=Fl(zl(o,r),zl(Fl(1,_i(o)),l));return[b,b]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Hb(this.activation),recurrentActivation:Hb(this.recurrentActivation),useBias:this.useBias,kernelInitializer:sy(this.kernelInitializer),recurrentInitializer:sy(this.recurrentInitializer),biasInitializer:sy(this.biasInitializer),kernelRegularizer:Qb(this.kernelRegularizer),recurrentRegularizer:Qb(this.recurrentRegularizer),biasRegularizer:Qb(this.biasRegularizer),activityRegularizer:Qb(this.activityRegularizer),kernelConstraint:By(this.kernelConstraint),recurrentConstraint:By(this.recurrentConstraint),biasConstraint:By(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}};Mv.className="GRUCell",gl.registerClass(Mv);var $v=class extends Nv{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Mv(e),super(e)}call(e,t){return gi((()=>{null!=this.cell.dropoutMask&&(yi(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(yi(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};$v.className="GRU",gl.registerClass($v);var Fv=class extends Tv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,KA(this.units,"units"),this.activation=Xb(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Xb(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=oy(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oy(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oy(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=tv(e.kernelRegularizer),this.recurrentRegularizer=tv(e.recurrentRegularizer),this.biasRegularizer=tv(e.biasRegularizer),this.kernelConstraint=Uy(e.kernelConstraint),this.recurrentConstraint=Uy(e.recurrentConstraint),this.biasConstraint=Uy(e.biasConstraint),this.dropout=xg([1,bg([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=xg([1,bg([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=cy(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends Wg{apply(t,r){const a=e.apply([n]),s=(new Vg).apply([n]),o=e.apply([2*n]);return Tg(Tg(a,s),o)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return gi((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new TA(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zv({ones:()=>vd(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zv({ones:()=>vd(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,l,u,c;0<this.dropout&&this.dropout<1&&(e=zl(e,s[0]));let d=Mg(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=zl(r,o[0])),d=Fl(d,Mg(r,this.recurrentKernel.read())),this.useBias&&(d=Dg(d,this.bias.read()));const[h,p,f,m]=ch(d,4,d.rank-1);i=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=Fl(zl(l,a),zl(i,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const A=zl(c,this.activation.apply(u));return[A,A,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Hb(this.activation),recurrentActivation:Hb(this.recurrentActivation),useBias:this.useBias,kernelInitializer:sy(this.kernelInitializer),recurrentInitializer:sy(this.recurrentInitializer),biasInitializer:sy(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Qb(this.kernelRegularizer),recurrentRegularizer:Qb(this.recurrentRegularizer),biasRegularizer:Qb(this.biasRegularizer),activityRegularizer:Qb(this.activityRegularizer),kernelConstraint:By(this.kernelConstraint),recurrentConstraint:By(this.recurrentConstraint),biasConstraint:By(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}};Fv.className="LSTMCell",gl.registerClass(Fv);var Ov=class extends Nv{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Fv(e),super(e)}call(e,t){return gi((()=>{null!=this.cell.dropoutMask&&(yi(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(yi(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};Ov.className="LSTM",gl.registerClass(Ov);var Dv=class extends Tv{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return gi((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=r[o],s=0===o?[e[0]].concat(n):[s[0]].concat(n),s=i.call(s,t),a.push(s.slice(1))}n=[];for(const e of a.slice().reverse())n.push(...e);return[s[0]].concat(n)}))}build(e){let t;iy(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{hg(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign({},e,t)}static fromConfig(e,t,n={}){const r=[];for(const e of t.cells)r.push(wx(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return fy(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}my(t)}};function zv(e){const{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,o=()=>null!=s?s(t(),n):zg(t(),n),i=()=>Pg(o,t,r);if(!a||a<=1)return xi(i().clone());return Array(a).fill(void 0).map(i).map((e=>xi(e.clone())))}Dv.className="StackedRNNCells",gl.registerClass(Dv);var Pv=class extends Nv{constructor(e){if(e.unroll)throw new RA("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new RA("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Ay({ndim:5})]}call(e,t){return gi((()=>{if(null!=this.cell.dropoutMask&&(yi(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(yi(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new TA("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return gi((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=dd([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e,t=!1){gi((()=>{if(!this.stateful)throw new EA("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new TA("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>dd(a))):this.states_=[dd(a)];else if(null==e)yi(this.states_),null!=this.keptStates&&(yi(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>dd(a))):this.states_[0]=dd(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new TA(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):yi(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=a;if(!wa.arraysEqual(n.shape,r))throw new TA(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>xi(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:o}=this.cell,i="channelsFirst"===t,l=e[i?3:2],u=e[i?4:3],c=uv(l,r[0],a,s[0],o[0]),d=uv(u,r[1],a,s[1],o[1]);return[...e.slice(0,2),...i?[n,c,d]:[c,d,n]]}};Pv.className="ConvRNN2D";var Lv=class extends Fv{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:o}=e;super(Object.assign({},e,{units:t})),this.filters=t,KA(this.filters,"filters"),this.kernelSize=lv(n,2,"kernelSize"),this.kernelSize.forEach((e=>KA(e,"kernelSize"))),this.strides=lv(r||1,2,"strides"),this.strides.forEach((e=>KA(e,"strides"))),this.padding=a||"valid",ug(this.padding),this.dataFormat=s||"channelsLast",lg(this.dataFormat),this.dilationRate=lv(o||1,2,"dilationRate"),this.dilationRate.forEach((e=>KA(e,"dilationRate")))}build(e){var t;e=cy(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new TA(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends Wg{apply(e,t){return Ng([n.apply([r]),hd([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return gi((()=>{if(3!==e.length)throw new TA(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zv({ones:()=>vd(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=(e,t,n)=>t&&t[n]?zl(t[n],e):e;let l=i(r,o,0),u=i(r,o,1),c=i(r,o,2),d=i(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zv({ones:()=>vd(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=i(a,h,0),f=i(a,h,1),m=i(a,h,2),A=i(a,h,3);const[g,y,x,b]=ch(this.kernel.read(),4,3),[v,w,k,S]=this.useBias?ch(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,g,v,this.padding),u=this.inputConv(u,y,w,this.padding),c=this.inputConv(c,x,k,this.padding),d=this.inputConv(d,b,S,this.padding);const[I,C,E,N]=ch(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,I),f=this.recurrentConv(f,C),m=this.recurrentConv(m,E),A=this.recurrentConv(A,N);const T=this.recurrentActivation.apply(Fl(l,p)),R=this.recurrentActivation.apply(Fl(u,f)),_=Fl(zl(R,s),zl(T,this.activation.apply(Fl(c,m)))),M=zl(this.recurrentActivation.apply(Fl(d,A)),this.activation.apply(_));return[M,M,_]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(e,t,n,r){const a=$u(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Dg(a,n,this.dataFormat):a}recurrentConv(e,t){return $u(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};Lv.className="ConvLSTM2DCell",gl.registerClass(Lv);var Bv=class extends Pv{constructor(e){const t=new Lv(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}};Bv.className="ConvLSTM2D",gl.registerClass(Bv);var Wv=class extends vy{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return gi((()=>{this.invokeCallHook(e,t);const n=uy(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return Pg((()=>zg(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};Wv.className="Dropout",gl.registerClass(Wv);var Uv=class extends Wv{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}};Uv.className="SpatialDropout1D",gl.registerClass(Uv);var Vv=class extends vy{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,KA(this.units,"units"),this.activation=Xb(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=oy(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=oy(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Uy(e.kernelConstraint),this.biasConstraint=Uy(e.biasConstraint),this.kernelRegularizer=tv(e.kernelRegularizer),this.biasRegularizer=tv(e.biasRegularizer),this.activityRegularizer=tv(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=cy(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=cy(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return gi((()=>{this.invokeCallHook(e,t);const n=uy(e),r=YA(this.activation.getClassName());let a;return null!=r?a=Mg(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=Mg(n,this.kernel.read()),null!=this.bias&&(a=Dg(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const e={units:this.units,activation:Hb(this.activation),useBias:this.useBias,kernelInitializer:sy(this.kernelInitializer),biasInitializer:sy(this.biasInitializer),kernelRegularizer:Qb(this.kernelRegularizer),biasRegularizer:Qb(this.biasRegularizer),activityRegularizer:Qb(this.activityRegularizer),kernelConstraint:By(this.kernelConstraint),biasConstraint:By(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};Vv.className="Dense",gl.registerClass(Vv);var jv=class extends vy{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=cy(e);for(const t of e.slice(1))if(null==t)throw new TA(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],yg(e,1)]}call(e,t){return gi((()=>{this.invokeCallHook(e,t);let n=uy(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=$i(n,e)}return function(e){if(e.rank<=1)throw new TA(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],yg(e.shape,1)];return du(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}};jv.className="Flatten",gl.registerClass(jv);var Gv=class extends vy{constructor(e){super(e),this.supportsMasking=!0,this.activation=Xb(e.activation)}call(e,t){return gi((()=>{this.invokeCallHook(e,t);const n=uy(e);return this.activation.apply(n)}))}getConfig(){const e={activation:Hb(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};Gv.className="Activation",gl.registerClass(Gv);var Hv=class extends vy{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return gi((()=>{return e=uy(e),t=e,n=this.n,gi((()=>{if(2!==t.shape.length)throw new TA(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return Rg(Sg(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};Hv.className="RepeatVector",gl.registerClass(Hv);var qv=class extends vy{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let a=1,s=null;for(let e=0;e<r.length;++e){const t=r[e];if(this.isUnknown(t)){if(null!==s)throw new TA("Can only specifiy one unknown dimension.");s=e}else a*=t}const o=yg(e);if(null!==s){if(0===a||o%a!=0)throw new TA(n);r[s]=o/a}else if(o!==a)throw new TA(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return gi((()=>{this.invokeCallHook(e,t);const n=uy(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return du(n,a)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};qv.className="Reshape",gl.registerClass(qv);var Xv=class extends vy{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=vg(1,e.dims.length+1);if(!wa.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ay({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=cy(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return $i(uy(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};Xv.className="Permute",gl.registerClass(Xv);var Kv=class extends vy{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=uy(e);return Vl(bd(n,this.maskValue),-1)}call(e,t){return gi((()=>{this.invokeCallHook(e,t);const n=uy(e),r=Vl(bd(n,this.maskValue),-1,!0);return zl(n,zo(r,n.dtype))}))}};Kv.className="Masking",gl.registerClass(Kv);var Zv=class extends vy{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(zA(e.inputLength))}this.inputDim=e.inputDim,KA(this.inputDim,"inputDim"),this.outputDim=e.outputDim,KA(this.outputDim,"outputDim"),this.embeddingsInitializer=oy(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=tv(e.embeddingsRegularizer),this.activityRegularizer=tv(e.activityRegularizer),this.embeddingsConstraint=Uy(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return gi((()=>this.maskZero?(e=uy(e),bd(e,Yu(e))):null))}computeOutputShape(e){if(e=cy(e),null==this.inputLength)return[...e,this.outputDim];const t=zA(this.inputLength);if(t.length!==e.length-1)throw new TA(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new TA(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return gi((()=>{this.invokeCallHook(e,t);let n=uy(e);"int32"!==n.dtype&&(n=kg(n,"int32"));const r=$g(this.embeddings.read(),du(n,[n.size]));return du(r,cy(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:sy(this.embeddingsInitializer),embeddingsRegularizer:Qb(this.embeddingsRegularizer),activityRegularizer:Qb(this.activityRegularizer),embeddingsConstraint:By(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};Zv.className="Embedding",gl.registerClass(Zv);var Yv=class extends vy{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new RA}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new TA("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[cy(e)]),e.length<2)throw new TA(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=GA(t),t.length>1)throw new TA(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const r=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===GA(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return gi((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=bg(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=Sg(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,a=e[0],s=e.slice(1).concat([a]);let o=du(r,[a].concat(yg(e.slice(1))));o=$i(o,[1,0]),o=du(o,s),t.push(o),n=!0}else if(e>1){const a=vg(1,e).concat([0]);t.push($i(r,a)),n=!0}else t.push(r)}let r=this.mergeFunction(t);const a=r.rank;if(n)if(null==a){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=du($i(du(r,[-1,t]),[1,0]),n)}else if(a>1){const e=[a-1].concat(vg(0,a-1));r=$i(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=GA(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return gi((()=>{if(null==t)return null;if(!Array.isArray(t))throw new TA("`mask` should be an Array");if(!Array.isArray(e))throw new TA("`inputs` should be an Array");if(t.length!==e.length)throw new TA(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:wc(e,0))))[0];for(let e=1;e<t.length-1;++e)n=Qc(n,t[e]);return n}))}},Jv=class extends Yv{constructor(e){super(e)}mergeFunction(e){return gi((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Fl(t,e[n]);return t}))}};Jv.className="Add",gl.registerClass(Jv);var Qv=class extends Yv{constructor(e){super(e)}mergeFunction(e){return gi((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=zl(t,e[n]);return t}))}};Qv.className="Multiply",gl.registerClass(Qv);var ew=class extends Yv{constructor(e){super(e)}mergeFunction(e){return gi((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Fl(t,e[n]);return zl(1/e.length,t)}))}};ew.className="Average",gl.registerClass(ew);var tw=class extends Yv{constructor(e){super(e)}mergeFunction(e){return gi((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ud(t,e[n]);return t}))}};tw.className="Maximum",gl.registerClass(tw);var nw=class extends Yv{constructor(e){super(e)}mergeFunction(e){return gi((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=fd(t,e[n]);return t}))}};nw.className="Minimum",gl.registerClass(nw);var rw=class extends Yv{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new TA("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const r=e[t].slice();r.splice(this.axis,1);let a=!1;for(const e of n)if(wa.arraysEqual(e,r)){a=!0;break}a||n.push(r)}if(n.length>1)throw new TA("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return gi((()=>Ng(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new TA("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[r]||null==e[r]){n[r]=null;break}n[r]+=e[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new TA("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new TA("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new TA(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return gi((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(zo(vd(e[n]),"bool")):t[n].rank<e[n].rank?r.push(wc(t[n],-1)):r.push(t[n]);const a=fu(r,this.axis);return Ul(a,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function aw(e,t){for(;e<0;)e+=t;return e}rw.className="Concatenate",gl.registerClass(rw);var sw=class extends Yv{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){wa.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new RA("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new TA(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new TA(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>aw(t,e[n].shape.length))):[aw(this.axes,n.shape.length),aw(this.axes,r.shape.length)],this.normalize&&(n=kx(n,t[0]),r=kx(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new RA("batchDot is not implemented for tensors of 4D or higher rank yet");if(wa.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),wa.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new RA("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return gi((()=>{let n,o;if(r>a){n=r-a;const e=[];for(let t=0;t<n;++t)e.push(1);t=du(t,t.shape.concat(e))}else if(a>r){n=a-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=du(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)o=s[0]===s[1]?gc(zl(e,t),s[0]):gc(zl($i(e,[1,0]),t),s[1]);else{const n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;o=ii(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);o=ph(o,t)}return 1===o.shape.length&&(o=wc(o,1)),o}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[aw(this.axes,e.length),aw(this.axes,t.length)],n}computeOutputShape(e){wa.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new RA("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};sw.className="Dot",gl.registerClass(sw);var ow=class extends vy{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return gi((()=>{this.invokeCallHook(e,t);const n=uy(e);return Pg((()=>Fl(_g(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};ow.className="GaussianNoise",gl.registerClass(ow);var iw=class extends vy{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return gi((()=>{this.invokeCallHook(e,t);const n=uy(e);if(this.rate>0&&this.rate<1){return Pg((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return zl(n,_g(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}};iw.className="GaussianDropout",gl.registerClass(iw);var lw=class extends vy{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||uy(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return gi((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return Pg((()=>{const t=uy(e),r=-1.7580993408473766;let a=Rc(Pd(n),this.rate);a=kg(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-s*r*this.rate,i=Fl(zl(t,a),zl(Fl(a,-1),r));return Fl(zl(i,s),o)}),(()=>uy(e)),t.training||!1)}return e}))}};function uw(e,t,n,r,a,s=.001){let o;if(2===e.rank)o=vu(e,t,n,r,a,s);else if(3===e.rank)o=wu(e,t,n,r,a,s);else{if(4!==e.rank)throw new RA(`batchNormalization is not implemented for array of rank ${e.rank} yet`);o=ku(e,t,n,r,a,s)}return o}function cw(e,t,n,r,a=.001){return wa.arraysEqual(r.slice().sort(),vg(0,e.rank-1))?function(e,t,n,r,a=.001){return gi((()=>{const s=gd(e,r),o=s.mean,i=s.variance;return[uw(e,o,i,n,t,a),o,i]}))}(e,t,n,r,a):function(e,t,n,r,a=.001){return gi((()=>{const s=gd(e,r),o=s.mean,i=s.variance,l=[];for(const t of vg(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=du(o,l),c=du(i,l),d=null==t?null:du(t,l),h=null==n?null:du(n,l);return[uw(e,u,c,h,d,a),o,i]}))}(e,t,n,r,a)}lw.className="AlphaDropout",gl.registerClass(lw);var dw=class extends vy{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=oy(e.betaInitializer||"zeros"),this.gammaInitializer=oy(e.gammaInitializer||"ones"),this.movingMeanInitializer=oy(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=oy(e.movingVarianceInitializer||"ones"),this.betaConstraint=Uy(e.betaConstraint),this.gammaConstraint=Uy(e.gammaConstraint),this.betaRegularizer=tv(e.betaRegularizer),this.gammaRegularizer=tv(e.gammaRegularizer)}build(e){e=cy(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new TA(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ay({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return gi((()=>{const n=null!=t.training&&t.training,r=uy(e),a=r.shape,s=a.length,o=vg(0,s),i=this.axis>=0?this.axis:this.axis+s;o.splice(i,1);const l=$A(1,s);l[i]=a[i];const u=o.slice();u.sort();const c=!wa.arraysEqual(u,vg(0,s).slice(0,s-1));if(!n)return(()=>{if(c){const e=du(this.movingMean.read(),l),t=du(this.movingVariance.read(),l),n=this.center?du(this.beta.read(),l):null,a=this.scale?du(this.gamma.read(),l):null;return uw(r,e,t,n,a,this.epsilon)}return uw(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=cw(r,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(e,t,n)=>{gi((()=>{const r=1-n,a=e.read(),s=zl(Zc(a,t),r);e.write(Zc(a,s))}))};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:sy(this.betaInitializer),gammaInitializer:sy(this.gammaInitializer),movingMeanInitializer:sy(this.movingMeanInitializer),movingVarianceInitializer:sy(this.movingVarianceInitializer),betaRegularizer:Qb(this.betaRegularizer),gammaRegularizer:Qb(this.gammaRegularizer),betaConstraint:By(this.betaConstraint),gammaConstraint:By(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};dw.className="BatchNormalization",gl.registerClass(dw);var hw=class extends vy{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=oy(e.betaInitializer||"zeros"),this.gammaInitializer=oy(e.gammaInitializer||"ones"),this.betaRegularizer=tv(e.betaRegularizer),this.gammaRegularizer=tv(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=cy(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(const e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==GA(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,true):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,true):this.beta=null,this.built=!0}call(e,t){const n=uy(e),r=n.shape,a=r.length;return gi((()=>{let{mean:e,variance:t}=gd(n,this.axis,!0);const s=$A(1,a);for(const e of this.axis)s[e]=r[e];const o=e=>null!=e&&e.shape.length!==a?du(e,s):e;let i=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null;const u=[],c=[];for(let e=0;e<a;++e)-1!==this.axis.indexOf(e)?(u.push(r[e]),c.push(1)):(u.push(1),c.push(r[e]));return e=Sc(e,u),t=Sc(t,u),null!=i&&(i=Sc(i,c)),null!=l&&(l=Sc(l,c)),uw(n,e,t,l,i,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:sy(this.betaInitializer),gammaInitializer:sy(this.gammaInitializer),betaRegularizer:Qb(this.betaRegularizer),gammaRegularizer:Qb(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};hw.className="LayerNormalization",gl.registerClass(hw);var pw=class extends vy{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new TA(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new TA(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new TA(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Ay({ndim:4})]}computeOutputShape(e){let t,n;return e=cy(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return gi((()=>{return t=uy(e),n=this.padding,r=this.dataFormat,gi((()=>{if(4!==t.rank)throw new TA(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new TA("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new TA(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],kd(t,e)}));var t,n,r}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function fw(e,t,n,r,a,s){return gi((()=>{let o;lg(a),cg(s),ug(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=dv(e,a);const i="same"===r?"same":"valid";return o="max"===s?od(e,t,n,i):hu(e,t,n,i),"channelsFirst"===a&&(o=$i(o,[0,3,1,2])),o}))}function mw(e,t,n,r,a,s){return gi((()=>{let o;lg(a),cg(s),ug(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=hv(e,a);const i="same"===r?"same":"valid";return o="max"===s?id(e,t,n,i):pu(e,t,n,i),"channelsFirst"===a&&(o=$i(o,[0,4,1,2,3])),o}))}pw.className="ZeroPadding2D",gl.registerClass(pw);var Aw=class extends vy{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new TA(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(KA(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new TA(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}KA(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,ug(this.padding),this.inputSpec=[new Ay({ndim:3})]}computeOutputShape(e){const t=uv((e=cy(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return gi((()=>{this.invokeCallHook(e,t),e=Sg(uy(e),2);const n=this.poolingFunction(uy(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ph(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},gw=class extends Aw{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return lg(a),ug(r),fw(e,t,n,r,a,"max")}};gw.className="MaxPooling1D",gl.registerClass(gw);var yw=class extends Aw{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return lg(a),ug(r),fw(e,t,n,r,a,"avg")}};yw.className="AveragePooling1D",gl.registerClass(yw);var xw=class extends vy{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new TA(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];KA(this.poolSize,"poolSize"),KA(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,lg(this.dataFormat),ug(this.padding),this.inputSpec=[new Ay({ndim:4})]}computeOutputShape(e){e=cy(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=uv(t,this.poolSize[0],this.padding,this.strides[0]),n=uv(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return gi((()=>(this.invokeCallHook(e,t),this.poolingFunction(uy(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},bw=class extends xw{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return lg(a),ug(r),fw(e,t,n,r,a,"max")}};bw.className="MaxPooling2D",gl.registerClass(bw);var vw=class extends xw{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return lg(a),ug(r),fw(e,t,n,r,a,"avg")}};vw.className="AveragePooling2D",gl.registerClass(vw);var ww=class extends vy{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new TA(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];KA(this.poolSize,"poolSize"),KA(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,lg(this.dataFormat),ug(this.padding),this.inputSpec=[new Ay({ndim:5})]}computeOutputShape(e){e=cy(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=uv(t,this.poolSize[0],this.padding,this.strides[0]),n=uv(n,this.poolSize[1],this.padding,this.strides[1]),r=uv(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return gi((()=>(this.invokeCallHook(e,t),this.poolingFunction(uy(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},kw=class extends ww{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return lg(a),ug(r),mw(e,t,n,r,a,"max")}};kw.className="MaxPooling3D",gl.registerClass(kw);var Sw=class extends ww{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return lg(a),ug(r),mw(e,t,n,r,a,"avg")}};Sw.className="AveragePooling3D",gl.registerClass(Sw);var Iw=class extends vy{constructor(e){super(e),this.inputSpec=[new Ay({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new RA}},Cw=class extends Iw{constructor(e){super(e||{})}call(e,t){return gi((()=>{const t=uy(e);return cd(t,1)}))}};Cw.className="GlobalAveragePooling1D",gl.registerClass(Cw);var Ew=class extends Iw{constructor(e){super(e||{})}call(e,t){return gi((()=>{const t=uy(e);return dc(t,1)}))}};Ew.className="GlobalMaxPooling1D",gl.registerClass(Ew);var Nw=class extends vy{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,lg(this.dataFormat),this.inputSpec=[new Ay({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new RA}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Tw=class extends Nw{call(e,t){return gi((()=>{const t=uy(e);return"channelsLast"===this.dataFormat?cd(t,[1,2]):cd(t,[2,3])}))}};Tw.className="GlobalAveragePooling2D",gl.registerClass(Tw);var Rw=class extends Nw{call(e,t){return gi((()=>{const t=uy(e);return"channelsLast"===this.dataFormat?dc(t,[1,2]):dc(t,[2,3])}))}};Rw.className="GlobalMaxPooling2D",gl.registerClass(Rw);var _w=class extends vy{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=wx(t.layer,n);delete t.layer;const a={layer:r};return Object.assign(a,t),new e(a)}},Mw=class extends _w{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=cy(e)).length<3)throw new TA(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=cy(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return gi((()=>Ev(((e,n)=>[uy(this.layer.call(e,t)),[]]),e=uy(e),[],!1,null,null,!1,!0)[1]))}};Mw.className="TimeDistributed",gl.registerClass(Mw);var $w=class extends _w{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=wx(n),t.goBackwards=!0!==t.goBackwards;const r={};var a;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=wx(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,a=this.mergeMode,qA(og,"BidirectionalMergeMode",a),e.weights)throw new RA("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),t=a[0]):t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):DA(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=Cv(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const s=[],o=[];if(null!=n){const e=n.length;if(e%2>0)throw new TA("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);const r=n.map((e=>new Ay({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),o.push(...r)}if(null!=r)throw new RA("Support for constants in Bidirectional layers is not implemented yet.");const i=s[0]instanceof gy;for(const e of s)if(e instanceof gy!==i)throw new TA("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[e].concat(s),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;const i=super.apply(n,t);return this.inputSpec=a,i}return super.apply(e,t)}call(e,t){return gi((()=>{const n=t.initialState;let r,a,s,o;if(null==n)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:s})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:o}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=Vd(a,1)),"concat"===this.mergeMode?o=Ng([r,a]):"sum"===this.mergeMode?o=Fl(r,a):"ave"===this.mergeMode?o=zl(.5,Fl(r,a)):"mul"===this.mergeMode?o=zl(r,a):null==this.mergeMode&&(o=[r,a]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){hg(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),hg(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=wx(t.layer);if(delete t.layer,null!=t.numConstants)throw new RA("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}};function Fw(e){return new ky(e)}function Ow(e){return new sv(e)}function Dw(e){return new nv(e)}function zw(e){return new rv(e)}function Pw(e){return new av(e)}function Lw(e){return new iv(e)}function Bw(e){return new ov(e)}function Ww(e){return new wv(e)}function Uw(e){return new Av(e)}function Vw(e){return new yv(e)}function jw(e){return new gv(e)}function Gw(e){return new xv(e)}function Hw(e){return new vv(e)}function qw(e){return new kv(e)}function Xw(e){return new Sv(e)}function Kw(e){return new Iv(e)}function Zw(e){return new Gv(e)}function Yw(e){return new Vv(e)}function Jw(e){return new Wv(e)}function Qw(e){return new Uv(e)}function ek(e){return new jv(e)}function tk(e){return new Hv(e)}function nk(e){return new qv(e)}function rk(e){return new Xv(e)}function ak(e){return new Zv(e)}function sk(e){return new Jv(e)}function ok(e){return new ew(e)}function ik(e){return new rw(e)}function lk(e){return new tw(e)}function uk(e){return new nw(e)}function ck(e){return new Qv(e)}function dk(e){return new sw(e)}function hk(e){return new dw(e)}function pk(e){return new hw(e)}function fk(e){return new pw(e)}function mk(e){return new yw(e)}function Ak(e){return mk(e)}function gk(e){return mk(e)}function yk(e){return new vw(e)}function xk(e){return yk(e)}function bk(e){return yk(e)}function vk(e){return new Sw(e)}function wk(e){return vk(e)}function kk(e){return vk(e)}function Sk(e){return new Cw(e)}function Ik(e){return new Tw(e)}function Ck(e){return new Ew(e)}function Ek(e){return new Rw(e)}function Nk(e){return new gw(e)}function Tk(e){return new bw(e)}function Rk(e){return new kw(e)}function _k(e){return new $v(e)}function Mk(e){return new Mv(e)}function $k(e){return new Ov(e)}function Fk(e){return new Fv(e)}function Ok(e){return new _v(e)}function Dk(e){return new Rv(e)}function zk(e){return new Bv(e)}function Pk(e){return new Lv(e)}function Lk(e){return new Nv(e)}function Bk(e){return new Dv(e)}function Wk(e){return new $w(e)}function Uk(e){return new Mw(e)}$w.className="Bidirectional",gl.registerClass($w);var Vk=Ck,jk=Ek,Gk=Nk,Hk=Tk;function qk(e){return new ow(e)}function Xk(e){return new iw(e)}function Kk(e){return new lw(e)}function Zk(e){return new Kv(e)}var Yk={};function Jk(e,t){return $x(e,t)}function Qk(e,t){return Px(e,t)}function eS(e,t){return Lx(e,t)}function tS(e,t){return Fx(e,t)}function nS(e,t){return Bx(e,t)}function rS(e,t){return Dx(e,t)}function aS(e,t){return zx(e,t)}function sS(e,t){return Rx(e,t)}function oS(e,t){return Ix(e,t)}function iS(e,t){return Cx(e,t)}function lS(e,t){return Cx(e,t)}function uS(e,t){return Cx(e,t)}function cS(e,t){return Sx(e,t)}function dS(e,t){return Sx(e,t)}function hS(e,t){return Sx(e,t)}S(Yk,{MAPE:()=>lS,MSE:()=>dS,binaryAccuracy:()=>Jk,binaryCrossentropy:()=>Qk,categoricalAccuracy:()=>tS,categoricalCrossentropy:()=>nS,cosineProximity:()=>sS,mape:()=>uS,meanAbsoluteError:()=>oS,meanAbsolutePercentageError:()=>iS,meanSquaredError:()=>cS,mse:()=>hS,precision:()=>rS,recall:()=>aS,sparseCategoricalAccuracy:()=>eS});var pS={};S(pS,{modelFromJSON:()=>kb});var fS={};function mS(e){return new Yb(e)}function AS(e){return Kb(t=e),new Yb({l1:null!=t?t.l1:null,l2:0});var t}function gS(e){return Kb(t=e),new Yb({l2:null!=t?t.l2:null,l1:0});var t}S(fS,{l1:()=>AS,l1l2:()=>mS,l2:()=>gS});var yS=class extends fx{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof vb))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function xS(e,t){return e<t}function bS(e,t){return e>t}var vS=class extends yS{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new RA("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=xS:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=bS:this.monitorFunc=xS,this.monitorFunc===xS&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===xS?1/0:-1/0}async onEpochEnd(e,t){await hx(t);const n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});const t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};var wS,kS,SS,IS={earlyStopping:function(e){return new vS(e)}};qe().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),(kS=wS||(wS={}))[kS.DT_INVALID=0]="DT_INVALID",kS[kS.DT_FLOAT=1]="DT_FLOAT",kS[kS.DT_DOUBLE=2]="DT_DOUBLE",kS[kS.DT_INT32=3]="DT_INT32",kS[kS.DT_UINT8=4]="DT_UINT8",kS[kS.DT_INT16=5]="DT_INT16",kS[kS.DT_INT8=6]="DT_INT8",kS[kS.DT_STRING=7]="DT_STRING",kS[kS.DT_COMPLEX64=8]="DT_COMPLEX64",kS[kS.DT_INT64=9]="DT_INT64",kS[kS.DT_BOOL=10]="DT_BOOL",kS[kS.DT_QINT8=11]="DT_QINT8",kS[kS.DT_QUINT8=12]="DT_QUINT8",kS[kS.DT_QINT32=13]="DT_QINT32",kS[kS.DT_BFLOAT16=14]="DT_BFLOAT16",kS[kS.DT_QINT16=15]="DT_QINT16",kS[kS.DT_QUINT16=16]="DT_QUINT16",kS[kS.DT_UINT16=17]="DT_UINT16",kS[kS.DT_COMPLEX128=18]="DT_COMPLEX128",kS[kS.DT_HALF=19]="DT_HALF",kS[kS.DT_RESOURCE=20]="DT_RESOURCE",kS[kS.DT_VARIANT=21]="DT_VARIANT",kS[kS.DT_UINT32=22]="DT_UINT32",kS[kS.DT_UINT64=23]="DT_UINT64",kS[kS.DT_FLOAT_REF=101]="DT_FLOAT_REF",kS[kS.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",kS[kS.DT_INT32_REF=103]="DT_INT32_REF",kS[kS.DT_UINT8_REF=104]="DT_UINT8_REF",kS[kS.DT_INT16_REF=105]="DT_INT16_REF",kS[kS.DT_INT8_REF=106]="DT_INT8_REF",kS[kS.DT_STRING_REF=107]="DT_STRING_REF",kS[kS.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",kS[kS.DT_INT64_REF=109]="DT_INT64_REF",kS[kS.DT_BOOL_REF=110]="DT_BOOL_REF",kS[kS.DT_QINT8_REF=111]="DT_QINT8_REF",kS[kS.DT_QUINT8_REF=112]="DT_QUINT8_REF",kS[kS.DT_QINT32_REF=113]="DT_QINT32_REF",kS[kS.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",kS[kS.DT_QINT16_REF=115]="DT_QINT16_REF",kS[kS.DT_QUINT16_REF=116]="DT_QUINT16_REF",kS[kS.DT_UINT16_REF=117]="DT_UINT16_REF",kS[kS.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",kS[kS.DT_HALF_REF=119]="DT_HALF_REF",kS[kS.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",kS[kS.DT_VARIANT_REF=121]="DT_VARIANT_REF",kS[kS.DT_UINT32_REF=122]="DT_UINT32_REF",kS[kS.DT_UINT64_REF=123]="DT_UINT64_REF",function(e){let t;var n;(n=t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"}(SS||(SS={}));var CS={};function ES(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};CS[e]=n}function NS(e){return CS[e]}function TS(e){delete CS[e]}function RS(e,t,n,r,a){const s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){const e=s.inputIndexStart,o=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd;if("tensor"===s.type)return _S(t.inputNames[s.inputIndexStart],n,r,a);if("tensors"===s.type){return t.inputNames.slice(e,o).map((e=>_S(e,n,r,a)))}const i=_S(t.inputNames.slice(e)[0],n,r,a),l=i.dataSync();return"number"===s.type?l[0]:wa.toNestedArray(i.shape,l)}const o=t.attrParams[e];return o&&o.value}function _S(e,t,n,r){const[a,s]=FS(e);if(null!=r){const e=r.getHashTableHandleByName(a);if(null!=e)return e}const o=n.currentContextIds.find((e=>!!t[$S(a,e)]));return void 0!==o?t[$S(a,o)][s]:void 0}function MS(e,t){const[n,r,a]=FS(e);return[$S(n,t&&t.currentContextId),r,a]}function $S(e,t){return t?`${e}-${t}`:e}function FS(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=t[0],r=3===t.length?t[1]:void 0;return[n,Number(t[t.length-1]),r]}function OS(e,t,n){let r=RS("pad",e,t,n);if("explicit"===r){r=RS("explicitPaddings",e,t,n);const a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function DS(e){return e.kept?e:Po(e)}var zS={};S(zS,{json:()=>PS});var PS=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],LS={};S(LS,{json:()=>BS});var BS=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],WS={};S(WS,{json:()=>US});var US=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],VS={};S(VS,{json:()=>jS});var jS=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],GS={};S(GS,{json:()=>HS});var HS=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],qS={};S(qS,{json:()=>XS});var XS=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],KS={};S(KS,{json:()=>ZS});var ZS=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],YS={};S(YS,{json:()=>JS});var JS=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],QS={};S(QS,{json:()=>eI});var eI=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],tI={};S(tI,{json:()=>nI});var nI=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],rI={};S(rI,{json:()=>aI});var aI=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],sI={};S(sI,{json:()=>oI});var oI=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],iI={};S(iI,{json:()=>lI});var lI=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],uI={};S(uI,{json:()=>cI});var cI=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],dI={};S(dI,{json:()=>hI});var hI=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],pI={};S(pI,{json:()=>fI});var fI=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],mI={};S(mI,{json:()=>AI});var AI=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],gI={};S(gI,{json:()=>yI});var yI=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],xI={};S(xI,{json:()=>bI});var bI=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],vI=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[zS,LS,WS,VS,GS,qS,KS,YS,QS,tI,rI,sI,iI,uI,dI,pI,mI,gI,xI].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const n=e.node,r=[],a=[],s=[],o=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e)),{});let i=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(o);d.forEach((e=>{const t=o[e];t.inputNames.forEach(((e,n)=>{const[r,,a]=MS(e),s=o[r];if(null!=s.outputs){const e=s.outputs.indexOf(a);if(-1!==e){const a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{const t=o[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{const[t]=MS(e),n=o[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{const[t]=MS(e),n=o[t];n&&(n.signatureKey=u[e],i.push(n))})):i=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:o,inputs:i,outputs:l,weights:a,placeholders:r,signature:t,functions:h};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=NS(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let a;switch(n.type){case"string":a=kI(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=kI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":a=$I(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=$I(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":a=II(e.attr,n.tfName,n.defaultValue||0),void 0===a&&n.tfDeprecatedName&&(a=II(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":a=MI(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=MI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":a=SI(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=SI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":a=OI(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=OI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":a=_I(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=_I(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":a=FI(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=FI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":a=NI(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=NI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":a=TI(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=TI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":a=EI(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=EI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:a,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const a=[],s=[];e.signature.inputArg.forEach((e=>{const[t]=MS(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:CI(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[a,,s]=MS(e),o=r[a];if(null!=o.outputs){const e=o.outputs.indexOf(s);if(-1!==e){const r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(o),o.children.push(t)}))}));const o=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=MS(o[e.name]),a=r[t];null!=a&&(a.defaultOutput=n,s.push(a))}));const i=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:s,weights:n,placeholders:[],signature:i}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function wI(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=qe().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function kI(e,t,n,r=!1){const a=e[t];return null!=a?wI(a.s,r):n}function SI(e,t,n){const r=e[t];return r?r.b:n}function II(e,t,n){const r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function CI(e){switch("string"==typeof e&&(e=wS[e]),e){case wS.DT_FLOAT:case wS.DT_HALF:return"float32";case wS.DT_INT32:case wS.DT_INT64:case wS.DT_INT8:case wS.DT_UINT8:return"int32";case wS.DT_BOOL:return"bool";case wS.DT_DOUBLE:return"float32";case wS.DT_STRING:return"string";default:return null}}function EI(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function NI(e,t,n){const r=e[t];return r&&r.type?CI(r.type):n}function TI(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>CI(e))):n}function RI(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function _I(e,t,n){const r=e[t];return r&&r.shape?RI(r.shape):n}function MI(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function $I(e,t,n,r=!1){const a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>wI(e,r))):n}function FI(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>RI(e))):n}function OI(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var DI={};S(DI,{OP_SCOPE_SUFFIX:()=>Ps,abs:()=>Pl,acos:()=>Ll,acosh:()=>Bl,add:()=>Fl,addN:()=>Wl,all:()=>Ul,any:()=>Vl,argMax:()=>jl,argMin:()=>Gl,asin:()=>Hl,asinh:()=>ql,atan:()=>Xl,atan2:()=>Kl,atanh:()=>Zl,avgPool:()=>hu,avgPool3d:()=>pu,basicLSTMCell:()=>yu,batchNorm:()=>bu,batchNorm2d:()=>vu,batchNorm3d:()=>wu,batchNorm4d:()=>ku,batchToSpaceND:()=>xu,bincount:()=>Su,booleanMaskAsync:()=>Mh,broadcastArgs:()=>Iu,broadcastTo:()=>Cu,buffer:()=>Do,cast:()=>zo,ceil:()=>Eu,clipByValue:()=>Nu,clone:()=>Po,complex:()=>Bs,concat:()=>fu,concat1d:()=>Tu,concat2d:()=>Ru,concat3d:()=>_u,concat4d:()=>Mu,conv1d:()=>Fu,conv2d:()=>$u,conv2dTranspose:()=>Du,conv3d:()=>zu,conv3dTranspose:()=>Lu,cos:()=>Bu,cosh:()=>Wu,cosineWindow:()=>Lh,cumprod:()=>Uu,cumsum:()=>Vu,denseBincount:()=>ju,depthToSpace:()=>Gu,depthwiseConv2d:()=>Hu,diag:()=>qu,dilation2d:()=>Xu,div:()=>Dl,divNoNan:()=>Ju,dot:()=>Qu,dropout:()=>zh,einsum:()=>ec,elu:()=>tc,enclosingPowerOfTwo:()=>Ph,equal:()=>Ku,erf:()=>nc,euclideanNorm:()=>bc,exp:()=>vc,expandDims:()=>wc,expm1:()=>kc,eye:()=>Ic,fft:()=>ih,fill:()=>Cc,floor:()=>Ec,floorDiv:()=>Ol,fused:()=>Wh,gather:()=>Nc,gatherND:()=>Dh,greater:()=>Tc,greaterEqual:()=>Rc,ifft:()=>lh,imag:()=>Ri,image:()=>Zp,inTopKAsync:()=>Bh,irfft:()=>uh,isFinite:()=>_c,isInf:()=>Mc,isNaN:()=>$c,leakyRelu:()=>Fc,less:()=>Oc,lessEqual:()=>Dc,linalg:()=>Yp,linspace:()=>zc,localResponseNormalization:()=>Pc,log:()=>Lc,log1p:()=>Bc,logSigmoid:()=>Kc,logSoftmax:()=>Yc,logSumExp:()=>Jc,logicalAnd:()=>Qc,logicalNot:()=>ed,logicalOr:()=>td,logicalXor:()=>nd,losses:()=>Jp,lowerBound:()=>sd,matMul:()=>ii,max:()=>dc,maxPool:()=>od,maxPool3d:()=>id,maxPoolWithArgmax:()=>ld,maximum:()=>ud,mean:()=>cd,meshgrid:()=>pd,min:()=>hc,minimum:()=>fd,mirrorPad:()=>md,mod:()=>Ad,moments:()=>gd,movingAverage:()=>$h,mul:()=>zl,multiRNNCell:()=>yd,multinomial:()=>xd,neg:()=>_i,norm:()=>xc,notEqual:()=>bd,oneHot:()=>li,ones:()=>hd,onesLike:()=>vd,op:()=>Ls,outerProduct:()=>wd,pad:()=>kd,pad1d:()=>Sd,pad2d:()=>Id,pad3d:()=>Cd,pad4d:()=>Ed,pool:()=>Td,pow:()=>pc,prelu:()=>Rd,print:()=>Lo,prod:()=>_d,rand:()=>Md,randomGamma:()=>Od,randomNormal:()=>Dd,randomStandardNormal:()=>zd,randomUniform:()=>Pd,range:()=>Ld,real:()=>Mi,reciprocal:()=>Bd,relu:()=>Wd,relu6:()=>Ud,reshape:()=>du,reverse:()=>Vd,reverse1d:()=>jd,reverse2d:()=>Gd,reverse3d:()=>Hd,reverse4d:()=>qd,rfft:()=>dh,round:()=>Xd,rsqrt:()=>Kd,scalar:()=>fc,scatterND:()=>Fh,searchSorted:()=>ad,selu:()=>Zd,separableConv2d:()=>Yd,setdiff1dAsync:()=>Jd,sigmoid:()=>mu,sign:()=>Qd,signal:()=>Kp,sin:()=>eh,sinh:()=>th,slice:()=>Au,slice1d:()=>nh,slice2d:()=>rh,slice3d:()=>ah,slice4d:()=>sh,softmax:()=>oh,softplus:()=>Xc,spaceToBatchND:()=>Nd,sparse:()=>Qp,sparseToDense:()=>Oh,spectral:()=>Xp,split:()=>ch,sqrt:()=>mc,square:()=>Ac,squaredDifference:()=>hh,squeeze:()=>ph,stack:()=>fh,step:()=>mh,stridedSlice:()=>Ah,string:()=>ef,sub:()=>Zc,sum:()=>gc,tan:()=>gh,tanh:()=>gu,tensor:()=>Us,tensor1d:()=>yh,tensor2d:()=>xh,tensor3d:()=>Wi,tensor4d:()=>bh,tensor5d:()=>vh,tensor6d:()=>wh,tile:()=>Sc,topk:()=>kh,transpose:()=>$i,truncatedNormal:()=>Sh,unique:()=>Ih,unsortedSegmentSum:()=>Ch,unstack:()=>Eh,upperBound:()=>Nh,variable:()=>Th,where:()=>Zu,whereAsync:()=>_h,zeros:()=>dd,zerosLike:()=>Yu});function zI(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){wa.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const a=e[r],s=t[r];wa.assert(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function PI(e){return"number"!=typeof e&&!e.some((e=>e<0))}function LI(e,t,n){let r=BI(e,n);const a=!PI(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=BI(e.shape,r)})),!PI(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function BI(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var WI=class{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);zI(t,e.shape,"TensorList shape mismatch: "),xi(e)})),this.idTensor=fc(0),this.maxNumElements=r,xi(this.idTensor)}get id(){return this.idTensor.id}copy(){return new WI([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);zI(e,this.elementShape,"TensorList shape mismatch: ");const r=LI(this.elementShape,this.tensors,e);return gi((()=>{const e=this.tensors.map((e=>du(e,r)));return fh(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=LI(this.elementShape,this.tensors,e),r=this.tensors.pop();return zI(r.shape,e,"TensorList shape mismatch: "),du(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(zI(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");xi(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new WI([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);zI(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=LI(this.elementShape,this.tensors,t);return du(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);zI(this.elementShape,t.shape,"TensorList shape mismatch: "),xi(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);zI(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=LI(this.elementShape,this.tensors,n);return 0===e.length?Us([],[0].concat(r)):gi((()=>{const t=e.map((e=>du(this.tensors[e],r)));return fh(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);zI(this.elementShape,t,"TensorList shape mismatch: ");const n=LI(this.elementShape,this.tensors,t);return 0===this.size()?Us([],[0].concat(n)):gi((()=>{const e=this.tensors.map((e=>du(e,n)));return fu(e,0)}))}};var UI=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=RS("thenBranch",e,t,n),a=RS("elseBranch",e,t,n),s=RS("cond",e,t,n),o=RS("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=RS("body",e,t,n),a=RS("cond",e,t,n),s=RS("args",e,t,n),o=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),i=s.map((e=>e.id));let l=await o[0].data();o.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||e.dispose()}));let u=s;for(;l[0];){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":return[DS(RS("pred",e,t,n))];case"Switch":{const r=RS("pred",e,t,n);let a=RS("data",e,t,n);return a.kept||(a=DS(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==_S(e,t,n)));if(r){return[DS(_S(r,t,n))]}return}case"Enter":{const r=RS("frameName",e,t,n),a=RS("tensor",e,t,n);return n.enterFrame(r),[DS(a)]}case"Exit":{const r=RS("tensor",e,t,n);return n.exitFrame(),[DS(r)]}case"NextIteration":{const r=RS("tensor",e,t,n);return n.nextIteration(),[DS(r)]}case"TensorArrayV3":{const r=RS("size",e,t,n),a=RS("dtype",e,t,n),s=RS("elementShape",e,t,n),o=RS("dynamicSize",e,t,n),i=RS("clearAfterRead",e,t,n),l=RS("identicalElementShapes",e,t,n),u=RS("name",e,t,n),c=new class{constructor(e,t,n,r,a,s,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=fc(0),xi(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),zI(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,xi(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Us([],[0].concat(this.elementShape));const n=this.readMany(e);return zI(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),fh(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Us([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const n=this.readMany(t);return zI(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),fu(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Eh(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=0===n?0:t.size/n,s=[];gi((()=>{t=du(t,[1,n,a]);for(let n=0;n<e.length;++n){const o=[0,0===n?0:r[n-1],0],i=[1,e[n],a];s[n]=du(Au(t,o,i),this.elementShape)}return s}));const o=[];for(let t=0;t<e.length;t++)o[t]=t;this.writeMany(o,s)}}(u,a,r,s,l,o,i);return n.addTensorArray(c),[c.idTensor,fc(1)]}case"TensorArrayWriteV3":{const r=RS("tensorArrayId",e,t,n),a=RS("index",e,t,n),s=RS("tensor",e,t,n),o=n.getTensorArray(r.id);return o.write(a,s),[o.idTensor]}case"TensorArrayReadV3":{const r=RS("tensorArrayId",e,t,n),a=RS("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{const r=RS("tensorArrayId",e,t,n),a=RS("indices",e,t,n),s=RS("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{const r=RS("tensorArrayId",e,t,n),a=RS("indices",e,t,n),s=RS("tensor",e,t,n),o=n.getTensorArray(r.id);return o.scatter(a,s),[o.idTensor]}case"TensorArrayConcatV3":{const r=RS("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=RS("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{const r=RS("tensorArrayId",e,t,n),a=RS("tensor",e,t,n),s=RS("lengths",e,t,n),o=n.getTensorArray(r.id);return o.split(s,a),[o.idTensor]}case"TensorArraySizeV3":{const r=RS("tensorArrayId",e,t,n);return[fc(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=RS("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const r=RS("tensorListId",e,t,n),a=RS("index",e,t,n),s=RS("tensor",e,t,n),o=n.getTensorList(r.id);return o.setItem(a,s),[o.idTensor]}case"TensorListGetItem":{const r=RS("tensorListId",e,t,n),a=RS("index",e,t,n),s=RS("elementShape",e,t,n),o=RS("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=RS("indices",e,t,n),a=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);const s=new WI([],n,e.dtype,r),o=Eh(e,0);return t.forEach(((e,t)=>{s.setItem(e,o[t])})),s}(RS("tensor",e,t,n),r,RS("elementShape",e,t,n),RS("numElements",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=RS("elementShape",e,t,n),a=RS("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=RS(s,e,t,n),i=function(e,t,n,r){return new WI([],e,t,r)}(r,a,0,"TensorListReserve"===e.op?-1:o);return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const r=RS("tensorListId",e,t,n),a=RS("indices",e,t,n),s=RS("elementShape",e,t,n),o=RS("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,o,s)]}case"TensorListStack":{const r=RS("tensorListId",e,t,n),a=RS("elementShape",e,t,n),s=RS("elementDType",e,t,n),o=RS("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,o)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);zI(e.shape.slice(1),t,"TensorList shape mismatch: ");const a=Eh(e);return new WI(a,t,r)}(RS("tensor",e,t,n),RS("elementShape",e,t,n),RS("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=RS("tensorListId",e,t,n),a=n.getTensorList(r.id),s=RS("dtype",e,t,n),o=RS("elementShape",e,t,n);return[a.concat(s,o)]}case"TensorListPushBack":{const r=RS("tensorListId",e,t,n),a=RS("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{const r=RS("tensorListId",e,t,n),a=RS("elementShape",e,t,n),s=RS("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{const r=RS("tensor",e,t,n),a=RS("elementShape",e,t,n),s=function(e,t,n){let r=0;const a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const s=BI(e.shape.slice(1),n),o=0===r?0:e.size/r,i=gi((()=>{const n=[];e=du(e,[1,r,o]);for(let r=0;r<t.length;++r){const i=[0,0===r?0:a[r-1],0],l=[1,t[r],o];n[r]=du(Au(e,i,l),s)}return e.dispose(),n})),l=new WI([],n,e.dtype,t.length);for(let e=0;e<i.length;e++)l.setItem(e,i[e]);return l}(r,RS("lengths",e,t,n),a);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{const r=RS("tensorListId",e,t,n);return[fc(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=RS("tensorListId",e,t,n),a=RS("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function VI(e,t,n){const[r,a]=RS("fusedOps",e,t,n),s="biasadd"===r,o=!s,i="prelu"===a,l="fusedbatchnorm"===r,u=RS("numArgs",e,t,n);if(s){if(i&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=RS("strides",e,t,n),d=OS(e,t,n),h=RS("dataFormat",e,t,n).toUpperCase(),p=RS("dilations",e,t,n);let[f,m]=RS("args",e,t,n);o&&(m=f,f=void 0);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:RS("leakyreluAlpha",e,t,n)}}function jI(e,t,n){return{boxes:RS("boxes",e,t,n),scores:RS("scores",e,t,n),maxOutputSize:RS("maxOutputSize",e,t,n),iouThreshold:RS("iouThreshold",e,t,n),scoreThreshold:RS("scoreThreshold",e,t,n),softNmsSigma:RS("softNmsSigma",e,t,n)}}var GI=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const a=RS("keyDType",e,t,n),s=RS("valueDType",e,t,n),o=new class{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=fc(0),this.tensorMap=new Map,xi(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return fc(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),gi((()=>{const e=Eh(t),r=n.length,a=e.length;wa.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){const r=n[t],a=e[t];xi(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return gi((()=>{const e=[];for(let r=0;r<n.length;r++){const a=n[r],s=this.findWithDefault(a,t);e.push(s)}return fh(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}(a,s);return r.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const a=RS("tableHandle",e,t,n,r),s=RS("keys",e,t,n),o=RS("values",e,t,n),i=r.getHashTableById(a.id);return[await i.import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const a=RS("tableHandle",e,t,n,r),s=RS("keys",e,t,n),o=RS("defaultValue",e,t,n),i=r.getHashTableById(a.id);return[await i.find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=RS("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function HI(e,t,n,r,a=gi){const s=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(RS("a",e,t,n),RS("b",e,t,n))];case"AddN":return[r.addN(RS("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(RS("a",e,t,n),RS("b",e,t,n))];case"Mul":return[r.mul(RS("a",e,t,n),RS("b",e,t,n))];case"RealDiv":case"Div":return[r.div(RS("a",e,t,n),RS("b",e,t,n))];case"DivNoNan":return[r.divNoNan(RS("a",e,t,n),RS("b",e,t,n))];case"FloorDiv":return[r.floorDiv(RS("a",e,t,n),RS("b",e,t,n))];case"Sub":return[r.sub(RS("a",e,t,n),RS("b",e,t,n))];case"Minimum":return[r.minimum(RS("a",e,t,n),RS("b",e,t,n))];case"Maximum":return[r.maximum(RS("a",e,t,n),RS("b",e,t,n))];case"Pow":return[r.pow(RS("a",e,t,n),RS("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(RS("a",e,t,n),RS("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"basic_math":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(RS("x",e,t,n))];case"Acos":return[r.acos(RS("x",e,t,n))];case"Acosh":return[r.acosh(RS("x",e,t,n))];case"Asin":return[r.asin(RS("x",e,t,n))];case"Asinh":return[r.asinh(RS("x",e,t,n))];case"Atan":return[r.atan(RS("x",e,t,n))];case"Atan2":return[r.atan2(RS("x",e,t,n),RS("y",e,t,n))];case"Atanh":return[r.atanh(RS("x",e,t,n))];case"Ceil":return[r.ceil(RS("x",e,t,n))];case"Complex":return[r.complex(RS("real",e,t,n),RS("imag",e,t,n))];case"Cos":return[r.cos(RS("x",e,t,n))];case"Cosh":return[r.cosh(RS("x",e,t,n))];case"Elu":return[r.elu(RS("x",e,t,n))];case"Erf":return[r.erf(RS("x",e,t,n))];case"Exp":return[r.exp(RS("x",e,t,n))];case"Expm1":return[r.expm1(RS("x",e,t,n))];case"Floor":return[r.floor(RS("x",e,t,n))];case"Log":return[r.log(RS("x",e,t,n))];case"Log1p":return[r.log1p(RS("x",e,t,n))];case"Imag":return[r.imag(RS("x",e,t,n))];case"Neg":return[r.neg(RS("x",e,t,n))];case"Reciprocal":return[r.reciprocal(RS("x",e,t,n))];case"Real":return[r.real(RS("x",e,t,n))];case"Relu":return[r.relu(RS("x",e,t,n))];case"Round":return[r.round(RS("x",e,t,n))];case"Selu":return[r.selu(RS("x",e,t,n))];case"Sigmoid":return[r.sigmoid(RS("x",e,t,n))];case"Sin":return[r.sin(RS("x",e,t,n))];case"Sign":return[r.sign(RS("x",e,t,n))];case"Sinh":return[r.sinh(RS("x",e,t,n))];case"Softplus":return[r.softplus(RS("x",e,t,n))];case"Sqrt":return[r.sqrt(RS("x",e,t,n))];case"Square":return[r.square(RS("x",e,t,n))];case"Tanh":return[r.tanh(RS("x",e,t,n))];case"Tan":return[r.tan(RS("x",e,t,n))];case"ClipByValue":return[r.clipByValue(RS("x",e,t,n),RS("clipValueMin",e,t,n),RS("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(RS("x",e,t,n))];case"Rsqrt":return[r.rsqrt(_S(e.inputNames[0],t,n))];case"Prod":return[r.prod(RS("x",e,t,n),RS("axes",e,t,n))];case"LeakyRelu":return[r.leakyRelu(RS("x",e,t,n),RS("alpha",e,t,n))];case"Prelu":return[r.prelu(RS("x",e,t,n),RS("alpha",e,t,n))];case"IsNan":return[r.isNaN(_S(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"control":return UI(e,t,n);case"convolution":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"Conv1D":{const a=RS("stride",e,t,n),s=RS("pad",e,t,n),o=RS("dataFormat",e,t,n).toUpperCase(),i=RS("dilation",e,t,n);return[r.conv1d(RS("x",e,t,n),RS("filter",e,t,n),a,s,o,i)]}case"Conv2D":{const a=RS("strides",e,t,n),s=OS(e,t,n),o=RS("dataFormat",e,t,n).toUpperCase(),i=RS("dilations",e,t,n);return[r.conv2d(RS("x",e,t,n),RS("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:a,pad:s,dataFormat:o,dilations:i,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=VI(e,t,n);return[r.fused.conv2d({x:RS("x",e,t,n),filter:RS("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:s,dataFormat:o,dilations:i,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=VI(e,t,n);return[r.fused.depthwiseConv2d({x:RS("x",e,t,n),filter:RS("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=RS("outputShape",e,t,n),s=RS("strides",e,t,n),o=OS(e,t,n);return[r.conv2dTranspose(RS("x",e,t,n),RS("filter",e,t,n),a,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=RS("strides",e,t,n),s=OS(e,t,n),o=RS("dilations",e,t,n),i=RS("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(RS("input",e,t,n),RS("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const a=RS("strides",e,t,n),s=RS("pad",e,t,n),o=RS("dataFormat",e,t,n).toUpperCase(),i=RS("dilations",e,t,n);return[r.conv3d(RS("x",e,t,n),RS("filter",e,t,n),[a[1],a[2],a[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const a=RS("strides",e,t,n),s=RS("pad",e,t,n),o=RS("kernelSize",e,t,n);return[r.avgPool(RS("x",e,t,n),[o[1],o[2]],[a[1],a[2]],s)]}case"MaxPool":{const a=RS("strides",e,t,n),s=RS("pad",e,t,n),o=RS("kernelSize",e,t,n);return[r.maxPool(RS("x",e,t,n),[o[1],o[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{const a=RS("strides",e,t,n),s=RS("pad",e,t,n),o=RS("kernelSize",e,t,n),i=RS("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(RS("x",e,t,n),[o[1],o[2]],[a[1],a[2]],s,i);return[l,u]}case"AvgPool3D":{const a=RS("strides",e,t,n),s=RS("pad",e,t,n),o=RS("kernelSize",e,t,n);return[r.avgPool3d(RS("x",e,t,n),[o[1],o[2],o[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{const a=RS("strides",e,t,n),s=RS("pad",e,t,n),o=RS("kernelSize",e,t,n);return[r.maxPool3d(RS("x",e,t,n),[o[1],o[2],o[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{const a=RS("strides",e,t,n),s=RS("pad",e,t,n),o=RS("dilations",e,t,n),i=a[1],l=a[2],u=o[1],c=o[2];return[r.dilation2d(RS("x",e,t,n),RS("filter",e,t,n),[i,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"creation":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"Fill":{const a=RS("shape",e,t,n),s=RS("dtype",e,t,n),o=RS("value",e,t,n);return[r.fill(a,o,s)]}case"LinSpace":{const a=RS("start",e,t,n),s=RS("stop",e,t,n),o=RS("num",e,t,n);return[r.linspace(a,s,o)]}case"Multinomial":{const a=RS("logits",e,t,n),s=RS("numSamples",e,t,n),o=RS("seed",e,t,n);return[r.multinomial(a,s,o)]}case"OneHot":{const a=RS("indices",e,t,n),s=RS("depth",e,t,n),o=RS("onValue",e,t,n),i=RS("offValue",e,t,n);return[r.oneHot(a,s,o,i)]}case"Ones":return[r.ones(RS("shape",e,t,n),RS("dtype",e,t,n))];case"OnesLike":return[r.onesLike(RS("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(RS("shape",e,t,n),RS("dtype",e,t,n),RS("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(RS("shape",e,t,n),RS("minval",e,t,n),RS("maxval",e,t,n),RS("dtype",e,t,n))];case"Range":{const a=RS("start",e,t,n),s=RS("stop",e,t,n),o=RS("step",e,t,n);return[r.range(a,s,o,RS("dtype",e,t,n))]}case"TruncatedNormal":{const a=RS("shape",e,t,n),s=RS("mean",e,t,n),o=RS("stdDev",e,t,n),i=RS("seed",e,t,n);return[r.truncatedNormal(a,s,o,RS("dtype",e,t,n),i)]}case"Zeros":return[r.zeros(RS("shape",e,t,n),RS("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(RS("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"dynamic":return(async(e,t,n,r,a=DI)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=jI(e,t,n),c=await a.image.nonMaxSuppressionWithScoreAsync(r,s,o,i,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=jI(e,t,n),u=RS("padToMaxOutputSize",e,t,n),c=await a.image.nonMaxSuppressionPaddedAsync(r,s,o,i,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=jI(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,s,o,i,l)]}case"Where":{const r=a.cast(RS("condition",e,t,n),"bool"),s=[await a.whereAsync(r)];return r.dispose(),s}case"ListDiff":return a.setdiff1dAsync(RS("x",e,t,n),RS("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"LowerBound":{const a=RS("sortedSequence",e,t,n),s=RS("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{const a=RS("x",e,t,n),s=RS("k",e,t,n),o=RS("sorted",e,t,n),i=r.topk(a,s,o);return[i.values,i.indices]}case"UpperBound":{const a=RS("sortedSequence",e,t,n),s=RS("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{const a=RS("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{const a=RS("x",e,t,n),s=RS("axis",e,t,n),o=r.unique(a,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"image":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"ResizeBilinear":{const a=RS("images",e,t,n),s=RS("size",e,t,n),o=RS("alignCorners",e,t,n),i=RS("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const a=RS("images",e,t,n),s=RS("size",e,t,n),o=RS("alignCorners",e,t,n),i=RS("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],o,i)]}case"CropAndResize":{const a=RS("image",e,t,n),s=RS("boxes",e,t,n),o=RS("boxInd",e,t,n),i=RS("cropSize",e,t,n),l=RS("method",e,t,n),u=RS("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,o,i,l,u)]}case"ImageProjectiveTransformV3":{const a=RS("images",e,t,n),s=RS("transforms",e,t,n),o=RS("outputShape",e,t,n),i=RS("fillValue",e,t,n),l=RS("interpolation",e,t,n),u=RS("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"graph":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const a=RS("default",e,t,n);return[_S(e.name,t,n)||a];case"Placeholder":return[_S(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[DS(RS("x",e,t,n))];case"IdentityN":return RS("x",e,t,n).map((e=>DS(e)));case"Shape":return[r.tensor1d(RS("x",e,t,n).shape,"int32")];case"ShapeN":return RS("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(RS("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(RS("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const s=RS("x",e,t,n),o=RS("data",e,t,n),i=RS("message",e,t,n),l=RS("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"logical":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"Equal":return[r.equal(RS("a",e,t,n),RS("b",e,t,n))];case"NotEqual":return[r.notEqual(RS("a",e,t,n),RS("b",e,t,n))];case"Greater":return[r.greater(RS("a",e,t,n),RS("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(RS("a",e,t,n),RS("b",e,t,n))];case"Less":return[r.less(RS("a",e,t,n),RS("b",e,t,n))];case"LessEqual":return[r.lessEqual(RS("a",e,t,n),RS("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(RS("a",e,t,n),RS("b",e,t,n))];case"LogicalNot":return[r.logicalNot(RS("a",e,t,n))];case"LogicalOr":return[r.logicalOr(RS("a",e,t,n),RS("b",e,t,n))];case"Select":case"SelectV2":return[r.where(RS("condition",e,t,n),RS("a",e,t,n),RS("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"matrices":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(RS("a",e,t,n),RS("b",e,t,n),RS("transposeA",e,t,n),RS("transposeB",e,t,n))];case"Einsum":return[r.einsum(RS("equation",e,t,n),...RS("tensors",e,t,n))];case"Transpose":return[r.transpose(RS("x",e,t,n),RS("perm",e,t,n))];case"_FusedMatMul":const[a,s]=RS("fusedOps",e,t,n),o="biasadd"===a,i="prelu"===s,l=RS("numArgs",e,t,n),u=RS("leakyreluAlpha",e,t,n);if(o){if(i&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=RS("args",e,t,n);return[r.fused.matMul({a:RS("a",e,t,n),b:RS("b",e,t,n),transposeA:RS("transposeA",e,t,n),transposeB:RS("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"normalization":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(RS("x",e,t,n),RS("axis",e,t,n),RS("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(RS("x",e,t,n),RS("mean",e,t,n),RS("variance",e,t,n),RS("offset",e,t,n),RS("scale",e,t,n),RS("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(RS("x",e,t,n),RS("radius",e,t,n),RS("bias",e,t,n),RS("alpha",e,t,n),RS("beta",e,t,n))];case"Softmax":return[r.softmax(RS("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(RS("x",e,t,n))];case"SparseToDense":return[r.sparseToDense(RS("sparseIndices",e,t,n),RS("outputShape",e,t,n),RS("sparseValues",e,t,n),RS("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"reduction":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"Max":{const a=RS("axis",e,t,n),s=RS("keepDims",e,t,n);return[r.max(RS("x",e,t,n),a,s)]}case"Mean":{const a=RS("axis",e,t,n),s=RS("keepDims",e,t,n);return[r.mean(RS("x",e,t,n),a,s)]}case"Min":{const a=RS("axis",e,t,n),s=RS("keepDims",e,t,n);return[r.min(RS("x",e,t,n),a,s)]}case"Sum":{const a=RS("axis",e,t,n),s=RS("keepDims",e,t,n);return[r.sum(RS("x",e,t,n),a,s)]}case"All":{const a=RS("axis",e,t,n),s=RS("keepDims",e,t,n);return[r.all(RS("x",e,t,n),a,s)]}case"Any":{const a=RS("axis",e,t,n),s=RS("keepDims",e,t,n);return[r.any(RS("x",e,t,n),a,s)]}case"ArgMax":{const a=RS("axis",e,t,n);return[r.argMax(RS("x",e,t,n),a)]}case"ArgMin":{const a=RS("axis",e,t,n);return[r.argMin(RS("x",e,t,n),a)]}case"Prod":{const a=RS("axis",e,t,n),s=RS("keepDims",e,t,n);return[r.prod(RS("x",e,t,n),a,s)]}case"Cumprod":{const a=RS("axis",e,t,n),s=RS("exclusive",e,t,n),o=RS("reverse",e,t,n);return[r.cumprod(RS("x",e,t,n),a,s,o)]}case"Cumsum":{const a=RS("axis",e,t,n),s=RS("exclusive",e,t,n),o=RS("reverse",e,t,n);return[r.cumsum(RS("x",e,t,n),a,s,o)]}case"Bincount":const a=RS("x",e,t,n),s=RS("weights",e,t,n),o=RS("size",e,t,n);return[r.bincount(a,s,o)];case"DenseBincount":{const a=RS("x",e,t,n),s=RS("weights",e,t,n),o=RS("size",e,t,n),i=RS("binaryOutput",e,t,n);return[r.denseBincount(a,s,o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"slice_join":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"ConcatV2":case"Concat":{const a=RS("n",e,t,n),s=RS("axis",e,t,n);let o=RS("tensors",e,t,n);return o=o.slice(0,a),[r.concat(o,s)]}case"Gather":{const a=RS("x",e,t,n),s=RS("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{const a=RS("axis",e,t,n),s=RS("batchDims",e,t,n),o=RS("x",e,t,n),i=RS("indices",e,t,n);return[r.gather(o,r.cast(i,"int32"),a,s)]}case"Reverse":{const a=RS("dims",e,t,n),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);const o=RS("x",e,t,n);return[r.reverse(o,s)]}case"ReverseV2":{const a=RS("axis",e,t,n),s=RS("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{const a=RS("begin",e,t,n),s=RS("size",e,t,n);return[r.slice(RS("x",e,t,n),a,s)]}case"StridedSlice":{const a=RS("begin",e,t,n),s=RS("end",e,t,n),o=RS("strides",e,t,n),i=RS("beginMask",e,t,n),l=RS("endMask",e,t,n),u=RS("ellipsisMask",e,t,n),c=RS("newAxisMask",e,t,n),d=RS("shrinkAxisMask",e,t,n),h=RS("x",e,t,n);return[r.stridedSlice(h,a,s,o,i,l,u,c,d)]}case"Pack":return gi((()=>{const a=RS("axis",e,t,n),s=RS("tensors",e,t,n),o=s[0].shape,i=r.squeeze(s[0]).shape,l=s.map((e=>{const t=wa.arraysEqual(e.shape,o);if(!t&&!wa.arraysEqual(r.squeeze(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,o)}));return[r.stack(l,a)]}));case"Unpack":{const a=RS("axis",e,t,n),s=RS("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{const a=RS("reps",e,t,n);return[r.tile(RS("x",e,t,n),a)]}case"Split":case"SplitV":{const a=RS("axis",e,t,n),s=RS("numOrSizeSplits",e,t,n),o=RS("x",e,t,n);return r.split(o,s,a)}case"ScatterNd":{const a=RS("indices",e,t,n),s=RS("values",e,t,n),o=RS("shape",e,t,n);return[r.scatterND(a,s,o)]}case"GatherNd":{const a=RS("x",e,t,n),s=RS("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{const a=RS("sparseIndices",e,t,n),s=RS("outputShape",e,t,n),o=RS("sparseValues",e,t,n),i=RS("defaultValue",e,t,n);return[r.sparseToDense(a,o,s,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"sparse":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:s,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(RS("indices",e,t,n),RS("values",e,t,n),RS("denseShape",e,t,n),RS("defaultValue",e,t,n));return[a,s,o,i]}case"SparseReshape":{const{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(RS("inputIndices",e,t,n),RS("inputShape",e,t,n),RS("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(RS("data",e,t,n),RS("indices",e,t,n),RS("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(RS("data",e,t,n),RS("indices",e,t,n),RS("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"spectral":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"FFT":return[r.fft(RS("x",e,t,n))];case"IFFT":return[r.ifft(RS("x",e,t,n))];case"RFFT":return[r.rfft(RS("x",e,t,n))];case"IRFFT":return[r.irfft(RS("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"string":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"StringNGrams":{const{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(RS("data",e,t,n),RS("dataSplits",e,t,n),RS("separator",e,t,n),RS("nGramWidths",e,t,n),RS("leftPad",e,t,n),RS("rightPad",e,t,n),RS("padWidth",e,t,n),RS("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{const{indices:a,values:s,shape:o}=r.string.stringSplit(RS("input",e,t,n),RS("delimiter",e,t,n),RS("skipEmpty",e,t,n));return[a,s,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(RS("input",e,t,n),RS("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"transformation":return a((()=>((e,t,n,r=DI)=>{switch(e.op){case"Cast":return[r.cast(RS("x",e,t,n),RS("dtype",e,t,n))];case"ExpandDims":{const a=RS("axis",e,t,n);return[r.expandDims(RS("x",e,t,n),a)]}case"Squeeze":{const a=RS("axis",e,t,n);return[r.squeeze(RS("x",e,t,n),a)]}case"Reshape":return[r.reshape(RS("x",e,t,n),RS("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(RS("x",e,t,n),RS("padding",e,t,n),RS("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(RS("x",e,t,n),RS("padding",e,t,n),RS("constantValue",e,t,n))];case"SpaceToBatchND":{const a=RS("blockShape",e,t,n),s=RS("paddings",e,t,n);return[r.spaceToBatchND(RS("x",e,t,n),a,s)]}case"BatchToSpaceND":{const a=RS("blockShape",e,t,n),s=RS("crops",e,t,n);return[r.batchToSpaceND(RS("x",e,t,n),a,s)]}case"DepthToSpace":{const a=RS("blockSize",e,t,n),s=RS("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(RS("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(RS("x",e,t,n),RS("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(RS("s0",e,t,n),RS("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"hash_table":return GI(e,t,n,r);case"custom":const s=NS(e.op);if(s&&s.customExecutor)return s.customExecutor(new class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return _S(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return _S(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return II(this.node.rawAttrs,e,t);if(null!=n.s)return kI(this.node.rawAttrs,e,t);if(null!=n.b)return SI(this.node.rawAttrs,e,t);if(null!=n.shape)return _I(this.node.rawAttrs,e,t);if(null!=n.type)return NI(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return MI(this.node.rawAttrs,e,t);if(null!=n.list.s)return $I(this.node.rawAttrs,e,t);if(null!=n.list.shape)return FI(this.node.rawAttrs,e,t);if(null!=n.list.b)return OI(this.node.rawAttrs,e,t);if(null!=n.list.type)return TI(this.node.rawAttrs,e,t)}return t}}(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return wa.isPromise(s)?s.then((e=>[].concat(e))):[].concat(s)}var qI=class{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function XI(e,t,n,r){const a=new Set,s=[];let o=null,i=null;const l=new Set,u=Object.keys(e).map((e=>FS(e)[0]));let c=[];null!=r&&(c=r.map((e=>FS(e.name)[0])));const d=[...t];for(;d.length>0;){const e=d.pop();(JI(e)||QI(e)||eC(e))&&null==o&&(o=e,i=o.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&(-1===u.indexOf(e.name)&&-1===c.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))})):s.push(e.name)))}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:o,syncInputs:i}}var KI=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],ZI=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],YI=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function JI(e){return KI.indexOf(e.op)>=0}function QI(e){return ZI.indexOf(e.op)>=0}function eC(e){return YI.indexOf(e.op)>=0}var tC=class{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new tC(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const n=XI(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){const n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}return function(e,t,n){const{usedNodes:r,inputs:a}=n,s=[],o=Object.keys(a).map((e=>FS(e)[0])).map((t=>e.nodes[t])),i=e.initNodes;o.forEach((e=>{r.has(e.name)&&s.push(e)})),e.weights.forEach((e=>{r.has(e.name)&&s.push(e)})),null!=i&&i.forEach((e=>{r.has(e.name)&&s.push(e)}));const l=new Set,u=[];for(;s.length>0;){const e=s.pop();l.add(e.name),t[e.name]||u.push(e),e.children.forEach((e=>{!l.has(e.name)&&r.has(e.name)&&e.inputs.every((e=>l.has(e.name)))&&s.push(e)}))}return u}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[FS(e)[0]])),a=t.map((e=>FS(e)[0]));let s=a.map((e=>this.graph.nodes[e]));this.resetIntermediateTensors(),0===s.length&&(s=this._outputs);const o=this.getCompilationKey(r,s);let i=this.compiledMap.get(o);null==i&&(i=this.compile(e,s),this.compiledMap.set(o,i));const l={},u={};return gi((()=>{const n=new qI(this.weightMap,l,u,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,a]=FS(t),s=[];s[a]=e[t],r[n]=s}));const s=this.getFrozenTensorIds(r),o={};for(let e=0;e<i.length;e++){const t=i[e];if(!r[t.name]){const e=HI(t,r,n,this._resourceManager);if(wa.isPromise(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.checkTensorForDisposal(t.name,t,r,n,s,a,o)}}return null==this.parent&&n.dispose(s),t.map((e=>_S(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,o){"control"!==t.category&&-1===s.indexOf(e)&&(n[e].forEach((e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const s=function(e,t,n){return t[$S(e,n.currentContextId)]}(e.name,n,r);null!=s&&s.forEach((e=>{if(e&&!e.kept&&!a.has(e.id)){const n=o[e.id];if(1===n){if(this.keepTensorForDebug){const[n,a]=MS(t.name,r);this.intermediateTensors[n]||(this.intermediateTensors[n]=[]),this.intermediateTensors[n][a]=e}else e.dispose();delete o[e.id]}else null!=n&&o[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach((e=>this.intermediateTensors[e].forEach((e=>e.dispose())))),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach((e=>{this.tensorsMap[e].forEach((e=>{!e||e.kept||e.isDisposed||this.keepIds.has(e.id)||e.dispose()}))}))}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach((e=>e.dispose())),delete this.intermediateTensors[e]}async _executeAsync(e,t,n=!1,r={},a={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=qe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){console.warn(e.message)}this.resetIntermediateTensors();const s=new qI(this.weightMap,r,a,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,s,t,n);const o=t.map((e=>_S(e,this.tensorsMap,s))),i=o.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id));return this.keepIds=new Set([...i,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&s.dispose(this.keepIds),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const a=Object.keys(e),s=a.map((e=>this.graph.nodes[FS(e)[0]])),o=n.map((e=>FS(e)[0]));let i=o.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const{usedNodes:l,missingInputs:u,dynamicNode:c,syncInputs:d}=XI(e,i,this.weightMap,this._initNodes),h=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),p=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=FS(t),a=[];a[r]=e[t],p[n]=a}));const f={},m=this.getFrozenTensorIds(p),A={};for(;h.length>0;){const e=this.processStack(s,h,t,p,A,m,o,f,l);await Promise.all(e)}null!=c||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const g=i.filter((e=>!JI(e)&&!_S(e.name,p,t))).map((e=>e.name));if(g.length>0){let e="";throw null!=c&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${g}] from the provided inputs [${a}]. Consider providing the following inputs: [${u}]. ${e}`)}return p}processStack(e,t,n,r,a,s,o,i,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&RS("isConstant",e.node,r,n)&&([c]=MS(e.node.name,n)),null==r[e.node.name]){const d=HI(e.node,r,n,this._resourceManager);c||([c]=MS(e.node.name,n));const h=n.currentContext;wa.isPromise(d)?u.push(d.then((u=>(r[c]=u,n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,s,o,i),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[c]=d,this.checkTensorForDisposal(c,e.node,r,n,s,o,i),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{const[o]=MS(e.name,n);!a[o]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!_S(e,r,n)))&&(a[o]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!_S(e,r,n)))&&(a[o]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=FS(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));wa.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&wa.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){const t={};for(const n in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){t[this._signature.inputs[n].name]=e[n]}else t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=FS(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=FS(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},nC=class{constructor(e,t={},n=Bo){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return wa.isPromise(e)?e.then((e=>this.loadSync(e))):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new tC(vI.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=vI.Instance.transformGraph(e.modelInitializer);this.initializer=new tC(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){const n=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const e={};return(n instanceof Qa?[n]:n).forEach(((t,n)=>e[this.structuredOutputKeys[n]]=t)),e}return n}normalizeInputs(e){if(!(e instanceof Qa||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,n,r)=>(t[n]=e[r],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function rC(e,t={},n=Bo){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){e.endsWith("/")||(e+="/");return`${e}model.json?tfjs-format=file`}(e));const r=new nC(e,t,n);return await r.load(),r}function aC(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide a url or an IOHandler that loads the model");if(!e.load)throw new Error(`modelUrl IO Handler ${e} has no load function`);const t=new nC(e);return t.load(),t}var sC="3.19.0",oC={};S(oC,{CSVDataset:()=>JC,Dataset:()=>BC,FileDataSource:()=>dE,TextLineDataset:()=>GC,URLDataSource:()=>hE,array:()=>UC,csv:()=>pE,func:()=>fE,generator:()=>mE,microphone:()=>gE,version_data:()=>yE,webcam:()=>AE,zip:()=>VC});var iC=I(z()),lC=I(z());function uC(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(fC(e)){const a=Array.isArray(e)?[]:{};r.add(e);for(const s in e){const o=uC(e[s],t,n,r);a[s]=o}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function cC(e,t=hC){return dC(e,t)}function dC(e,t,n=new Set){const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(fC(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=dC(e.map((e=>e[s])),t,n);a[s]=r}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function hC(e){return null===e?null:fC(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function pC(e,t){const n=new Map;uC(e,t,n);for(const e of Array.from(n.keys())){const t=n.get(e);if(wa.isPromise(t)){const r=await t;n.set(e,r)}}return uC(e,t,n)}function fC(e){let t=!1;if(qe().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:n}=P();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof Qa)&&!(e instanceof Promise)&&!t)}function mC(e){return uC(e,AC)}function AC(e){return e instanceof Qa?{value:e.clone(),recurse:!1}:fC(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var gC=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},yC=class extends gC{constructor(){super(yC.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function xC(e){return new SC(e)}function bC(e){return new IC(e)}yC.INITIAL_CAPACITY=32;var vC,wC,kC=class{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new MC(this,e)}filter(e){return new RC(this,e)}map(e){return new _C(this,e)}mapAsync(e){return new $C(this,e)}serialMapAsync(e){return new $C(this,e).serial()}flatmap(e){return new OC(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new TC(this,e,t)}columnMajorBatch(e,t=!0,n=hC){return this.rowMajorBatch(e,t).map((e=>cC(e,n)))}concatenate(e,t){return new DC(xC([this,e]),t)}take(e){return e<0||null==e?this:new NC(this,e)}skip(e){return e<0||null==e?this:new EC(this,e)}prefetch(e){return new PC(this,e)}shuffle(e,t){return new LC(this,e,t)}serial(){return new CC(this)}},SC=class extends kC{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:mC(e),done:!1}}},IC=class extends kC{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},CC=class extends kC{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},EC=class extends kC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;yi(e.value)}return this.upstream.next()}},NC=class extends kC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},TC=class extends kC{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},RC=class extends kC{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;yi(e.value)}}},_C=class extends kC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=hs.getTensorsInContainer(e.value),n=this.transform(e.value),r=hs.getTensorsInContainer(n);for(const e of t)hs.isTensorInList(e,r)||e.dispose();return{value:n,done:!1}}},MC=class extends kC{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},$C=class extends kC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=hs.getTensorsInContainer(e.value),n=await this.transform(e.value),r=hs.getTensorsInContainer(n);for(const e of t)hs.isTensorInList(e,r)||e.dispose();return{value:n,done:!1}}},FC=class extends kC{constructor(){super(),this.outputQueue=new yC,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},OC=class extends FC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=hs.getTensorsInContainer(e.value),n=this.transform(e.value),r=hs.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const e of t)hs.isTensorInList(e,r)||e.dispose();return!0}},DC=class extends kC{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};(wC=vC||(vC={}))[wC.FAIL=0]="FAIL",wC[wC.SHORTEST=1]="SHORTEST",wC[wC.LONGEST=2]="LONGEST";var zC=class extends kC{constructor(e,t=vC.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;const r=await pC(this.iterators,(function(e){if(e instanceof kC){return{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}}return{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case vC.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case vC.SHORTEST:return{value:null,done:!0};case vC.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},PC=class extends kC{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new gC(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},LC=class extends PC{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=lC.alea(n||wa.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},BC=class{constructor(){this.size=null}batch(e,t=!0){const n=this;let r;return wa.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),WC((async()=>(await n.iterator()).columnMajorBatch(e,t,jC)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,WC((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,WC((async()=>(await t.iterator()).filter((t=>gi((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return WC((async()=>(await t.iterator()).map((t=>gi((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return WC((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return WC((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,WC((async()=>{const n=bC((async()=>({value:await t.iterator(),done:!1})));return r=n.take(e),new DC(r,a);var r,a}),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,WC((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,a=iC.alea(t||wa.now().toString());return WC((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,WC((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function WC(e,t=null){return new class extends BC{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function UC(e){return WC((async()=>xC(e)),e.length)}function VC(e){if(!fC(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(const n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return WC((async()=>function(e,t=vC.FAIL){return new zC(e,t)}(await pC(e,(e=>{if(e instanceof BC)return{value:e.iterator(),recurse:!1};if(fC(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),vC.SHORTEST)),t)}function jC(e){if(null===e)return null;const t=e[0];if(null==(n=t)||null===(r=n)||"object"!=typeof r&&"function"!=typeof r||Array.isArray(n)||"object"==typeof n&&n instanceof Qa||wa.isTypedArray(n)){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Qa?fh(e):Us(e)}(e),recurse:!1}}var n,r;return{value:null,recurse:!0}}BC.MAX_BUFFER_SIZE=1e4;var GC=class extends BC{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},HC='"',qC=Symbol("out"),XC=Symbol("field"),KC=Symbol("quote"),ZC=Symbol("quoteafterquote"),YC=Symbol("quoteinquote"),JC=class extends BC{constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new GC(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(wa.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&wa.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(wa.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(const e of Object.keys(this.columnConfigs)){if(-1===this.fullColumnNames.indexOf(e))throw new Error('The key "'+e+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const e=await this.base.iterator(),t=await e.next();if(t.done)throw new Error("No data was found for CSV parsing.");const n=t.value;return this.parseRow(n,!1)}return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){const t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){const s=this.fullColumnNames[a],o=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||o){const i=t[a];let l=null;if(""===i)if(o&&void 0!==o.default)l=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{const e=Number(i);if(isNaN(e))l=o&&"bool"===o.dtype?this.getBoolean(i):i;else if(o&&o.dtype)switch(o.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(i)}else l=e}o&&o.isLabel?r[s]=l:n[s]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){const n=[];let r=0;const a=e.length;let s=qC;for(let t=0;t<a;t++)switch(s){case qC:switch(e.charAt(t)){case HC:r=t+1,s=KC;break;case this.delimiter:if(r=t+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=qC;break;default:s=XC,r=t}break;case XC:if(e.charAt(t)===this.delimiter)n.push(e.substring(r,t)),s=qC,r=t+1;break;case KC:if(e.charAt(t)===HC)s=ZC;break;case ZC:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(r,t-1)),s=qC,r=t+1;break;case HC:s=KC;break;default:s=YC}break;case YC:if(e.charAt(t)===HC)s=KC}if(s===ZC?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},QC=class extends kC{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!qe().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new QC(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(e){throw new Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const n=await this.getAudioData();if(this.includeSpectrogram){const t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let n=0;return new Promise((r=>{const a=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){const n=new Float32Array(wa.sizeFromShape(t));return n.set(e,n.length-e.length),Us(n,t)}},eE=class extends kC{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=yh([0],"int32"),this.webcamConfig.centerCrop){const e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,a=n+e,s=t+r;this.cropBox=xh([r,n,s,a],[1,4])}else this.cropBox=xh([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!qe().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const n=new eE(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&wa.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Bi.fromPixels(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return gi((()=>{const t=wc(zo(e,"float32"),0);let n;n=Zp.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=n.shape;return du(n,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},tE=class{},nE=class extends kC{split(e){return new rE(this,e)}},rE=class extends nE{constructor(e,t){super(),this.upstream=e,this.impl=new aE(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},aE=class extends FC{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const e of t.slice(0,-1))this.outputQueue.push(e);return this.carryover=t[t.length-1],!0}},sE=class extends kC{decodeUTF8(){return new oE(this)}},oE=class extends nE{constructor(e){super(),this.upstream=e,this.impl=new iE(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},iE=class extends FC{constructor(e){if(super(),this.upstream=e,qe().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}=P();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t,n;return!e.done&&(t=e.value,n=qe().get("IS_BROWSER")?this.decoder.decode(t,{stream:!0}):this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0)}},lE=class extends sE{constructor(e,t={}){super(),this.file=e,this.options=t,wa.assert(e instanceof Uint8Array||!!qe().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};const e=new Promise(((e,t)=>{const n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{const r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));const a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n}));return{value:await e,done:!1}}};var uE=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function cE(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var dE=class extends tE{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(cE(this.input)&&qe().get("IS_NODE")){const e=L();this.input=e.readFileSync(this.input.slice(7))}return new lE(this.input,this.options)}},hE=class extends tE{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return cE(this.url)?new dE(this.url,this.fileOptions).iterator():async function(e,t={},n){let r,a;"string"==typeof e?r=e:(r=e.url,a=uE(e));const s=await(n||wa.fetch)(r,a);if(s.ok){const e=new Uint8Array(await s.arrayBuffer());return new lE(e,t)}throw new Error(s.statusText)}(this.url,this.fileOptions)}};function pE(e,t={}){return new JC(new hE(e),t)}function fE(e){const t=bC(e);return WC((async()=>t))}function mE(e){return WC((async()=>{const t=await e();return bC((()=>t.next()))}))}async function AE(e,t){return eE.create(e,t)}async function gE(e){return QC.create(e)}var yE="3.19.0";function xE(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&wa.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var bE=fm.whereImpl,vE=class extends X{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new q(this,fi())}nextDataId(){return vE.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,qe().get("IS_NODE")&&ff.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&wa.isString(n[0])){const a=n.map((e=>wa.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return ff.mergeRealAndImagArrays(e,t)}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>wa.decodeString(e)));return Do(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Do(e.shape,e.dtype,t)}makeOutput(e,t,n){return fi().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=wa.now();e();return{kernelMs:wa.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){xE([e],"where");const t=this.readSync(e.dataId);return bE(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};vE.nextDataId=0;var wE={};function kE(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}S(wE,{addImpl:()=>zE,bincountImpl:()=>WE,bincountReduceImpl:()=>UE,ceilImpl:()=>HE,concatImpl:()=>KE,equalImpl:()=>ZE,expImpl:()=>QE,expm1Impl:()=>nN,floorImpl:()=>sN,gatherNdImpl:()=>lN,gatherV2Impl:()=>uN,greaterEqualImpl:()=>pN,greaterImpl:()=>cN,lessEqualImpl:()=>xN,lessImpl:()=>AN,linSpaceImpl:()=>wN,logImpl:()=>kN,maxImpl:()=>CN,maximumImpl:()=>EN,minimumImpl:()=>RN,multiplyImpl:()=>$N,negImpl:()=>zN,notEqualImpl:()=>LN,prodImpl:()=>GN,rangeImpl:()=>qN,rsqrtImpl:()=>XN,scatterImpl:()=>YN,sigmoidImpl:()=>JN,simpleAbsImpl:()=>kE,sliceImpl:()=>tT,sparseFillEmptyRowsImpl:()=>aT,sparseReshapeImpl:()=>sT,sparseSegmentReductionImpl:()=>oT,sqrtImpl:()=>iT,squaredDifferenceImpl:()=>cT,stridedSliceImpl:()=>pT,stringNGramsImpl:()=>fT,stringSplitImpl:()=>AT,stringToHashBucketFastImpl:()=>gT,subImpl:()=>yT,tileImpl:()=>wT,topKImpl:()=>IT,transposeImpl:()=>UN,uniqueImpl:()=>CT});var SE={kernelName:Je,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;xE(t,"abs");let r=new Float32Array(wa.sizeFromShape(t.shape));return r=kE(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function IE(e){return(t,n,r,a,s)=>{const o=ff.assertAndGetBroadcastShape(t,n),i=o.length,l=wa.computeStrides(o),u=wa.sizeFromShape(o),c=wa.getTypedArrayFromDType(s,u),d=t.length,h=n.length,p=wa.computeStrides(t),f=wa.computeStrides(n),m=ff.getBroadcastDims(t,o),A=ff.getBroadcastDims(n,o);if(m.length+A.length===0)for(let t=0;t<c.length;++t)c[t]=e(r[t%r.length],a[t%a.length]);else for(let t=0;t<c.length;++t){const n=wa.indexToLoc(t,i,l),s=n.slice(-d);m.forEach((e=>s[e]=0));const o=wa.locToIndex(s,d,p),u=n.slice(-h);A.forEach((e=>u[e]=0));const g=wa.locToIndex(u,h,f);c[t]=e(r[o],a[g])}return[c,o]}}function CE(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,i=n.makeTensorInfo(r.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",o)},i}var EE={kernelName:St,backendName:"cpu",kernelFunc:CE};function NE(e,t,n="float32"){if("complex64"===n){return CE({inputs:{real:NE(e,t,"float32"),imag:NE(e,t,"float32")},backend:e})}const r=wa.makeZerosTypedArray(wa.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function TE(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var RE={kernelName:pn,backendName:"cpu",kernelFunc:TE};function _E(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var ME={kernelName:ir,backendName:"cpu",kernelFunc:_E};function $E(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return TE({inputs:{x:a},backend:n});const e=NE(n,a.shape,a.dtype),t=$E({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=CE({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=_E({inputs:{input:a},backend:n}),t=$E({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!wa.hasEncodingLoss(a.dtype,s)){const e=TE({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s){const e=n.data.get(a.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(a.shape,"int32",t)}if("bool"===s){const e=n.data.get(a.dataId).values,t=wa.toTypedArray([0],a.dtype),[r,s]=IE(((e,t)=>e!==t?1:0))(a.shape,[],e,t,"bool");return n.makeTensorInfo(s,"bool",r)}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var FE={kernelName:vt,backendName:"cpu",kernelFunc:$E};function OE(e,t,n,r){return null==n?({inputs:n,backend:a})=>{const{a:s,b:o}=n,i=a;xE([s,o],e);const l=i.data.get(s.dataId).values,u=i.data.get(o.dataId).values,c="string"===s.dtype?ff.fromUint8ToStringArray(l):l,d="string"===s.dtype?ff.fromUint8ToStringArray(u):u,h=r||s.dtype,[p,f]=t(s.shape,o.shape,c,d,h);return i.makeTensorInfo(f,h,p)}:({inputs:e,backend:a})=>{const{a:s,b:o}=e,i=a;if("complex64"===s.dtype||"complex64"===o.dtype){const e=$E({inputs:{x:s},backend:i,attrs:{dtype:"complex64"}}),t=i.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,l=i.data.get(r.dataId).values,u=i.data.get(a.dataId).values,c=$E({inputs:{x:o},backend:i,attrs:{dtype:"complex64"}}),d=i.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=i.data.get(h.dataId).values,m=i.data.get(p.dataId).values,[A,g,y]=n(s.shape,o.shape,l,u,f,m),x=i.makeTensorInfo(y,"float32",A),b=i.makeTensorInfo(y,"float32",g),v=CE({inputs:{real:x,imag:b},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(b),v}{const e=i.data.get(s.dataId).values,n=i.data.get(o.dataId).values,a=r||s.dtype,[l,u]=t(s.shape,o.shape,e,n,a);return i.makeTensorInfo(u,a,l)}}}function DE(e){return(t,n,r,a,s,o)=>{const i=ff.assertAndGetBroadcastShape(t,n),l=wa.sizeFromShape(i),u=i.length,c=wa.computeStrides(i),d=wa.getTypedArrayFromDType("float32",l),h=wa.getTypedArrayFromDType("float32",l),p=ff.getBroadcastDims(t,i),f=ff.getBroadcastDims(n,i),m=ff.mergeRealAndImagArrays(r,a),A=ff.mergeRealAndImagArrays(s,o),g=t.length,y=wa.computeStrides(t),x=n.length,b=wa.computeStrides(n);if(p.length+f.length===0)for(let t=0;t<d.length;t++){const n=t%m.length,r=t%A.length,a=e(m[2*n],m[2*n+1],A[2*r],A[2*r+1]);d[t]=a.real,h[t]=a.imag}else for(let t=0;t<d.length;t++){const n=wa.indexToLoc(t,u,c),r=n.slice(-g);p.forEach((e=>r[e]=0));const a=wa.locToIndex(r,g,y),s=n.slice(-x);f.forEach((e=>s[e]=0));const o=wa.locToIndex(s,x,b),i=e(m[2*a],m[2*a+1],A[2*o],A[2*o+1]);d[t]=i.real,h[t]=i.imag}return[d,h,i]}}var zE=IE(((e,t)=>e+t)),PE=DE(((e,t,n,r)=>({real:e+n,imag:t+r}))),LE=OE(tt,zE,PE),BE={kernelName:tt,backendName:"cpu",kernelFunc:LE};function WE(e,t,n,r,a){const s=wa.sizeFromShape(r),o=wa.makeZerosTypedArray(a,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=a||(o[r]+=s>0?t[n]:1)}return o}function UE(e,t,n,r=!1){const a=e.shape[0],s=e.shape[1],o=Do([a,n],t.dtype);for(let i=0;i<a;i++)for(let a=0;a<s;a++){const s=e.get(i,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?o.set(1,i,s):t.size>0?o.set(o.get(i,s)+t.get(i,a),i,s):o.set(o.get(i,s)+1,i,s))}return o}function VE(e){return(t,n,r)=>{const a=wa.getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)a[n]=e(t[n],r);return a}}function jE(e,t,n){return({inputs:r,attrs:a,backend:s})=>{const{x:o}=r;if(xE(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,l=i.data.get(o.dataId).values,u=wa.sizeFromShape(o.shape),c=n||o.dtype,d=wa.getArrayFromDType(c,u);for(let e=0;e<u;++e)d[e]=t(l[e],a);return i.makeTensorInfo(o.shape,c,d)}}function GE(e,t,n){return({inputs:r,attrs:a,backend:s})=>{const{x:o}=r;if(xE(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=s,l=i.data.get(o.dataId).values,u=n||o.dtype,c=t(l,u,a);return i.makeTensorInfo(o.shape,u,c)}}var HE=VE((e=>Math.ceil(e))),qE=GE(wt,HE),XE={kernelName:wt,backendName:"cpu",kernelFunc:qE};function KE(e,t,n,r){const a=wa.getArrayFromDType(n,wa.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=wa.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const s="string"===n?ff.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[i+t]=s[o++]}r+=e.shape[1]}))}return a}var ZE=IE(((e,t)=>e===t?1:0)),YE=OE(Jt,ZE,null,"bool"),JE={kernelName:Jt,backendName:"cpu",kernelFunc:YE},QE=VE((e=>Math.exp(e))),eN=GE(Qt,QE,"float32"),tN={kernelName:Qt,backendName:"cpu",kernelFunc:eN},nN=VE((e=>Math.expm1(e))),rN=GE(tn,nN),aN={kernelName:tn,backendName:"cpu",kernelFunc:rN},sN=VE((e=>Math.floor(e))),oN=GE(sn,sN),iN={kernelName:sn,backendName:"cpu",kernelFunc:oN};function lN(e,t,n,r,a,s,o,i,l){const u=Do([r,s],n);for(let n=0;n<r;n++){const r=[];let c=0;for(let t=0;t<a;t++){const s=e[n*a+t];c+=s*o[t],r.push(s)}if(c<0||c>=l/s)throw new Error(`Invalid indices: ${r} does not index into ${i}`);for(let e=0;e<s;e++)u.values[n*s+e]=t.get(...t.indexToLoc(c*s+e))}return u}function uN(e,t,n){const r=Do(n,e.dtype);for(let n=0;n<r.size;++n){const a=r.indexToLoc(n).slice(),s=a[0],o=a[2],i=t.locToIndex([s,o]);a[2]=t.values[i];const l=e.locToIndex(a);0<=l&&l<e.values.length&&(r.values[n]=e.values[l])}return r}var cN=IE(((e,t)=>e>t?1:0)),dN=OE(dn,cN,null,"bool"),hN={kernelName:dn,backendName:"cpu",kernelFunc:dN},pN=IE(((e,t)=>e>=t?1:0)),fN=OE(hn,pN,null,"bool"),mN={kernelName:hn,backendName:"cpu",kernelFunc:fN},AN=IE(((e,t)=>e<t?1:0)),gN=OE(bn,AN,null,"bool"),yN={kernelName:bn,backendName:"cpu",kernelFunc:gN},xN=IE(((e,t)=>e<=t?1:0)),bN=OE(vn,xN,null,"bool"),vN={kernelName:vn,backendName:"cpu",kernelFunc:bN};function wN(e,t,n){const r=(t-e)/(n-1),a=wa.makeZerosTypedArray(n,"float32");a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+r;return a}var kN=VE((e=>Math.log(e))),SN=GE(kn,kN),IN={kernelName:kn,backendName:"cpu",kernelFunc:SN};function CN(e,t,n,r){const a=wa.getTypedArrayFromDType(r,wa.sizeFromShape(n));for(let n=0;n<a.length;++n){const r=n*t;let s=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>s)&&(s=t)}a[n]=s}return a}var EN=IE(((e,t)=>Math.max(e,t))),NN=OE(Fn,EN),TN={kernelName:Fn,backendName:"cpu",kernelFunc:NN},RN=IE(((e,t)=>Math.min(e,t))),_N=OE(Un,RN),MN={kernelName:Un,backendName:"cpu",kernelFunc:_N},$N=IE(((e,t)=>e*t)),FN=DE(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),ON=OE(Hn,$N,FN),DN={kernelName:Hn,backendName:"cpu",kernelFunc:ON};function zN(e,t,n){const r=wa.createScalarValue(-1,n);return $N([],t,r,e,n)}var PN={kernelName:qn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;xE(r,"neg");const a=n.data.get(r.dataId).values,[s,o]=zN(a,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,s)}},LN=IE(((e,t)=>e!==t?1:0)),BN=OE(Xn,LN,null,"bool"),WN={kernelName:Xn,backendName:"cpu",kernelFunc:BN};function UN(e,t,n,r,a){const s=t.length,o=wa.sizeFromShape(t),i=wa.computeStrides(t),l=wa.computeStrides(a),u=wa.getTypedArrayFromDType(n,wa.sizeFromShape(a));for(let t=0;t<o;++t){const n=wa.indexToLoc(t,s,i),a=new Array(n.length);for(let e=0;e<a.length;e++)a[e]=n[r[e]];u[wa.locToIndex(a,s,l)]=e[t]}return u}function VN(e){const{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;xE(a,"transpose");const o=a.shape.length,i=new Array(o);for(let e=0;e<i.length;e++)i[e]=a.shape[s[e]];const l=UN(r.data.get(a.dataId).values,a.shape,a.dtype,s,i);return{dataId:r.write(l,i,a.dtype),shape:i,dtype:a.dtype}}var jN={kernelName:Yr,backendName:"cpu",kernelFunc:VN};function GN(e,t,n,r){const[a,s]=ff.computeOutAndReduceShapes(e,r),o=fs(t,"int32"),i=wa.makeZerosTypedArray(wa.sizeFromShape(a),o),l=wa.sizeFromShape(s);for(let e=0;e<i.length;++e){const t=e*l;let r=1;for(let e=0;e<l;++e)r*=n[t+e];i[e]=r}return{outVals:i,outShape:a,outDtype:o}}var HN={kernelName:sr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;xE(a,"prod");const i=a.shape.length,l=wa.parseAxisParam(s,a.shape),u=ff.getAxesPermutation(l,i);let c=l,d=a;const h=[];null!=u&&(d=VN({inputs:{x:a},backend:n,attrs:{perm:u}}),h.push(d),c=ff.getInnerMostAxes(c.length,i));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:A}=GN(d.shape,d.dtype,p,c);let g=m;return o&&(g=ff.expandShapeToKeepDim(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(g,A,f)}};function qN(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return wa.makeZerosTypedArray(0,r);const a=Math.abs(Math.ceil((t-e)/n)),s=wa.makeZerosTypedArray(a,r);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}var XN=VE((e=>1/Math.sqrt(e))),KN=GE(yr,XN),ZN={kernelName:yr,backendName:"cpu",kernelFunc:KN};function YN(e,t,n,r,a,s,o,i,l,u){const c=[r/a,a],d=e.values,h=t.values;if(0===r)return Do(n,t.dtype);const p=Do(c,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let e=0;e<s;e++){const s=[];let l=0;for(let t=0;t<o;t++){const n=d[e*o+t];s.push(n),l+=n*i[t]}if(l<0||l>=r/a)throw new Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<a;n++)u?p.values[l*a+n]+=h[e*a+n]:p.values[l*a+n]=0===t.rank?h[0]:h[e*a+n]}return p}var JN=VE((e=>1/(1+Math.exp(-e)))),QN=jE(Er,(e=>1/(1+Math.exp(-e)))),eT={kernelName:Er,backendName:"cpu",kernelFunc:QN};function tT(e,t,n,r,a){const s=Qi.isSliceContinous(r,t,n),o=wa.sizeFromShape(n),i=wa.computeStrides(r);if(s){const n=Qi.computeFlatOffset(t,i);return"string"===a?e.slice(n,n+o):e.subarray(n,n+o)}const l=Do(r,a,"string"===a?ff.fromUint8ToStringArray(e):e),u=Do(n,a);for(let e=0;e<u.size;++e){const n=u.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));u.set(l.get(...r),...n)}return"string"===a?ff.fromStringArrayToUint8(u.values):u.values}function nT(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:o}=r;xE(a,"slice");const[i,l]=Qi.parseSliceParams(a,s,o);Qi.assertParamsValid(a,i,l);const u=tT(n.data.get(a.dataId).values,i,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var rT={kernelName:kr,backendName:"cpu",kernelFunc:nT};function aT(e,t,n,r,a,s,o){const i=t[0],l=s[0],u=new Array(l),c=new Array(i),d=t[1];if(0===l){if(0!==i)throw new Error(ff.getSparseFillEmptyRowsIndicesDenseShapeMismatch(i));return[wa.getArrayFromDType(n,0),[0,d],wa.getArrayFromDType(a,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let t=0;t<i;++t){const n=e[t*d];if(n<0)throw new Error(ff.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,n));if(n>=l)throw new Error(ff.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,n,l));++f[n],h=h&&n>=p,p=n}let m=!0;for(let e=0;e<l;++e){const t=0===f[e];u[e]=t,m=m&&!t,f[e]=Math.max(f[e],1),e>0&&(f[e]+=f[e-1])}if(m&&h){const t=e,n=r;for(let e=0;e<i;++e)c[e]=e;return[t,[i,d],n,u,c]}{const t=f[l-1],s=wa.getArrayFromDType(n,t*d),h=wa.getArrayFromDType(a,t),p=new Array(l).fill(0);for(let t=0;t<i;++t){const n=e[t*d],a=p[n],o=(0===n?0:f[n-1])+a;p[n]++;for(let n=0;n<d;++n)s[o*d+n]=e[t*d+n];h[o]=r[t],c[t]=o}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;h[t]=o}}return[s,[t,d],h,u,c]}}function sT(e,t,n,r,a){const s=wa.sizeFromShape(r),o=t[0],i=a.length,l=[];let u=1,c=-1;for(let e=0;e<i;++e){const t=a[e];if(-1===t){if(-1!==c)throw new Error(ff.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,e));c=e,l.push(1)}else{if(t<0)throw new Error(ff.getSparseReshapeNegativeOutputDimErrorMessage(e,t));u*=t,l.push(t)}}if(-1!==c){if(u<=0)throw new Error(ff.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(s/u);if(u*e!==s)throw new Error(ff.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=e}if(wa.sizeFromShape(l)!==s)throw new Error(ff.getSparseReshapeInputOutputMismatchErrorMessage(r,l));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const p=[];if(i>0){p[i-1]=1;for(let e=i-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=wa.getArrayFromDType(n,o*i);for(let t=0;t<o;++t){let n=0;for(let r=0;r<d;++r)n+=e[t*d+r]*h[r];for(let e=0;e<i;++e)f[t*i+e]=Math.trunc(n/p[e]),n%=p[e]}return[f,[o,i],l]}function oT(e,t,n,r,a,s=!1,o=0){const i=r.length,l=[t[0],e.length/t[0]],u=l[1],c=i>0?a[i-1]+1:0;if(c<0)throw new Error(ff.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const d=t.slice();d[0]=c;const h=d.reduce(((e,t)=>e*t),1),p=wa.getArrayFromDType(n,h);if(0===i)return c>0&&p.fill(o),[p,d];if(c<=0)throw new Error(ff.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,A=0,g=a[f];for(;;){let t=0;if(m<i){if(t=a[m],g===t){++m;continue}if(g>=t)throw new Error(ff.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(g<0||g>=c)throw new Error(ff.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(g,c));g>A&&p.fill(o,A*u,g*u);for(let t=f;t<m;++t){const n=r[t];if(n<0||n>=l[0])throw new Error(ff.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,r[t],l[0]));for(let t=0;t<u;t++)p[g*u+t]+=e[n*u+t]}if(s)for(let e=0;e<u;e++)p[g*u+e]/=m-f;if(f=m,++m,A=g+1,g=t,m>i)break}return A<c&&p.fill(o,A*u,c*u),[p,d]}var iT=VE((e=>Math.sqrt(e))),lT=jE(Tr,(e=>Math.sqrt(e))),uT={kernelName:Tr,backendName:"cpu",kernelFunc:lT},cT=IE(((e,t)=>{const n=e-t;return n*n})),dT=OE(Lr,cT),hT={kernelName:Lr,backendName:"cpu",kernelFunc:dT};function pT(e,t,n,r){const a=Do(e,t.dtype);for(let e=0;e<a.size;e++){const s=a.indexToLoc(e),o=new Array(s.length);for(let e=0;e<o.length;e++)o[e]=s[e]*n[e]+r[e];a.set(t.get(...o),...s)}return a}function fT(e,t,n,r,a,s,o,i){return new class{constructor(e,t,n,r,a,s){this.separator=wa.encodeString(e),this.nGramWidths=t,this.leftPad=wa.encodeString(n),this.rightPad=wa.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let o=0;o<a;++o){const i=this.getPadWidth(s),l=Math.max(0,i-o),u=Math.max(0,i-(a-(o+1))),c=s-(l+u),d=t+(l>0?0:o-i);let h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length,h+=(l+u+c-1)*this.separator.length,n[r+o]=new Uint8Array(h);const p=n[r+o];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=r-1,s=wa.getArrayFromDType("int32",r);if(0===n||0===r){const e=new Array(n);for(let e=0;e<=a;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=a;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),s[e]=s[e-1]+r}const o=new Array(s[a]);for(let n=0;n<a;++n){const r=t[n];let a=s[n];if(this.nGramWidths.forEach((s=>{const i=t[n+1]-t[n],l=this.getNumNGrams(i,s);this.createNGrams(e,r,o,a,l,s),a+=l})),this.preserveShort&&a===s[n]){const s=t[n+1]-t[n];if(0===s)continue;const i=s+2*this.padWidth,l=1;this.createNGrams(e,r,o,a,l,i)}}return[o,s]}}(n,r,a,s,o,i).compute(e,t)}function mT(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const a=t[0];let s=e.indexOf(a);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}return void(n&&0===e.length||r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(a,s);n&&0===t.length||r.push(t),a=s+1}}function AT(e,t,n){const r=e.length,a=[];let s=0,o=0;const i=new Array(r);for(let l=0;l<r;++l){const r=a.length;mT(e[l],t,n,a);const u=a.length-r;i[l]=u,s+=u,o=Math.max(o,u)}const l=wa.getArrayFromDType("int32",2*s),u=new Array(s),c=[r,o];let d=0;for(let e=0;e<r;++e)for(let t=0;t<i[e];++t)l[2*d]=e,l[2*d+1]=t,u[d]=a[d],++d;return[l,u,c]}function gT(e,t){const n=wa.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=wa.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var yT=IE(((e,t)=>e-t)),xT=DE(((e,t,n,r)=>({real:e-n,imag:t-r}))),bT=OE(Gr,yT,xT),vT={kernelName:Gr,backendName:"cpu",kernelFunc:bT};function wT(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=Do(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),a=new Array(e.rank);for(let t=0;t<a.length;t++)a[t]=n[t]%e.shape[t];const s=e.locToIndex(a);r.values[t]=e.values[s]}return r}var kT=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function ST(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const a=r-n+1,s=t-n+1,o=Math.log(a),i=.5*Math.exp(2*o/3),l=.5*Math.sqrt(o*i*(a-i)/a)*Math.sign(s-a/2);ST(e,t,Math.max(n,Math.floor(t-s*i/a+l)),Math.min(r,Math.floor(t+(a-s)*i/a+l)))}const a=e[t];let s=n,o=r;for(wa.swap(e,n,t),kT(e[r],a)>0&&wa.swap(e,n,r);s<o;){for(wa.swap(e,s,o),s++,o--;kT(e[s],a)<0;)s+=1;for(;kT(e[o],a)>0;)o-=1}0===kT(e[n],a)?wa.swap(e,n,o):(o+=1,wa.swap(e,o,r)),o<=t&&(n=o+1),t<=o&&(r=o-1)}}function IT(e,t,n,r,a){const s=t[t.length-1],[o,i]=[e.length/s,s],l=wa.getTypedArrayFromDType(n,o*r),u=wa.getTypedArrayFromDType("int32",o*r);for(let t=0;t<o;t++){const n=t*i,s=e.subarray(n,n+i);let o=new Array(s.length);s.forEach(((e,t)=>o[t]={value:e,index:t})),r<o.length&&(ST(o,r),o=o.slice(0,r)),a&&o.sort(kT);const c=t*r,d=l.subarray(c,c+r),h=u.subarray(c,c+r);for(let e=0;e<r;e++)d[e]=o[e].value,h[e]=o[e].index}const c=t.slice();return c[c.length-1]=r,[Do(c,n,l),Do(c,"int32",u)]}function CT(e,t,n,r){const a=wa.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let e=0;e<a;e++)s[0]*=n[e];s[1]=n[a];for(let e=a+1;e<n.length;e++)s[2]*=n[e];const o={},i=new Int32Array(n[a]),l=new Za(s,r,e),u=[],c=1===s[0]&&1===s[2];for(let t=0;t<n[a];t++){let n;if(c)n=e[t].toString();else{const e=[];for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)e.push(l.get(n,t,r));n=e.join(",")}if(void 0!==o[n])i[t]=o[n];else{const e=Object.keys(o).length;o[n]=e,i[t]=e,u.push(t)}}const d=s.slice();d[1]=Object.keys(o).length;const h=new Za(d,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[a]=d[1],{outputValues:h.values,outputShape:p,indices:i}}Ei("cpu",(()=>new vE),1);var ET=jE(Kt,(e=>e>=0?e:Math.exp(e)-1)),NT={kernelName:Kt,backendName:"cpu",kernelFunc:ET};function TT(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;xE([a],"leakyRelu");const o=wa.sizeFromShape(a.shape),i=n.data.get(a.dataId).values,l=wa.getTypedArrayFromDType("float32",o);for(let e=0;e<i.length;e++)l[e]=i[e]<0?s*i[e]:i[e];return n.makeTensorInfo(a.shape,"float32",l)}var RT={kernelName:xn,backendName:"cpu",kernelFunc:TT},_T=IE(((e,t)=>e<0?t*e:e));function MT(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t;xE([r,a],"prelu");const s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,[i,l]=_T(r.shape,a.shape,s,o,"float32");return n.makeTensorInfo(l,"float32",i)}var $T={kernelName:ar,backendName:"cpu",kernelFunc:MT},FT=jE(ur,(e=>Math.max(0,e))),OT={kernelName:ur,backendName:"cpu",kernelFunc:FT},DT=jE(mr,(e=>Math.min(Math.max(0,e),6))),zT={kernelName:mr,backendName:"cpu",kernelFunc:DT};function PT(e,t,n,r,a){if("linear"===n)return TE({inputs:{x:t},backend:e});if("relu"===n)return FT({inputs:{x:t},backend:e});if("elu"===n)return ET({inputs:{x:t},backend:e});if("relu6"===n)return DT({inputs:{x:t},backend:e});if("prelu"===n)return MT({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return TT({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return QN({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function LT(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,o=wa.sizeFromShape(a.shape),i=wa.inferFromImplicitShape(s,o),l=wa.sizeFromShape(i);wa.assert(o===l,(()=>`The new shape (${i}) has ${l} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);const u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:a.dataId,shape:i,dtype:a.dtype}}var BT={kernelName:cr,backendName:"cpu",kernelFunc:LT};function WT(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:o,transposeB:i}=r;xE([a,s],"matMul");const l=a.shape.length,u=s.shape.length,c=o?a.shape[l-2]:a.shape[l-1],d=i?s.shape[u-1]:s.shape[u-2],h=o?a.shape[l-1]:a.shape[l-2],p=i?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),A=wa.sizeFromShape(f),g=wa.sizeFromShape(m),y=Oi.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);wa.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${o} and transposeB=${i} must match.`));const x=i?[g,p,d]:[g,d,p],b=LT({inputs:{x:a},backend:n,attrs:{shape:o?[A,c,h]:[A,h,c]}}),v=LT({inputs:{x:s},backend:n,attrs:{shape:x}}),w=o?b.shape[1]:b.shape[2],k=o?b.shape[2]:b.shape[1],S=i?v.shape[1]:v.shape[2],I=Math.max(A,g),C=n.data.get(b.dataId).values,E=n.data.get(v.dataId).values,N=wa.computeStrides(b.shape),T=wa.computeStrides(v.shape),[R,_,M]=o?[N[0],1,N[1]]:[N[0],N[1],1],[$,F,O]=i?[1,T[1],T[0]]:[T[1],1,T[0]],D=k*S,z=Do([I,k,S],b.dtype),P=z.values,L=n.blockSize;for(let e=0;e<I;e++)for(let t=0;t<k;t+=L)for(let n=0;n<S;n+=L)for(let r=0;r<w;r+=L){const a=Math.min(t+L,k),s=Math.min(n+L,S),o=Math.min(r+L,w);for(let i=t;i<a;i++)for(let t=n;t<s;t++){let n=0;for(let a=r;a<o;a++){const r=Math.min(e,A-1)*R,s=Math.min(e,g-1)*O;n+=C[r+i*_+a*M]*E[a*$+t*F+s]}P[e*D+(i*S+t)]+=n}}return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),n.makeTensorInfo(y,z.dtype,z.values)}var UT={kernelName:At,backendName:"cpu",kernelFunc:WT};var VT={kernelName:oa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=WT({inputs:{a:a,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),o&&(p=LE({inputs:{a:h,b:o},backend:n}),m.push(h),h=p),c&&(f=PT(n,h,c,i,d),m.push(h),h=f);for(const e of m)n.disposeIntermediateTensorInfo(e);return h}},jT=jE(Qe,(e=>Math.acos(e))),GT={kernelName:Qe,backendName:"cpu",kernelFunc:jT},HT=jE(et,(e=>Math.acosh(e))),qT={kernelName:et,backendName:"cpu",kernelFunc:HT};var XT={kernelName:nt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;xE(t,"addN");const a=r.map((e=>n.data.get(e.dataId).values)),s=Do(r[0].shape,r[0].dtype),o=s.values;for(let e=0;e<r.length;e++){const t=a[e];for(let e=0;e<o.length;e++)o[e]+=t[e]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};var KT={kernelName:rt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;xE(a,"all");const i=wa.parseAxisParam(s,a.shape);let l=i;const u=ff.getAxesPermutation(l,a.shape.length);let c=a;null!=u&&(c=VN({inputs:{x:a},backend:n,attrs:{perm:u}}),l=ff.getInnerMostAxes(l.length,a.shape.length)),ff.assertAxesAreInnerMostDims("all",l,c.shape.length);const[d,h]=ff.computeOutAndReduceShapes(c.shape,l),p=wa.sizeFromShape(h),f=wa.makeZerosTypedArray(wa.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];n=n&&r}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const A=n.makeTensorInfo(d,c.dtype,f);if(o){const e=LT({inputs:{x:A},backend:n,attrs:{shape:ff.expandShapeToKeepDim(d,i)}});return n.disposeIntermediateTensorInfo(A),e}return A}};var ZT={kernelName:at,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;xE(a,"any");const i=wa.parseAxisParam(s,a.shape);let l=i;const u=ff.getAxesPermutation(l,a.shape.length);let c=a;null!=u&&(c=VN({inputs:{x:a},backend:n,attrs:{perm:u}}),l=ff.getInnerMostAxes(l.length,a.shape.length)),ff.assertAxesAreInnerMostDims("any",l,c.shape.length);const[d,h]=ff.computeOutAndReduceShapes(c.shape,l),p=wa.sizeFromShape(h),f=wa.makeZerosTypedArray(wa.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];n=n||r}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const A=n.makeTensorInfo(d,c.dtype,f);if(o){const e=LT({inputs:{x:A},backend:n,attrs:{shape:ff.expandShapeToKeepDim(d,i)}});return n.disposeIntermediateTensorInfo(A),e}return A}};var YT={kernelName:st,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;xE(a,"argMax");let o=wa.parseAxisParam(s,a.shape);const i=ff.getAxesPermutation(o,a.shape.length);let l=a;const u=[];null!=i&&(l=VN({inputs:{x:a},backend:n,attrs:{perm:i}}),u.push(l),o=ff.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],ff.assertAxesAreInnerMostDims("argMax",o,l.shape.length);const[c,d]=ff.computeOutAndReduceShapes(l.shape,o),h=wa.sizeFromShape(c),p=wa.makeZerosTypedArray(h,"int32"),f=wa.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let e=0;e<p.length;++e){const t=e*f;let n=m[t],r=0;for(let e=0;e<f;++e){const a=m[t+e];a>n&&(n=a,r=e)}p[e]=r}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}};var JT={kernelName:ot,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;xE(a,"argMin");let o=wa.parseAxisParam(s,a.shape);const i=ff.getAxesPermutation(o,a.shape.length);let l=a;const u=[];null!=i&&(l=VN({inputs:{x:a},backend:n,attrs:{perm:i}}),u.push(l),o=ff.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],ff.assertAxesAreInnerMostDims("argMin",o,l.shape.length);const[c,d]=ff.computeOutAndReduceShapes(l.shape,o),h=wa.sizeFromShape(c),p=wa.makeZerosTypedArray(h,"int32"),f=wa.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let e=0;e<p.length;++e){const t=e*f;let n=m[t],r=0;for(let e=0;e<f;++e){const a=m[t+e];a<n&&(n=a,r=e)}p[e]=r}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}},QT=jE(it,(e=>Math.asin(e))),eR={kernelName:it,backendName:"cpu",kernelFunc:QT},tR=jE(lt,(e=>Math.asinh(e))),nR={kernelName:lt,backendName:"cpu",kernelFunc:tR},rR=jE(ut,(e=>Math.atan(e))),aR={kernelName:ut,backendName:"cpu",kernelFunc:rR},sR=IE(((e,t)=>Math.atan2(e,t))),oR=OE(dt,sR),iR={kernelName:dt,backendName:"cpu",kernelFunc:oR},lR=jE(ct,(e=>Math.atanh(e))),uR={kernelName:ct,backendName:"cpu",kernelFunc:lR};function cR(e,t,n,r,a,s){const o=a.strideHeight,i=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,c=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Do(a.outShape,n),A=m.values,g=a.outShape[1]*a.outShape[2]*a.outShape[3],y=a.outShape[2]*a.outShape[3],x=a.outShape[3];for(let t=0;t<a.batchSize;++t){const n=t*g,m=t*r[0];for(let t=0;t<a.inChannels;++t)for(let g=0;g<a.outHeight;++g){const b=g*o-h,v=Math.max(0,b),w=Math.min(a.inHeight,c+b),k=n+g*y;for(let n=0;n<a.outWidth;++n){const o=n*i-p,c=Math.max(0,o),h=Math.min(a.inWidth,d+o);let g=f,y=0,b=0;for(let n=v;n<w;n+=l){const a=m+n*r[1];for(let n=c;n<h;n+=u){const o=e[a+n*r[2]+t];"max"===s&&o>g?g=o:"avg"===s&&(y+=o,b++)}if(isNaN(g))break}A[k+n*x+t]="avg"===s?y/b:g}}}return m}function dR(e,t,n,r,a=!1,s=!1){const o=Do(r.outShape,"int32"),i=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Do(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){const A=n*i-p;let g=A;for(;g<0;)g+=u;const y=Math.min(r.inHeight,d+A);for(let i=0;i<r.outWidth;++i){const d=i*l-f;let p=d;for(;p<0;)p+=c;const x=Math.min(r.inWidth,h+d);let b=Number.NEGATIVE_INFINITY,v=-1;for(let n=g;n<y;n+=u){const o=n-A;for(let i=p;i<x;i+=c){const l=i-d,u=m.get(e,n,i,t);u>b&&(b=u,v=a?s?((e*r.inHeight+n)*r.inWidth+i)*r.inChannels+t:(n*r.inWidth+i)*r.inChannels+t:o*h+l)}}o.set(v,e,n,i,t)}}return o}function hR(e,t,n,r,a,s){const o=a.strideDepth,i=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,c=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,A=a.padInfo.top,g=a.padInfo.left,y="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Do(a.outShape,n),b=x.values,v=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],w=a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[3]*a.outShape[4],S=a.outShape[4];for(let t=0;t<a.batchSize;++t){const n=t*v,x=t*r[0];for(let t=0;t<a.inChannels;++t)for(let v=0;v<a.outDepth;++v){const I=v*o-m;let C=I;for(;C<0;)C+=u;const E=Math.min(a.inDepth,h+I),N=n+v*w;for(let n=0;n<a.outHeight;++n){const o=n*i-A;let h=o;for(;h<0;)h+=c;const m=Math.min(a.inHeight,p+o),v=N+n*k;for(let n=0;n<a.outWidth;++n){const o=n*l-g;let i=o;for(;i<0;)i+=d;const p=Math.min(a.inWidth,f+o),A=v+n*S;let w=y,k=0,I=0;for(let n=C;n<E;n+=u){const a=x+n*r[1];for(let n=h;n<m;n+=c){const o=a+n*r[2];for(let n=i;n<p;n+=d){const a=e[o+n*r[3]+t];if("max"===s&&a>w?w=a:"avg"===s&&(k+=a,I++),isNaN(w))break}if(isNaN(w))break}if(isNaN(w))break}b[A+t]="avg"===s?k/I:w}}}}return x}var pR={kernelName:ht,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;xE(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;wa.assert(ff.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=ff.computePool2DInfo(a.shape,s,o,1,i,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&wa.arraysEqual(u.inShape,u.outShape))c=TE({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=wa.computeStrides(a.shape),r=cR(e,a.shape,a.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,a.dtype,r.values)}return c}};var fR={kernelName:ft,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:u}=r;xE(a,"avgPool3d");const c=ff.computePool3DInfo(a.shape,s,o,1,i,l,u),d=hR(n.data.get(a.dataId).values,a.shape,a.dtype,wa.computeStrides(a.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};var mR={kernelName:mt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=r;xE([a,s],"avgPool3DGrad");const c=ff.computePool3DInfo(s.shape,o,i,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,A=c.filterWidth,g=c.dilationDepth,y=c.dilationHeight,x=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,k=b-1-c.padInfo.front,S=w-1-c.padInfo.left,I=v-1-c.padInfo.top,C=Do(s.shape,"float32"),E=1/(f*m*A),N=n.bufferSync(a);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let a=0;a<c.inWidth;++a){const s=n-k,o=r-I,i=a-S;let l=0;for(let n=0;n<b;n+=g){const r=(s+n)/d;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let n=0;n<v;n+=y){const a=(o+n)/h;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let n=0;n<w;n+=x){const s=(i+n)/p;if(s<0||s>=c.outWidth||Math.floor(s)!==s)continue;l+=N.get(e,r,a,s,t)}}}C.set(l*E,e,n,r,a,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};var AR={kernelName:pt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s;xE([a,s],"avgPoolGrad");const{filterSize:i,strides:l,pad:u}=r,c=ff.computePool2DInfo(o.shape,i,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,A=c.dilationWidth,g=c.effectiveFilterHeight,y=c.effectiveFilterWidth,x=y-1-c.padInfo.left,b=g-1-c.padInfo.top,v=Do(o.shape,"float32"),w=1/(p*f),k=n.data.get(a.dataId).values,S=Do(a.shape,"float32",k);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const a=n-b,s=r-x;let o=0;for(let n=0;n<g;n+=m){const r=(a+n)/d;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let n=0;n<y;n+=A){const a=(s+n)/h;if(a<0||a>=c.outWidth||Math.floor(a)!==a)continue;o+=S.get(e,r,a,t)}}v.set(o*w,e,n,r,t)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};var gR={kernelName:ln,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:o,mean:i,variance:l}=t;wa.assert(i.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),wa.assert(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),wa.assert(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),xE([a,i,l,s,o],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),A=f.length,g=p.length,y=h.length,x=d.length;let b=0,v=0,w=0,k=0;for(let e=0;e<c.length;++e)m[e]=f[b++]+(c[e]-d[v++])*p[w++]/Math.sqrt(h[k++]+u),b>=A&&(b=0),v>=x&&(v=0),w>=g&&(w=0),k>=y&&(k=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};var yR={kernelName:gt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:o}=r;xE([a],"batchToSpaceND");const i=s.reduce(((e,t)=>e*t)),l=ff.getReshaped(a.shape,s,i),u=ff.getPermuted(l.length,s.length),c=ff.getReshapedPermuted(a.shape,s,i),d=ff.getSliceBeginCoords(o,s.length),h=ff.getSliceSize(c,o,s.length),p=LT({inputs:{x:a},backend:n,attrs:{shape:l}}),f=VN({inputs:{x:p},backend:n,attrs:{perm:u}}),m=LT({inputs:{x:f},backend:n,attrs:{shape:c}}),A=nT({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),A}};var xR={kernelName:yt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:o}=r,i=WE(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,i)}};var bR={kernelName:bt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,i=ff.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},vR=jE(kt,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),wR={kernelName:kt,backendName:"cpu",kernelFunc:vR},kR={kernelName:It,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(wa.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,o=a.complexTensorInfos.imag,i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values;for(let e=0;e<i.length;e++){const t=i[e],n=l[e];r[e]=Math.hypot(t,n)}return n.makeOutput(r,t.shape,"float32")}};function SR(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var IR={kernelName:mn,backendName:"cpu",kernelFunc:SR};function CR(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=wa.parseAxisParam(a,t[0].shape)[0];let o=ff.computeOutShape(t.map((e=>e.shape)),s);if(0===wa.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>wa.sizeFromShape(e.shape)>0));if(1===i.length)return TE({inputs:{x:i[0]},backend:n});const l=i.map((e=>e.shape));if(ff.assertParamsConsistent(l,s),"complex64"===i[0].dtype){const e=i.map((e=>_E({inputs:{input:e},backend:n}))),t=i.map((e=>SR({inputs:{input:e},backend:n}))),r=CR({inputs:e,backend:n,attrs:{axis:s}}),a=CR({inputs:t,backend:n,attrs:{axis:s}}),o=CE({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),o}const u=i.map((e=>{const t=wa.sizeFromShape(e.shape.slice(s));return LT({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),c=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=ff.computeOutShape(u.map((e=>e.shape)),1);const d=1===u[0].shape[0],h=KE(c,o,t[0].dtype,d),p=ff.computeOutShape(i.map((e=>e.shape)),s),f=n.makeTensorInfo(p,t[0].dtype,h);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var ER={kernelName:Ct,backendName:"cpu",kernelFunc:CR};function NR(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=r;xE([a,s],"conv2d");const d=ff.convertConv2DDataFormat(l),h=ff.computeConv2DInfo(a.shape,s.shape,o,u,i,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,A=h.dilationWidth,g=h.padInfo.left,y=h.padInfo.top,x="channelsLast"===h.dataFormat,b=new Za(h.outShape,a.dtype),v=wa.computeStrides(a.shape),w=wa.computeStrides(s.shape),k=v[0],S=x?v[1]:v[2],I=x?v[2]:1,C=x?1:v[1],E=b.strides[0],N=x?b.strides[1]:b.strides[2],T=x?b.strides[2]:1,R=x?1:b.strides[1],_=n.data.get(a.dataId).values,M=n.data.get(s.dataId).values,$=b.values;for(let e=0;e<h.batchSize;++e){const t=e*k,n=e*E;for(let e=0;e<h.outHeight;++e){const r=n+e*N,a=e*h.strideHeight-y;for(let e=0;e<p;++e){const n=a+e*m;if(n<0||n>=h.inHeight)continue;const s=e*w[0],o=t+n*S;for(let e=0;e<h.outWidth;++e){const t=r+e*T,n=e*h.strideWidth-g;for(let e=0;e<f;++e){const r=n+e*A;if(r<0||r>=h.inWidth)continue;const a=o+r*I;let i=s+e*w[1];for(let e=0;e<h.inChannels;++e){const n=_[a+e*C];for(let e=0;e<h.outChannels;++e)$[t+e*R]+=n*M[i+e];i+=h.outChannels}}}}}}return n.makeTensorInfo(b.shape,b.dtype,$)}var TR={kernelName:Et,backendName:"cpu",kernelFunc:NR};var RR={kernelName:Nt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;xE([a,s],"conv2dBackpropFilter");const d=ff.convertConv2DDataFormat(l),h=ff.computeConv2DInfo(a.shape,c,o,1,i,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:A}=h,g="channelsLast"===h.dataFormat,y=new Za(h.filterShape,"float32"),x=h.padInfo.left,b=h.padInfo.top,v=n.data.get(a.dataId).values,w=n.data.get(s.dataId).values,k=new Za(a.shape,a.dtype,v),S=new Za(s.shape,s.dtype,w);for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((b-e)/p)),n=Math.min(h.outHeight,(h.inHeight+b-e)/p);for(let r=0;r<A;++r){const a=Math.max(0,Math.ceil((x-r)/f)),s=Math.min(h.outWidth,(h.inWidth+x-r)/f);for(let o=0;o<h.inChannels;++o)for(let i=0;i<h.outChannels;++i){let l=0;for(let u=0;u<h.batchSize;++u)for(let c=t;c<n;++c){const t=e+c*p-b;for(let e=a;e<s;++e){const n=r+e*f-x;l+=g?k.get(u,t,n,o)*S.get(u,c,e,i):k.get(u,o,t,n)*S.get(u,i,c,e)}}y.set(l,e,r,o,i)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var _R={kernelName:Tt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:o,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=r;xE([a,s],"conv2dBackpropInput");const d=wa.computeStrides(s.shape),h=wa.computeStrides(a.shape);let p=ff.convertConv2DDataFormat(u);const f=ff.computeConv2DInfo(o,s.shape,i,1,l,c,!1,p),m=new Za(f.inShape,"float32"),A=m.values,g=n.data.get(a.dataId).values,y=n.data.get(s.dataId).values,[x,b,v]=d,{batchSize:w,filterHeight:k,filterWidth:S,inChannels:I,inHeight:C,inWidth:E,outChannels:N,outHeight:T,outWidth:R,strideHeight:_,strideWidth:M}=f;p=f.dataFormat;const $=k-1-f.padInfo.top,F=S-1-f.padInfo.left,O="channelsLast"===p,D=m.strides[0],z=O?m.strides[1]:m.strides[2],P=O?m.strides[2]:1,L=O?1:m.strides[1],B=h[0],W=O?h[1]:h[2],U=O?h[2]:1,V=O?1:h[1];for(let e=0;e<w;++e)for(let t=0;t<I;++t)for(let n=0;n<C;++n){const r=n-$,a=Math.max(0,Math.ceil(r/_)),s=Math.min(T,(k+r)/_);for(let o=0;o<E;++o){const i=o-F,l=Math.max(0,Math.ceil(i/M)),u=Math.min(R,(S+i)/M);let c=0;for(let n=a;n<s;++n){const a=n*_-r;for(let r=l;r<u;++r){const s=B*e+W*n+U*r,o=x*(k-1-a)+b*(S-1-(r*M-i))+v*t;for(let e=0;e<N;++e){c+=g[s+V*e]*y[o+e]}}}A[D*e+z*n+P*o+L*t]=c}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};var MR={kernelName:Rt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:l}=r;xE([a,s],"conv3d");const u=ff.computeConv3DInfo(a.shape,s.shape,o,l,i),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:A}=u,g=A.front,y=A.left,x=A.top,b=new Za(u.outShape,a.dtype),v=n.data.get(a.dataId).values,w=n.data.get(s.dataId).values,k=b.values,S=wa.computeStrides(a.shape),I=wa.computeStrides(s.shape);for(let e=0;e<u.batchSize;++e){const t=e*S[0],n=e*b.strides[0];for(let e=0;e<u.outDepth;++e){const r=n+e*b.strides[1],a=e*u.strideDepth-g;for(let e=0;e<c;++e){const n=a+e*p;if(n<0||n>=u.inDepth)continue;const s=e*I[0],o=t+n*S[1];for(let e=0;e<u.outHeight;++e){const t=r+e*b.strides[2],n=e*u.strideHeight-x;for(let e=0;e<d;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const a=s+e*I[1],i=o+r*S[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-y;for(let e=0;e<h;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const s=a+e*I[2],o=i+t*u.inChannels;let l=s;for(let e=0;e<u.inChannels;++e){const t=v[o+e];for(let e=0;e<u.outChannels;++e)k[n+e]+=t*w[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var $R={kernelName:_t,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:i,filterShape:l}=r;xE([a,s],"conv3dBackpropFilterV2");const u=wa.computeStrides(a.shape),c=wa.computeStrides(s.shape),d=ff.computeConv3DInfo(a.shape,l,o,1,i),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,A=d.filterHeight,g=d.filterWidth,y=new Za(d.filterShape,"float32"),x=y.values,[b,v,w,k]=y.strides,S=n.data.get(s.dataId).values,[I,C,E,N]=c,T=n.data.get(a.dataId).values,[R,_,M,$]=u,F=d.padInfo.front,O=d.padInfo.left,D=d.padInfo.top;for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((F-e)/h)),n=Math.min(d.outDepth,(d.inDepth+F-e)/h),r=e*b;for(let a=0;a<A;++a){const s=Math.max(0,Math.ceil((D-a)/p)),o=Math.min(d.outHeight,(d.inHeight+D-a)/p),i=a*v+r;for(let r=0;r<g;++r){const l=Math.max(0,Math.ceil((O-r)/f)),u=Math.min(d.outWidth,(d.inWidth+O-r)/f),c=r*w+i;for(let i=0;i<d.inChannels;++i){const m=i*k+c;for(let c=0;c<d.outChannels;++c){let A=0;for(let m=0;m<d.batchSize;++m){const d=m*R,g=m*I;for(let m=t;m<n;++m){const t=(e+m*h-F)*_+d,n=m*C+g;for(let e=s;e<o;++e){const s=(a+e*p-D)*M+t,o=e*E+n;for(let e=l;e<u;++e){const t=e*N+o;A+=T[(r+e*f-O)*$+s+i]*S[t+c]}}}}x[m+c]=A}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var FR={kernelName:Mt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:o,strides:i,inputShape:l}=r;xE([a],"conv3dBackpropInputV2");const u=wa.computeStrides(a.shape),c=wa.computeStrides(s.shape),d=ff.computeConv3DInfo(l,s.shape,i,1,o),h=new Za(d.inShape,"float32"),p=h.values,[f,m,A,g]=h.strides,y=n.data.get(a.dataId).values,[x,b,v,w]=u,k=n.data.get(s.dataId).values,[S,I,C,E]=c,{batchSize:N,filterDepth:T,filterHeight:R,filterWidth:_,inChannels:M,inDepth:$,inHeight:F,inWidth:O,outChannels:D,outDepth:z,outHeight:P,outWidth:L,strideDepth:B,strideHeight:W,strideWidth:U}=d,V=T-1-d.padInfo.front,j=R-1-d.padInfo.top,G=_-1-d.padInfo.left;for(let e=0;e<N;++e)for(let t=0;t<M;++t)for(let n=0;n<$;++n){const r=n-V,a=Math.max(0,Math.ceil(r/B)),s=Math.min(z,(T+r)/B);for(let o=0;o<F;++o){const i=o-j,l=Math.max(0,Math.ceil(i/W)),u=Math.min(P,(R+i)/W);for(let c=0;c<O;++c){const d=c-G,h=Math.max(0,Math.ceil(d/U)),N=Math.min(L,(_+d)/U);let M=0;for(let n=a;n<s;++n){const a=n*B-r;for(let r=l;r<u;++r){const s=r*W-i;for(let o=h;o<N;++o){const i=x*e+b*n+v*r+w*o,l=S*(T-1-a)+I*(R-1-s)+C*(_-1-(o*U-d))+E*t;for(let e=0;e<D;++e){M+=y[i+e]*k[l+e]}}}}p[f*e+m*n+A*o+g*c+t]=M}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},OR=jE($t,(e=>Math.cos(e))),DR={kernelName:$t,backendName:"cpu",kernelFunc:OR},zR=jE(Ft,(e=>Math.cosh(e))),PR={kernelName:Ft,backendName:"cpu",kernelFunc:zR};var LR={kernelName:zt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:o}=t,{cropSize:i,method:l,extrapolationValue:u}=r,[c,d,h,p]=a.shape,f=s.shape[0],[m,A]=i,g=Do([f,m,A,p],"float32"),y=n.data.get(s.dataId).values,x=n.data.get(o.dataId).values,b=n.data.get(a.dataId).values,v=wa.computeStrides(a.shape),w=wa.computeStrides(g.shape);for(let e=0;e<f;e++){const t=4*e,n=y[t],r=y[t+1],a=y[t+2],s=y[t+3],o=x[e];if(o>=c)continue;const i=m>1?(a-n)*(d-1)/(m-1):0,f=A>1?(s-r)*(h-1)/(A-1):0;for(let t=0;t<m;t++){const c=m>1?n*(d-1)+t*i:.5*(n+a)*(d-1);if(c<0||c>d-1)for(let n=0;n<A;n++)for(let r=0;r<p;r++){const a=r+n*w[2]+t*w[1]+e*w[0];g.values[a]=u}else if("bilinear"===l){const n=Math.floor(c),a=Math.ceil(c),i=c-n;for(let l=0;l<A;l++){const c=A>1?r*(h-1)+l*f:.5*(r+s)*(h-1);if(c<0||c>h-1){for(let n=0;n<p;n++){const r=n+l*w[2]+t*w[1]+e*w[0];g.values[r]=u}continue}const d=Math.floor(c),m=Math.ceil(c),y=c-d;for(let r=0;r<p;r++){let s=r+d*v[2]+n*v[1]+o*v[0];const u=b[s];s=r+m*v[2]+n*v[1]+o*v[0];const c=b[s];s=r+d*v[2]+a*v[1]+o*v[0];const h=b[s];s=r+m*v[2]+a*v[1]+o*v[0];const p=u+(c-u)*y,f=h+(b[s]-h)*y;s=r+l*w[2]+t*w[1]+e*w[0],g.values[s]=p+(f-p)*i}}}else for(let n=0;n<A;++n){const a=A>1?r*(h-1)+n*f:.5*(r+s)*(h-1);if(a<0||a>h-1){for(let r=0;r<p;r++){const a=r+n*w[2]+t*w[1]+e*w[0];g.values[a]=u}continue}const i=Math.round(a),l=Math.round(c);for(let r=0;r<p;r++){const a=r+i*v[2]+l*v[1]+o*v[0],s=r+n*w[2]+t*w[1]+e*w[0];g.values[s]=b[a]}}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};var BR={kernelName:Ot,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;xE(a,"cumprod");const l=ff.getAxesPermutation([s],a.shape.length);let u=a;null!=l&&(u=VN({inputs:{x:a},backend:n,attrs:{perm:l}}));const c=ff.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=fs(u.dtype,"int32"),h=wa.makeOnesTypedArray(wa.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)h[n]=o?1:p[n];else{const r=m(e,t-1);h[n]=o?p[r]*h[r]:p[n]*h[r]}}const A=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=VN({inputs:{x:A},backend:n,attrs:{perm:ff.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(u),e}return A}};var WR={kernelName:Dt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;xE(a,"cumsum");const l=ff.getAxesPermutation([s],a.shape.length);let u=a;null!=l&&(u=VN({inputs:{x:a},backend:n,attrs:{perm:l}}));const c=ff.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=fs(u.dtype,"int32"),h=wa.makeZerosTypedArray(wa.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)h[n]=o?0:p[n];else{const r=m(e,t-1);h[n]=o?p[r]+h[r]:p[n]+h[r]}}const A=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=VN({inputs:{x:A},backend:n,attrs:{perm:ff.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(u),e}return A}};var UR={kernelName:Pt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:o,binaryOutput:i}=r;if(1===a.shape.length){const e=WE(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,e)}if(2===a.shape.length){const e=UE(n.bufferSync(a),n.bufferSync(s),o,i);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};var VR={kernelName:Lt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:o}=r;wa.assert("NHWC"===o,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`));const i=a.shape[0],l=a.shape[1],u=a.shape[2],c=a.shape[3],d=l*s,h=u*s,p=c/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(i*d*h*p);let A=0;for(let e=0;e<i;++e)for(let t=0;t<d;++t){const n=Math.floor(t/s),r=t%s;for(let t=0;t<h;++t){const a=Math.floor(t/s),o=(r*s+t%s)*p;for(let t=0;t<p;++t){const r=t+o+c*(a+u*(n+l*e));m[A++]=f[r]}}}return n.makeTensorInfo([i,d,h,p],a.dtype,m)}};function jR(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:l,dimRoundingMode:u}=r;xE([a,s],"depthwiseConv2DNative");const c=wa.computeStrides(a.shape),d=wa.computeStrides(s.shape);let h=l;null==h&&(h=[1,1]),wa.assert(ff.eitherStridesOrDilationsAreOne(o,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`));const p=ff.computeConv2DInfo(a.shape,s.shape,o,h,i,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:A,dilationWidth:g,padInfo:y}=p,x=y.left,b=y.top,v=p.outChannels/p.inChannels,w=new Za(p.outShape,a.dtype),k=n.data.get(a.dataId).values,S=n.data.get(s.dataId).values,I=w.values;for(let e=0;e<p.batchSize;++e){const t=e*c[0],n=e*w.strides[0];for(let e=0;e<p.outHeight;++e){const r=n+e*w.strides[1],a=e*p.strideHeight-b;for(let e=0;e<f;++e){const n=a+e*A;if(n<0||n>=p.inHeight)continue;const s=e*d[0],o=t+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*w.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const r=n+e*g;if(r<0||r>=p.inWidth)continue;const a=s+e*d[1],i=o+r*p.inChannels;let l=t,u=a;for(let e=0;e<p.inChannels;++e){const t=k[i+e];for(let e=0;e<v;++e)I[l+e]+=t*S[u+e];l+=v,u+=v}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var GR={kernelName:Bt,backendName:"cpu",kernelFunc:jR};var HR={kernelName:Wt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=r;xE([a,s],"depthwiseConv2dNativeBackpropFilter");const d=ff.computeConv2DInfo(a.shape,c,o,i,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,A=new Za(d.filterShape,"float32"),g=d.padInfo.left,y=d.padInfo.top,x=d.outChannels/d.inChannels,b=n.data.get(a.dataId).values,v=new Za(a.shape,a.dtype,b),w=n.data.get(s.dataId).values,k=new Za(s.shape,s.dtype,w);for(let e=0;e<f;++e){const t=Math.max(0,Math.ceil((y-e)/h)),n=Math.min(d.outHeight,(d.inHeight+y-e)/h);for(let r=0;r<m;++r){const a=Math.max(0,Math.ceil((g-r)/p)),s=Math.min(d.outWidth,(d.inWidth+g-r)/p);for(let o=0;o<d.outChannels;++o){const i=Math.trunc(o/x),l=o%x;let u=0;for(let l=0;l<d.batchSize;++l)for(let c=t;c<n;++c){const t=e+c*h-y;for(let e=a;e<s;++e){const n=r+e*p-g;u+=v.get(l,t,n,i)*k.get(l,c,e,o)}}A.set(u,e,r,i,l)}}}return n.makeTensorInfo(A.shape,A.dtype,A.values)}};var qR={kernelName:Ut,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=r;xE([a,s],"depthwiseConv2DNativeBackpropInput");const d=wa.computeStrides(a.shape),h=wa.computeStrides(s.shape),p=ff.computeConv2DInfo(c,s.shape,o,i,l,u,!0),f=new Za(p.inShape,"float32"),m=f.values,[A,g,y]=f.strides,x=n.data.get(a.dataId).values,[b,v,w]=d,k=n.data.get(s.dataId).values,[S,I,C]=h,{batchSize:E,filterHeight:N,filterWidth:T,inChannels:R,inHeight:_,inWidth:M,outChannels:$,outHeight:F,outWidth:O,strideHeight:D,strideWidth:z}=p,P=N-1-p.padInfo.top,L=T-1-p.padInfo.left,B=$/R;for(let e=0;e<E;++e)for(let t=0;t<R;++t)for(let n=0;n<_;++n){const r=n-P,a=Math.max(0,Math.ceil(r/D)),s=Math.min(F,(N+r)/D);for(let o=0;o<M;++o){const i=o-L,l=Math.max(0,Math.ceil(i/z)),u=Math.min(O,(T+i)/z);let c=0;for(let n=a;n<s;++n){const a=n*D-r;for(let r=l;r<u;++r){const s=b*e+v*n+w*r,o=S*(N-1-a)+I*(T-1-(r*z-i))+C*t;for(let e=0;e<B;++e){c+=x[s+(t*B+e)]*k[o+e]}}}m[A*e+g*n+y*o+t]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};var XR={kernelName:Vt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=wa.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,o=Do([a,a],r.dtype),i=o.values;for(let e=0;e<s.length;e++)i[e*a+e]=s[e];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,o.dtype,o.values)}},KR={kernelName:jt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:a}=e,{strides:s,pad:o,dilations:i}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(a.dataId).values,h=a.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:A,outHeight:g,outWidth:y,padInfo:x,strideHeight:b,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:C}=ff.computeDilation2DInfo(r.shape,a.shape,s,o,"NHWC",i),E=wa.sizeFromShape(C),N=C.length,T=wa.getArrayFromDType(r.dtype,E);for(let e=0;e<p;++e)for(let t=0;t<g;++t){const n=t*b-x.top;for(let s=0;s<y;++s){const o=s*v-x.left;for(let i=0;i<A;++i){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<w;++t){const s=n+t*S;if(s>=0&&s<f)for(let n=0;n<k;++n){const p=o+n*I;if(p>=0&&p<m){const o=wa.locToIndex([e,s,p,i],c,wa.computeStrides(r.shape)),f=wa.locToIndex([t,n,i],h,wa.computeStrides(a.shape)),m=u[o]+d[f];m>l&&(l=m)}}}T[wa.locToIndex([e,t,s,i],N,wa.computeStrides(C))]=l}}}return{dataId:l.write(wa.toTypedArray(T,r.dtype),C,r.dtype),shape:C,dtype:r.dtype}}},ZR={kernelName:Ht,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:a,dy:s}=e,{strides:o,pad:i,dilations:l}=n,u=t,c=wa.toNestedArray(r.shape,u.data.get(r.dataId).values),d=wa.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:A,outWidth:g,padInfo:y,strideHeight:x,strideWidth:b,filterHeight:v,filterWidth:w,dilationHeight:k,dilationWidth:S,outShape:I}=ff.computeDilation2DInfo(r.shape,a.shape,o,i,"NHWC",l);wa.assert(s.rank===I.length,(()=>`Error in ${Ht}, dy must have the same rank as output ${I.length}, but got ${s.rank}`));const C=wa.toNestedArray(I,u.data.get(s.dataId).values),E=wa.makeZerosNestedTypedArray(a.shape,a.dtype);for(let e=0;e<h;++e)for(let t=0;t<A;++t){const n=t*x-y.top;for(let r=0;r<g;++r){const a=r*b-y.left;for(let s=0;s<m;++s){let o=Number.MIN_SAFE_INTEGER,i=0,l=0;for(let t=0;t<v;++t){const r=n+t*k;if(r>=0&&r<p)for(let n=0;n<w;++n){const u=a+n*S;if(u>=0&&u<f){const a=c[e][r][u][s]+d[t][n][s];a>o&&(o=a,i=t,l=n)}}}E[i][l][s]+=C[e][t][r][s]}}}return{dataId:u.write(wa.toTypedArray(E,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},YR={kernelName:Gt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:a,dy:s}=e,{strides:o,pad:i,dilations:l}=n,u=t,c=wa.toNestedArray(r.shape,u.data.get(r.dataId).values),d=wa.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:A,outWidth:g,padInfo:y,strideHeight:x,strideWidth:b,filterHeight:v,filterWidth:w,dilationHeight:k,dilationWidth:S,outShape:I}=ff.computeDilation2DInfo(r.shape,a.shape,o,i,"NHWC",l);wa.assert(s.rank===I.length,(()=>`Error in ${Gt}, dy must have the same rank as output ${I.length}, but got ${s.rank}`));const C=wa.toNestedArray(I,u.data.get(s.dataId).values),E=wa.makeZerosNestedTypedArray(r.shape,r.dtype);for(let e=0;e<h;++e)for(let t=0;t<A;++t){const n=t*x-y.top;for(let r=0;r<g;++r){const a=r*b-y.left;for(let s=0;s<m;++s){let o=Number.MIN_SAFE_INTEGER,i=n<0?0:n,l=a<0?0:a;for(let t=0;t<v;++t){const r=n+t*k;if(r>=0&&r<p)for(let n=0;n<w;++n){const u=a+n*S;if(u>=0&&u<f){const a=c[e][r][u][s]+d[t][n][s];a>o&&(o=a,i=r,l=u)}}}E[e][i][l][s]+=C[e][t][r][s]}}}return{dataId:u.write(wa.toTypedArray(E,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function JR(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;let i;xE(a,"sum"),i="bool"===a.dtype?$E({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):TE({inputs:{x:a},backend:n});const l=i.shape.length,u=wa.parseAxisParam(s,i.shape),c=ff.getAxesPermutation(u,l);let d=u,h=i;null!=c&&(h=VN({inputs:{x:i},backend:n,attrs:{perm:c}}),d=ff.getInnerMostAxes(d.length,l)),ff.assertAxesAreInnerMostDims("sum",d,h.shape.length);const[p,f]=ff.computeOutAndReduceShapes(h.shape,d);let m=NE(n,p,ff.upcastType(h.dtype,"int32"));const A=wa.sizeFromShape(f),g=n.data.get(m.dataId).values,y=n.data.get(h.dataId).values;for(let e=0;e<g.length;++e){const t=e*A;let n=0;for(let e=0;e<A;++e)n+=y[t+e];g[e]=n}if(o){const e=m;m=LT({inputs:{x:m},backend:n,attrs:{shape:ff.expandShapeToKeepDim(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=c&&n.disposeIntermediateTensorInfo(h),m}var QR={kernelName:Rr,backendName:"cpu",kernelFunc:JR};var e_={kernelName:Xt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:o,summedDims:i,idDims:l}=ff.decodeEinsumEquation(a,s.length);ff.checkEinsumDimSizes(o.length,l,s);const{path:u,steps:c}=ff.getEinsumComputePath(i,l),d=c.length;let h=null,p=o.length;const f=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:r}=ff.getEinsumPermutation(p,l[t]);let a;ff.isIdentityPermutation(e)?a=s[t]:(a=VN({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(a));const o=a.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);wa.arraysEqual(a.shape,o)||(a=LT({inputs:{x:a},backend:n,attrs:{shape:o}}),f.push(a)),null===h?h=a:(h=ON({inputs:{a:a,b:h},backend:n}),f.push(h))}e<d-1&&(u[e]>=0&&(h=JR({inputs:{x:h},backend:n,attrs:{axis:u[e]-(o.length-p),keepDims:!1}}),f.push(h)),p--)}for(const e of f)e!==h&&n.disposeIntermediateTensorInfo(e);return h}};var t_={kernelName:Zt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:a}=t;xE([r,a],"eluGrad");const s=new Float32Array(wa.sizeFromShape(a.shape)),o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values;for(let e=0;e<o.length;++e){const t=o[e];s[e]=t>=1?i[e]:i[e]*(t+1)}return n.makeTensorInfo(a.shape,"float32",s)}},n_=ff.ERF_P,r_=ff.ERF_A1,a_=ff.ERF_A2,s_=ff.ERF_A3,o_=ff.ERF_A4,i_=ff.ERF_A5,l_=jE(Yt,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+n_*n);return t*(1-((((i_*r+o_)*r+s_)*r+a_)*r+r_)*r*Math.exp(-n*n))})),u_={kernelName:Yt,backendName:"cpu",kernelFunc:l_};function c_(e){const{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,o=a.shape.length,i=a.shape.slice();let l=s;return s<0&&(wa.assert(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+s+1),i.splice(l,0,1),LT({inputs:{x:a},backend:n,attrs:{shape:i}})}var d_={kernelName:en,backendName:"cpu",kernelFunc:c_},h_=IE(((e,t)=>e/t)),p_=OE(qt,h_),f_={kernelName:qt,backendName:"cpu",kernelFunc:p_};function m_(e,t,n){const r=e.shape,a=r[0],s=r[1],o=n.data.get(e.dataId),i=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[a,s],c=wa.sizeFromShape(u),d=wa.getTypedArrayFromDType("float32",c),h=wa.getTypedArrayFromDType("float32",c);for(let e=0;e<a;e++){const r=nT({inputs:{x:i},backend:n,attrs:{begin:[e,0],size:[1,s]}}),a=nT({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,s]}}),o=CE({inputs:{real:r,imag:a},backend:n}),{real:u,imag:c}=A_(o,t,n),p=ff.mergeRealAndImagArrays(u,c);for(let t=0;t<s;t++){const n=ff.getComplexWithIndex(p,t);d[e*s+t]=n.real,h[e*s+t]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o)}const p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=CE({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function A_(e,t,n){const r=wa.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,o=n.data.get(a.complexTensorInfos.imag.dataId).values;if(0==((i=r)&i-1)){const a=g_(s,o,r,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",a.real),t=n.makeTensorInfo(i,"float32",a.imag),s=n.makeTensorInfo([],"float32",wa.createScalarValue(r,"float32")),o=TE({inputs:{x:s},backend:n}),l=f_.kernelFunc({inputs:{a:e,b:s},backend:n}),u=f_.kernelFunc({inputs:{a:t,b:o},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return a}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,o=0;for(let r=0;r<t;r++){const i=ff.exponent(a*r,t,n),l=ff.getComplexWithIndex(e,r);s+=l.real*i.real-l.imag*i.imag,o+=l.real*i.imag+l.imag*i.real}n&&(s/=t,o/=t),ff.assignToTypedArray(r,s,o,a)}return r}(ff.mergeRealAndImagArrays(s,o),r,t);return ff.splitRealAndImagArrays(e)}var i}function g_(e,t,n,r,a){if(1===n)return{real:e,imag:t};const s=ff.mergeRealAndImagArrays(e,t),o=n/2,i=ff.complexWithEvenIndex(s),l=i.real,u=i.imag,c=[l.length],d=a.makeTensorInfo(c,"float32",l),h=a.makeTensorInfo(c,"float32",u),p=CE({inputs:{real:d,imag:h},backend:a}),f=ff.complexWithOddIndex(s),m=f.real,A=f.imag,g=[m.length],y=a.makeTensorInfo(g,"float32",m),x=a.makeTensorInfo(g,"float32",A),b=CE({inputs:{real:y,imag:x},backend:a}),v=g_(l,u,o,r,a),w=v.real,k=v.imag,S=[w.length],I=a.makeTensorInfo(S,"float32",w),C=a.makeTensorInfo(S,"float32",k),E=CE({inputs:{real:I,imag:C},backend:a}),N=g_(m,A,o,r,a),T=N.real,R=N.imag,_=[T.length],M=a.makeTensorInfo(_,"float32",T),$=a.makeTensorInfo(_,"float32",R),F=CE({inputs:{real:M,imag:$},backend:a}),O=ff.exponents(n,r),D=[O.real.length],z=a.makeTensorInfo(D,"float32",O.real),P=a.makeTensorInfo(D,"float32",O.imag),L=CE({inputs:{real:z,imag:P},backend:a}),B=ON({inputs:{a:L,b:F},backend:a}),W=LE({inputs:{a:E,b:B},backend:a}),U=bT({inputs:{a:E,b:B},backend:a}),V=_E({inputs:{input:W},backend:a}),j=_E({inputs:{input:U},backend:a}),G=SR({inputs:{input:W},backend:a}),H=SR({inputs:{input:U},backend:a}),q=CR({inputs:[V,j],backend:a,attrs:{axis:0}}),X=CR({inputs:[G,H],backend:a,attrs:{axis:0}}),K=a.data.get(q.dataId).values,Z=a.data.get(X.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(I),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(E),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo($),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(X),{real:K,imag:Z}}var y_={kernelName:nn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=wa.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],o=LT({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),i=m_(o,!1,n),l=LT({inputs:{x:i},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),l}};function x_(e){const{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,o=s||wa.inferDtype(a),i=wa.getArrayFromDType(o,wa.sizeFromShape(r));return function(e,t,n){e.fill(t)}(i,a),t.makeTensorInfo(r,o,i)}var b_={kernelName:rn,backendName:"cpu",kernelFunc:x_};var v_={kernelName:an,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,a=n,s=wa.getTypedArrayFromDType(r.dtype,wa.sizeFromShape(r.shape)),[o,i,l,u]=r.shape,c=a.data.get(r.dataId).values;for(let e=0;e<o;e++){const t=e*l*i*u;for(let e=0;e<i;e++){const n=e*(l*u);for(let e=0;e<l;e++){const r=e*u;for(let a=0;a<u;a++){const o=Math.round(l-e-1),i=t+n+r+a;let d=c[i];if(o>=0&&o<l){d=c[t+n+o*u+a]}s[i]=d}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},w_=IE(((e,t)=>Math.floor(e/t))),k_=OE(on,w_,null,"int32"),S_={kernelName:on,backendName:"cpu",kernelFunc:k_};var I_={kernelName:ia,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=NR({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(o){const e=m;if("NCHW"===c&&1===o.shape.length&&1!==o.shape[0]){const e=LT({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=LE({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=LE({inputs:{a:m,b:o},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const e=LT({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=PT(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=PT(n,m,p,i,f);n.disposeIntermediateTensorInfo(e)}return m}};var C_={kernelName:la,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=jR({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(o){const e=m;m=LE({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=PT(n,m,p,i,f),n.disposeIntermediateTensorInfo(e)}return m}};var E_={kernelName:cn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=wa.sizeFromShape(r.shape),o=a.shape,i=o[o.length-1],[l,u,c,d]=ff.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const h=lN(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,i,c,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,h.values)}};var N_={kernelName:un,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:o,batchDims:i}=r;xE([a,s],"gatherV2");const l=wa.parseAxisParam(o,a.shape)[0],u=n.data.get(s.dataId).values,c=a.shape[l];for(let e=0;e<u.length;++e){const t=u[e];wa.assert(t<=c-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${c-1}]`))}let d=i;null==i&&(d=0);const h=wa.sizeFromShape(s.shape),p=ff.segment_util.collectGatherOpShapeInfo(a,s,l,d),f=LT({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=LT({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),A=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],g=n.bufferSync(m),y=uN(n.bufferSync(f),g,A);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}};var T_={kernelName:fn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=wa.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],o=LT({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),i=m_(o,!0,n),l=LT({inputs:{x:i},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),l}},R_=jE(An,(e=>Number.isFinite(e)?1:0),"bool"),__={kernelName:An,backendName:"cpu",kernelFunc:R_},M_=jE(gn,(e=>Math.abs(e)===1/0?1:0),"bool"),$_={kernelName:gn,backendName:"cpu",kernelFunc:M_},F_=jE(yn,(e=>Number.isNaN(e)?1:0),"bool"),O_={kernelName:yn,backendName:"cpu",kernelFunc:F_};var D_={kernelName:wn,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,o=wN(r,a,s);return t.makeTensorInfo([o.length],"float32",o)}},z_=jE(Sn,(e=>Math.log1p(e))),P_={kernelName:Sn,backendName:"cpu",kernelFunc:z_},L_=IE(((e,t)=>e&&t)),B_=OE(In,L_,null,"bool"),W_={kernelName:In,backendName:"cpu",kernelFunc:B_},U_=jE(Cn,(e=>e?0:1),"bool"),V_={kernelName:Cn,backendName:"cpu",kernelFunc:U_},j_=IE(((e,t)=>e||t)),G_=OE(En,j_,null,"bool"),H_={kernelName:En,backendName:"cpu",kernelFunc:G_};var q_={kernelName:_n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:o,alpha:i,beta:l}=r;xE(a,"LRN");const u=a.shape[3],c=u-1,d=n.data.get(a.dataId).values,h=wa.sizeFromShape(a.shape),p=new Float32Array(h);function f(e){const t=e%u;let n=e-t+Math.max(0,t-s);const r=e-t+Math.min(t+s,c);let a=0;for(;n<=r;n++){const e=d[n];a+=e*e}return a}for(let e=0;e<h;e++){const t=f(e),n=d[e]*Math.pow(o+i*t,-l);p[e]=n}return n.makeTensorInfo(a.shape,a.dtype,p)}};var X_={kernelName:Mn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:o}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=r;xE(o,"LRNGrad");const d=wa.sizeFromShape(o.shape),h=o.shape[3],p=n.data.get(o.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,A=new Float32Array(d),g=d;for(let e=0;e<g;e++){const t=e%h,n=e-t+Math.max(0,t-i),r=e-t+Math.min(h,t+i+1);let a=0;for(let e=n;e<r;e++)a+=Math.pow(f[e],2);a=u*a+l;for(let t=n;t<r;t++){let n=-2*u*c*f[t]*m[e]/a;e===t&&(n+=Math.pow(a,-c)),n*=p[e],A[t]+=n}}return n.makeTensorInfo(o.shape,a.dtype,A)}};function K_(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:o}=r,i=n;let l=a.shape;const u=l.length,c=wa.parseAxisParam(s,l);let d=c;const h=ff.getAxesPermutation(d,u);let p=i.data.get(a.dataId).values;if(null!=h){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=UN(p,l,a.dtype,h,e),d=ff.getInnerMostAxes(d.length,u),l=e}xE(a,"max"),ff.assertAxesAreInnerMostDims("max",d,u);const[f,m]=ff.computeOutAndReduceShapes(l,d),A=CN(p,wa.sizeFromShape(m),f,a.dtype),g=i.write(A,f,a.dtype);let y=f;if(o){y=ff.expandShapeToKeepDim(f,c)}return{dataId:g,shape:y,dtype:a.dtype}}var Z_={kernelName:$n,backendName:"cpu",kernelFunc:K_};var Y_={kernelName:On,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;xE(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;wa.assert(ff.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=ff.computePool2DInfo(a.shape,s,o,1,i,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&wa.arraysEqual(u.inShape,u.outShape))c=TE({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=wa.computeStrides(a.shape),r=cR(e,a.shape,a.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,a.dtype,r.values)}return c}};var J_={kernelName:zn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:u}=r;xE(a,"maxPool3d");const c=ff.computePool3DInfo(a.shape,s,o,1,i,l,u),d=hR(n.data.get(a.dataId).values,a.shape,a.dtype,wa.computeStrides(a.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};var Q_={kernelName:Pn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=r;xE([a,s],"maxPool3DGrad");const c=ff.computePool3DInfo(s.shape,o,i,1,l,u),d=function(e,t){const n=Do(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let A=0;A<t.inChannels;++A)for(let g=0;g<t.outDepth;++g){const y=g*r-h;let x=y;for(;x<0;)x+=o;const b=Math.min(t.inDepth,u+y);for(let r=0;r<t.outHeight;++r){const u=r*a-p;let h=u;for(;h<0;)h+=i;const v=Math.min(t.inHeight,c+u);for(let a=0;a<t.outWidth;++a){const p=a*s-f;let w=p;for(;w<0;)w+=l;const k=Math.min(t.inWidth,d+p);let S=Number.NEGATIVE_INFINITY,I=-1;for(let t=x;t<b;t+=o){const n=t-y;for(let r=h;r<v;r+=i){const a=r-u;for(let s=w;s<k;s+=l){const o=s-p,i=e.get(m,t,r,s,A);i>=S&&(S=i,I=n*c*d+a*c+o)}}}n.set(I,m,g,r,a,A)}}}return n}(n.bufferSync(s),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,A=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterDepth,x=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=y-1-c.padInfo.front,w=b-1-c.padInfo.left,k=x-1-c.padInfo.top,S=Do(s.shape,"float32"),I=n.bufferSync(a);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let a=0;a<c.inWidth;++a){const s=n-v,o=r-k,i=a-w;let l=0;for(let n=0;n<y;n+=m){const r=(s+n)/h;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let a=0;a<x;a+=A){const s=(o+a)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let o=0;o<b;o+=g){const u=(i+o)/f;if(u<0||u>=c.outWidth||Math.floor(u)!==u)continue;const h=y*x*b-1-d.get(e,r,s,u,t)===n*x*b+a*b+o?1:0;if(0===h)continue;l+=I.get(e,r,s,u,t)*h}}}S.set(l,e,n,r,a,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};var eM={kernelName:Dn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:o}=t,i=s;xE([s,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=ff.computePool2DInfo(i.shape,l,u,1,c,d),p=n.data.get(i.dataId).values,f=Do(h.outShape,i.dtype,dR(p,i.shape,i.dtype,h).values),m=h.strideHeight,A=h.strideWidth,g=h.dilationHeight,y=h.dilationWidth,x=h.effectiveFilterHeight,b=h.effectiveFilterWidth,v=b-1-h.padInfo.left,w=x-1-h.padInfo.top,k=Do(i.shape,"float32"),S=n.data.get(a.dataId).values,I=Do(a.shape,"float32",S);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let n=0;n<h.inHeight;++n)for(let r=0;r<h.inWidth;++r){const a=n-w,s=r-v;let o=0;for(let n=0;n<x;n+=g){const r=(a+n)/m;if(!(r<0||r>=h.outHeight||Math.floor(r)!==r))for(let a=0;a<b;a+=y){const i=(s+a)/A;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;const l=x*b-1-f.get(e,r,i,t)===n*b+a?1:0;if(0===l)continue;o+=I.get(e,r,i,t)*l}}k.set(o,e,n,r,t)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}};var tM={kernelName:Ln,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:a,strides:s,pad:o,includeBatchInIndex:i}=t,l=n;xE(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=ff.computePool2DInfo(r.shape,a,s,[1,1],o),[d,h]=function(e,t,n,r,a){const s=cR(e,0,n,wa.computeStrides(t),a,"max"),o=dR(e,t,n,a,!0,r);return[s.values,o.values]}(u,r.shape,r.dtype,i,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};var nM={kernelName:Bn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=wa.parseAxisParam(s,a.shape),l=ff.computeOutAndReduceShapes(a.shape,i)[1],u=wa.sizeFromShape(l),c=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(d);const h=$E({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(h);const p=p_({inputs:{a:h,b:d},backend:n});c.push(p);const f=JR({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:o}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};var rM={kernelName:Wn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;xE(a,"min");const i=wa.parseAxisParam(s,a.shape);let l=i;const u=ff.getAxesPermutation(l,a.shape.length);let c=a;null!=u&&(c=VN({inputs:{x:a},backend:n,attrs:{perm:u}}),l=ff.getInnerMostAxes(l.length,a.shape.length)),ff.assertAxesAreInnerMostDims("min",l,c.shape.length);const[d,h]=ff.computeOutAndReduceShapes(c.shape,l),p=wa.sizeFromShape(h),f=wa.makeZerosTypedArray(wa.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];(Number.isNaN(r)||r<n)&&(n=r)}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const A=n.makeTensorInfo(d,c.dtype,f);if(o){const e=LT({inputs:{x:A},backend:n,attrs:{shape:ff.expandShapeToKeepDim(d,i)}});return n.disposeIntermediateTensorInfo(A),e}return A}};var aM={kernelName:Vn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:o}=r;xE(a,"mirrorPad");const i=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),c="reflect"===o?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,p=wa.computeStrides(a.shape),f=wa.sizeFromShape(i),m=i.length,A=wa.computeStrides(i),g=wa.getTypedArrayFromDType(a.dtype,f);for(let e=0;e<f;e++){let t=wa.indexToLoc(e,m,A);for(let e=0;e<m;e++)t[e]<l[e]?t[e]=2*l[e]-t[e]-c:t[e]>=u[e]&&(t[e]=2*(u[e]-1)-t[e]+c);t=t.map(((e,t)=>e-l[t]));const n=wa.locToIndex(t,h,p);g[e]=d[n]}return{dataId:n.write(g,i,a.dtype),shape:i,dtype:a.dtype}}},sM=IE(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),oM=OE(jn,sM),iM={kernelName:jn,backendName:"cpu",kernelFunc:oM},lM=I(z());function uM(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,o=a.shape.length;let i=s;if(-1===i&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);const l=wa.parseAxisParam([i],a.shape),u=K_({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=ff.expandShapeToKeepDim(u.shape,l),d=LT({inputs:{x:u},backend:n,attrs:{shape:c}}),h=bT({inputs:{a:a,b:d},backend:n}),p=eN({inputs:{x:h},backend:n}),f=JR({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=LT({inputs:{x:f},backend:n,attrs:{shape:c}}),A=p_({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),A}var cM={kernelName:$r,backendName:"cpu",kernelFunc:uM};var dM={kernelName:Gn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:o,normalized:i}=r;xE(a,"multinomial");const l=i?a:uM({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,s],p=wa.makeZerosTypedArray(wa.sizeFromShape(h),"int32");for(let e=0;e<u;++e){const t=e*c,n=new Float32Array(c-1);n[0]=d[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+d[t+e];const r=lM.alea(o.toString()),a=e*s;for(let e=0;e<s;++e){const t=r();p[a+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){p[a+e]=r;break}}}return i||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}},hM=fm.nonMaxSuppressionV3Impl;var pM={kernelName:Kn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=r;xE(a,"NonMaxSuppression");const u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=hM(u,c,o,i,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},fM=fm.nonMaxSuppressionV4Impl;var mM={kernelName:Zn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=r;xE(a,"NonMaxSuppressionPadded");const c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=fM(c,d,o,i,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},AM=fm.nonMaxSuppressionV5Impl;var gM={kernelName:Yn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=r;xE(a,"NonMaxSuppressionWithScore");const c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=o,p=i,f=l,m=u,{selectedIndices:A,selectedScores:g}=AM(c,d,h,p,f,m);return[n.makeTensorInfo([A.length],"int32",new Int32Array(A)),n.makeTensorInfo([g.length],"float32",new Float32Array(g))]}};var yM={kernelName:Qn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{depth:s,onValue:o,offValue:i}=r;xE(a,"oneHot");const l=wa.sizeFromShape(a.shape),u=new Float32Array(l*s);u.fill(i);const c=n.data.get(a.dataId).values;for(let e=0;e<l;++e)c[e]>=0&&c[e]<s&&(u[e*s+c[e]]=o);return n.makeTensorInfo([...a.shape,s],"int32",u)}};function xM(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=_E({inputs:{input:r},backend:n}),t=xM({inputs:{x:e},backend:n}),a=SR({inputs:{input:r},backend:n}),s=xM({inputs:{x:a},backend:n}),o=CE({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return x_({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var bM={kernelName:na,backendName:"cpu",kernelFunc:xM};var vM={kernelName:Jn,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const t=_E({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=SR({inputs:{input:a},backend:r}),o=xM({inputs:{x:s},backend:r}),i=CE({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}return x_({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function wM(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return c_({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{wa.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),wa.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=CR({inputs:t.map((e=>{const t=c_({inputs:{input:e},backend:n,attrs:{dim:a}});return i.push(t),t})),backend:n,attrs:{axis:a}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}var kM={kernelName:er,backendName:"cpu",kernelFunc:wM};var SM={kernelName:tr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:o}=r;xE(a,"pad");const i=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,c=wa.sizeFromShape(a.shape),d=a.shape.length,h=wa.computeStrides(a.shape),p=wa.sizeFromShape(i),f=i.length,m=wa.computeStrides(i),A=wa.getTypedArrayFromDType(a.dtype,p);0!==o&&A.fill(o);for(let e=0;e<c;e++){const t=wa.indexToLoc(e,d,h).map(((e,t)=>e+l[t]));A[wa.locToIndex(t,f,m)]=u[e]}return{dataId:n.write(A,i,a.dtype),shape:i,dtype:a.dtype}}},IM=IE(((e,t)=>Math.pow(e,t))),CM=OE(rr,IM),EM={kernelName:rr,backendName:"cpu",kernelFunc:CM};var NM={kernelName:or,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:o}=n,i=qN(r,a,o,s);return t.makeTensorInfo([i.length],s,i)}},TM=jE(lr,(e=>1/e)),RM={kernelName:lr,backendName:"cpu",kernelFunc:TM};var _M={kernelName:pr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r;xE(a,"resizeBilinear");const l=wa.computeStrides(a.shape),[u,c]=i,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,A=new Float32Array(wa.sizeFromShape([d,u,c,f])),g=[s&&u>1?h-1:h,s&&c>1?p-1:p],y=[s&&u>1?u-1:u,s&&c>1?c-1:c];let x=0;const b=g[0]/y[0],v=g[1]/y[1];for(let e=0;e<d;e++)for(let t=0;t<u;t++){let n;n=o?b*(t+.5)-.5:b*t;const r=Math.max(0,Math.floor(n)),a=n-r,s=Math.min(h-1,Math.ceil(n)),i=e*l[0]+r*l[1],u=e*l[0]+s*l[1];for(let e=0;e<c;e++){let t;t=o?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(p-1,Math.ceil(t)),c=i+n*l[2],d=u+n*l[2],h=i+s*l[2],g=u+s*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[d+e],s=t+(m[h+e]-t)*r,o=s+(n+(m[g+e]-n)*r-s)*a;A[x++]=o}}}return n.makeTensorInfo([d,u,c,f],"float32",A)}};var MM={kernelName:fr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:o}=r;xE([s,a],"resizeBilinearGrad");const i=wa.computeStrides(a.shape),[l,u,c,d]=a.shape,[,h,p]=s.shape,f=new Float32Array(l*u*c*d),m=[o&&h>1?u-1:u,o&&p>1?c-1:c],A=[o&&h>1?h-1:h,o&&p>1?p-1:p],g=m[0]/A[0],y=m[1]/A[1],x=n.data.get(s.dataId).values;let b=0;for(let e=0;e<l;e++){const t=e*i[0];for(let e=0;e<h;e++){const n=e*g,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=t+r*i[1],o=t+a*i[1],l=n-r,h=1-l;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),a=t-n,u=1-a,p=s+n*i[2],m=s+r*i[2],A=o+n*i[2],g=o+r*i[2],v=h*u,w=h*a,k=l*u,S=l*a;for(let e=0;e<d;e++){const t=x[b++];f[p+e]+=t*v,f[m+e]+=t*w,f[A+e]+=t*k,f[g+e]+=t*S}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}};var $M={kernelName:dr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r;xE(a,"resizeNearestNeighbor");const l=wa.computeStrides(a.shape),[u,c]=i,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,A=new Float32Array(d*u*c*f),g=[s&&u>1?h-1:h,s&&c>1?p-1:p],y=[s&&u>1?u-1:u,s&&c>1?c-1:c],x=g[0]/y[0],b=g[1]/y[1];let v=0;for(let e=0;e<d;e++){const t=e*l[0];for(let e=0;e<u;e++){const n=o?x*(e+.5):x*e;let r=Math.min(h-1,s?Math.round(n):Math.floor(n));o&&(r=Math.max(0,r));const a=t+r*l[1];for(let e=0;e<c;e++){const t=o?b*(e+.5):b*e;let n=Math.min(p-1,s?Math.round(t):Math.floor(t));o&&(n=Math.max(0,n));const r=a+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];A[v++]=t}}}}return n.makeTensorInfo([d,u,c,f],a.dtype,A)}};var FM={kernelName:hr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:o}=r;xE([s,a],"resizeNearestNeighborGrad");const i=wa.computeStrides(a.shape),l=wa.computeStrides(s.shape),[u,c,d,h]=a.shape,[,p,f]=s.shape,m=new Float32Array(u*c*d*h),A=n.data.get(s.dataId).values,g=[o&&p>1?c-1:c,o&&f>1?d-1:d],y=[o&&p>1?p-1:p,o&&f>1?f-1:f],x=g[0]/y[0],b=g[1]/y[1],v=1/x,w=1/b,k=2*Math.ceil(v)+2,S=2*Math.ceil(w)+2;for(let e=0;e<u;e++){const t=e*i[0];for(let e=0;e<c;e++){const n=t+e*i[1],r=Math.floor(e*v),a=Math.floor(r-k/2);for(let r=0;r<d;r++){const s=n+r*i[2],u=Math.floor(r*w),g=Math.floor(u-S/2);for(let n=0;n<h;n++){let i=0;for(let s=0;s<k;s++){const u=s+a;if(u<0||u>=p)continue;const h=t+u*l[1],m=u*x;if(e===Math.min(c-1,o?Math.round(m):Math.floor(m)))for(let e=0;e<S;e++){const t=e+g;if(t<0||t>=f)continue;const a=h+t*l[2],s=t*b;r===Math.min(d-1,o?Math.round(s):Math.floor(s))&&(i+=A[a+n])}}m[s+n]=i}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};var OM={kernelName:Ar,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;xE(a,"reverse");const o=a.shape.length,i=wa.parseAxisParam(s,a.shape);if(0===o)return TE({inputs:{x:a},backend:n});const l=new Za(a.shape,a.dtype),u=n.bufferSync(a);for(let e=0;e<l.size;e++){const t=l.indexToLoc(e),n=t.slice();i.forEach((e=>n[e]=a.shape[e]-1-n[e])),l.set(u.get(...n),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},DM={kernelName:sa,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:a,fillValue:s,center:o}=t,i=n,l=wa.getTypedArrayFromDType(r.dtype,wa.sizeFromShape(r.shape)),[u,c,d,h]=r.shape,[p,f]=ff.getImageCenter(o,c,d),m=Math.sin(a),A=Math.cos(a),g=i.data.get(r.dataId).values;for(let e=0;e<u;e++){const t=e*d*c*h;for(let e=0;e<c;e++){const n=e*(d*h);for(let r=0;r<d;r++){const a=r*h;for(let o=0;o<h;o++){const i=[u,e,r,o],y=i[2],x=i[1];let b=(y-p)*A-(x-f)*m,v=(y-p)*m+(x-f)*A;b=Math.round(b+p),v=Math.round(v+f);let w=s;if("number"!=typeof s&&(w=3===o?255:s[o]),b>=0&&b<d&&v>=0&&v<c){w=g[t+v*(d*h)+b*h+o]}l[t+n+a+o]=w}}}}return{dataId:i.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},zM=jE(gr,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),PM={kernelName:gr,backendName:"cpu",kernelFunc:zM};var LM={kernelName:xr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:o}=r,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ff.calculateShapes(s,a,o),h=YN(n.bufferSync(a),n.bufferSync(s),o,d,u,l,i,c,0,!0);return n.makeTensorInfo(o,h.dtype,h.values)}};function BM(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function WM(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}var UM={kernelName:br,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:o}=r,i=function(e,t,n,r,a,s){const o=wa.getArrayFromDType("int32",n*a);for(let i=0;i<n;++i){const n=e.slice(i*r,(i+1)*r),l=i*a;for(let e=0;e<a;++e)o[l+e]="left"===s?BM(n,t[e+l]):WM(n,t[e+l])}return o}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],o);return n.makeTensorInfo(s.shape,"int32",i)}};var VM={kernelName:vr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;xE([r,a,s],"select");const o=r.shape.length,i=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=fs(a.dtype,s.dtype),d=wa.makeZerosTypedArray(wa.sizeFromShape(a.shape),c);let h=0;const p=0===o||o>1||1===a.shape.length?1:wa.sizeFromShape(a.shape.slice(1));for(let e=0;e<i.length;e++)for(let t=0;t<p;t++)1===i[e]?d[h++]=l[e]:d[h++]=u[e];return n.makeTensorInfo(a.shape,c,d)}},jM=ff.SELU_SCALEALPHA,GM=ff.SELU_SCALE,HM=jE(wr,(e=>e>=0?GM*e:jM*(Math.exp(e)-1))),qM={kernelName:wr,backendName:"cpu",kernelFunc:HM},XM=jE(Cr,(e=>e<0?-1:e>0?1:0)),KM={kernelName:Cr,backendName:"cpu",kernelFunc:XM},ZM=jE(Sr,(e=>Math.sin(e))),YM={kernelName:Sr,backendName:"cpu",kernelFunc:ZM},JM=jE(Ir,(e=>Math.sinh(e))),QM={kernelName:Ir,backendName:"cpu",kernelFunc:JM},e$=Math.log(1.1920928955078125e-7)+2,t$=jE(Nr,(e=>{const t=e>-e$,n=e<e$,r=Math.exp(e);let a;return a=n?r:t?e:Math.log(1+r),a})),n$={kernelName:Nr,backendName:"cpu",kernelFunc:t$};var r$={kernelName:_r,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:o}=r;xE([a],"spaceToBatchND");const i=wa.sizeFromShape(s),l=[[0,0]];l.push(...o);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);const u=SM.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=ff.getReshaped(u.shape,s,i,!1),d=ff.getPermuted(c.length,s.length,!1),h=ff.getReshapedPermuted(u.shape,s,i,!1),p=LT({inputs:{x:u},backend:n,attrs:{shape:c}}),f=VN({inputs:{x:p},backend:n,attrs:{perm:d}}),m=LT({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};var a$={kernelName:Fr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const i=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values[0],[d,h,p,f,m]=aT(i,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var s$={kernelName:Or,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.data.get(a.dataId).values),i=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,d]=sT(i,r.shape,r.dtype,o,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var o$={kernelName:Dr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=oT(o,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};var i$={kernelName:zr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=oT(o,r.shape,r.dtype,i,l);return n.makeTensorInfo(c,r.dtype,u)}};var l$={kernelName:Pr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ff.calculateShapes(s,a,i),p=!1,f=n.bufferSync(a);let m;switch(s.dtype){case"bool":m=YN(f,n.bufferSync(s),i,h,c,u,l,d,Boolean(n.data.get(o.dataId).values[0]),p);break;case"float32":m=YN(f,n.bufferSync(s),i,h,c,u,l,d,n.data.get(o.dataId).values[0],p);break;case"int32":m=YN(f,n.bufferSync(s),i,h,c,u,l,d,n.data.get(o.dataId).values[0],p);break;case"string":m=YN(f,n.bufferSync(s),i,h,c,u,l,d,wa.decodeString(n.data.get(o.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(i,m.dtype,m.values)}};var u$={kernelName:Mr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:o}=r,i=wa.parseAxisParam(o,a.shape)[0],l=ff.prepareSplitSize(a,s,i),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{const t=[...c];t[i]=e;const r=nT({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[i]+=e,r}))}},c$={kernelName:Br,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;xE(n,"square");const a=r.data.get(n.dataId).values,s=new Float32Array(a.length);for(let e=0;e<a.length;++e){const t=a[e];s[e]=t*t}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},d$=jE(ra,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),h$={kernelName:ra,backendName:"cpu",kernelFunc:d$};var p$={kernelName:Wr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:o,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;xE(a,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:A,isSimpleSlice:g,begin:y,end:x,strides:b}=Qi.sliceInfo(a.shape,s,o,i,l,u,c,d,h);let v;if(m)v=LT({inputs:{x:a},backend:n,attrs:{shape:f}});else if(A||g){wa.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=Qi.computeOutShape(y,x,b),t=nT({inputs:{x:a},backend:n,attrs:{begin:y,size:e}});v=LT({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=pT(p,n.bufferSync(a),b,y);v=n.makeTensorInfo(f,e.dtype,e.values)}return v}};var f$={kernelName:Ur,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=fT(h,p,a,s,o,i,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var m$={kernelName:Vr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values[0],[u,c,d]=AT(i,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var A$={kernelName:jr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=gT(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",o)}},g$=jE(Hr,(e=>Math.tan(e))),y$={kernelName:Hr,backendName:"cpu",kernelFunc:g$},x$=jE(qr,(e=>Math.tanh(e)));function b$(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return wa.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return wa.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return wa.clamp(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function v$(e,t,n,r,a,s,o,i,l,u,c){return 0<=i&&i<t&&0<=l&&l<n?e[o*r+i*a+l*s+u]:c}function w$(e,t,n,r,a,s,o,i,l,u,c){return v$(e,t,n,r,a,s,o,Math.round(i),Math.round(l),u,c)}function k$(e,t,n,r,a,s,o,i,l,u,c){const d=Math.floor(i),h=Math.floor(l),p=d+1,f=h+1;return(p-i)*((f-l)*v$(e,t,n,r,a,s,o,d,h,u,c)+(l-h)*v$(e,t,n,r,a,s,o,d,f,u,c))+(i-d)*((f-l)*v$(e,t,n,r,a,s,o,p,h,u,c)+(l-h)*v$(e,t,n,r,a,s,o,p,f,u,c))}var S$=[VT,SE,GT,qT,BE,XT,KT,ZT,YT,JT,eR,nR,aR,iR,uR,pR,fR,mR,AR,UT,gR,yR,xR,bR,FE,XE,wR,EE,kR,ER,TR,RR,_R,MR,$R,FR,DR,PR,LR,BR,WR,UR,VR,GR,HR,qR,XR,KR,ZR,YR,e_,NT,t_,JE,u_,tN,d_,aN,y_,b_,v_,iN,S_,I_,C_,E_,N_,hN,mN,RE,T_,IR,__,$_,O_,RT,yN,vN,D_,IN,P_,W_,V_,H_,q_,X_,Z_,TN,Y_,J_,Q_,eM,tM,nM,rM,MN,aM,iM,dM,DN,PN,pM,mM,gM,WN,yM,vM,kM,SM,EM,$T,HN,NM,ME,f_,RM,OT,zT,BT,_M,MM,$M,FM,OM,DM,PM,ZN,LM,UM,VM,qM,eT,KM,YM,QM,rT,cM,n$,r$,a$,s$,o$,i$,l$,u$,uT,c$,hT,h$,p$,f$,m$,A$,vT,QR,y$,{kernelName:qr,backendName:"cpu",kernelFunc:x$},{kernelName:Xr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;xE(a,"tile");const o=wT(n.bufferSync(a),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:Kr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:o}=r;xE(a,"topk");const i=n.data.get(a.dataId).values,[l,u]=IT(i,a.shape,a.dtype,s,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}},{kernelName:Zr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:l,outputShape:u}=n,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],A=[c,f,m,p],g=wa.computeStrides(a.shape),y=g[0],x=g[1],b=g[2],v=wa.getTypedArrayFromDType(a.dtype,wa.sizeFromShape(A));v.fill(l);const w=r.data.get(a.dataId).values,k=r.data.get(s.dataId).values;for(let e=0;e<c;++e){const t=1===s.shape[0]?k:k.subarray(8*e,8*e+8);for(let n=0;n<f;++n)for(let r=0;r<m;++r)for(let a=0;a<p;++a){let s;const u=t[6]*r+t[7]*n+1;if(0===u)continue;const c=(t[0]*r+t[1]*n+t[2])/u,p=(t[3]*r+t[4]*n+t[5])/u,f=b$(c,h,i),m=b$(p,d,i);switch(o){case"nearest":s=w$(w,d,h,y,x,b,e,m,f,a,l);break;case"bilinear":s=k$(w,d,h,y,x,b,e,m,f,a,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}v[e*y+n*x+r*b+a]=s}return r.makeTensorInfo(A,a.dtype,v)}return{dataId:r.write(v,A,a.dtype),shape:a.shape,dtype:a.dtype}}},jN,{kernelName:Jr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;xE(s,"unique");const o=r.data.get(s.dataId).values,{outputValues:i,outputShape:l,indices:u}=CT(o,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,i),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:Qr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a.shape.length,i=a.shape[s],l=new Array(o-1);let u=0;for(let e=0;e<o;e++)e!==s&&(l[u++]=a.shape[e]);const c=new Array(o).fill(0),d=a.shape.slice();d[s]=1;const h=new Array(i);for(let e=0;e<h.length;e++){c[s]=e;const t=nT({inputs:{x:a},backend:n,attrs:{begin:c,size:d}});h[e]=LT({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return h}},{kernelName:ea,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:o}=r;xE(a,"unsortedSegmentSum");const i=[],l=[],u=a.shape.length-s.shape.length;let c=s;for(let e=0;e<u;++e){const t=c_({inputs:{input:c},backend:n,attrs:{dim:e+1}});c=t,l.push(t)}for(let e=0;e<o;++e){const t=wa.createScalarValue(e,"int32"),r=n.makeTensorInfo([],"int32",t),s=YE({inputs:{a:r,b:c},backend:n}),o=$E({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=ON({inputs:{a:o,b:a},backend:n}),d=JR({inputs:{x:u},backend:n,attrs:{axis:0,keepDims:!1}});i.push(d),l.push(r),l.push(s),l.push(o),l.push(u),l.push(d)}const d=wM({inputs:i,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},bM];for(const e of S$)Aa(e);var I$={};S(I$,{assertNotComplex:()=>OF,bindCanvasToFramebuffer:()=>dF,bindColorTextureToFramebuffer:()=>hF,bindTextureToProgramUniformSampler:()=>cF,bindTextureUnit:()=>oF,bindVertexBufferToProgramAttribute:()=>sF,callAndCheck:()=>B$,canBeRepresented:()=>W$,createFragmentShader:()=>G$,createFramebuffer:()=>aF,createProgram:()=>Z$,createStaticIndexBuffer:()=>eF,createStaticVertexBuffer:()=>Q$,createTexture:()=>nF,createVertexShader:()=>j$,getBatchDim:()=>yF,getExtensionOrThrow:()=>V$,getFramebufferErrorMessage:()=>mF,getMaxTexturesInShader:()=>EF,getNumChannels:()=>tF,getProgramUniformLocation:()=>uF,getProgramUniformLocationOrThrow:()=>lF,getRowsCols:()=>xF,getShapeAs3D:()=>bF,getTextureShapeFromLogicalShape:()=>vF,getWebGLDisjointQueryTimerVersion:()=>NF,getWebGLErrorMessage:()=>U$,getWebGLMaxTextureSize:()=>SF,hasExtension:()=>TF,isCapableOfRenderingToFloatTexture:()=>_F,isDownloadFloatTextureEnabled:()=>MF,isReshapeFree:()=>kF,isWebGLFenceEnabled:()=>FF,isWebGLVersionEnabled:()=>RF,linkProgram:()=>Y$,logShaderSourceAndInfoLog:()=>K$,resetMaxTextureSize:()=>IF,resetMaxTexturesInShader:()=>CF,unbindColorTextureFromFramebuffer:()=>pF,unbindTextureUnit:()=>iF,validateFramebuffer:()=>fF,validateProgram:()=>J$,validateTextureSize:()=>rF});var C$,E$,N$,T$,R$,_$,M$={},$$={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function F$(e,t){M$[e]=t}function O$(e,t){if(!(e in M$)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;if(n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete M$[e]}),!1),1===e)return n.getContext("webgl",$$)||n.getContext("experimental-webgl",$$);return n.getContext("webgl2",$$)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;M$[e]=n}const n=M$[e];return null==n||n.isContextLost()?(delete M$[e],O$(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),M$[e])}function D$(e,t){return[t,e]}function z$(e){const t=wa.sizeFromShape(e),n=Math.ceil(t/4);return wa.sizeToSquarishShape(n)}function P$(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function L$(e,t){const n=e;let r,a,s,o,i,l,u,c,d,h;return 2===qe().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,o=n.RGBA32F,i=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,o=n.RGBA,i=e.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function B$(e,t){const n=t();return qe().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+U$(e,t))}(e),n}(E$=C$||(C$={}))[E$.DENSE=0]="DENSE",E$[E$.SHARED_BATCH=1]="SHARED_BATCH",(T$=N$||(N$={}))[T$.RENDER=0]="RENDER",T$[T$.UPLOAD=1]="UPLOAD",T$[T$.PIXELS=2]="PIXELS",T$[T$.DOWNLOAD=3]="DOWNLOAD",(_$=R$||(R$={}))[_$.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",_$[_$.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",_$[_$.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",_$[_$.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",_$[_$.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16";function W$(e){return!!(qe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function U$(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function V$(e,t){return AF(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function j$(e,t){const n=AF(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(B$(e,(()=>e.shaderSource(n,t))),B$(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function G$(e,t){const n=AF(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(B$(e,(()=>e.shaderSource(n,t))),B$(e,(()=>e.compileShader(n))),qe().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw K$(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var H$,q$,X$=/ERROR: [0-9]+:([0-9]+):/g;function K$(e,t){const n=X$.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,o=a.map(((e,t)=>wa.rightPad((t+1).toString(),s)+e));let i=0;for(let e=0;e<o.length;e++)i=Math.max(o[e].length,i);const l=o.slice(0,r-1),u=o.slice(r-1,r),c=o.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${wa.rightPad(u[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function Z$(e){return AF(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function Y$(e,t){if(B$(e,(()=>e.linkProgram(t))),!qe().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function J$(e,t){if(B$(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Q$(e,t){const n=AF(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return B$(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),B$(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function eF(e,t){const n=AF(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return B$(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),B$(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function tF(){return 2===qe().getNumber("WEBGL_VERSION")?1:4}function nF(e){return AF(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function rF(e,t){const n=qe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function aF(e){return AF(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function sF(e,t,n,r,a,s,o){const i=e.getAttribLocation(t,n);return-1!==i&&(B$(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),B$(e,(()=>e.vertexAttribPointer(i,a,e.FLOAT,!1,s,o))),B$(e,(()=>e.enableVertexAttribArray(i))),!0)}function oF(e,t,n){gF(e,n),B$(e,(()=>e.activeTexture(e.TEXTURE0+n))),B$(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function iF(e,t){gF(e,t),B$(e,(()=>e.activeTexture(e.TEXTURE0+t))),B$(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function lF(e,t,n){return AF(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function uF(e,t,n){return e.getUniformLocation(t,n)}function cF(e,t,n,r){B$(e,(()=>oF(e,t,r))),B$(e,(()=>e.uniform1i(n,r)))}function dF(e){B$(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),B$(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),B$(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function hF(e,t,n){B$(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),B$(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function pF(e,t){B$(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),B$(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function fF(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+mF(e,t))}function mF(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function AF(e,t,n){const r=B$(e,(()=>t()));if(null==r)throw new Error(n);return r}function gF(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function yF(e,t=2){return wa.sizeFromShape(e.slice(0,e.length-t))}function xF(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function bF(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[yF(e),...xF(e)]),t}function vF(e,t=!1){let n=qe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map(((t,n)=>n>=e.length-2?wa.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=wa.squeezeShape(e);e=t.newShape}let r=wa.sizeFromShape(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=yF(e);let n=2,a=2;return e.length&&([n,a]=xF(e)),r=t*(n/2)*(a/2),wa.sizeToSquarishShape(r).map((e=>2*e))}return wa.sizeToSquarishShape(r)}function wF(e){return e%2==0}function kF(e,t){if(e=e.slice(-2),t=t.slice(-2),wa.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(wF(n)&&wF(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&wF(e[0])&&wF(t[0])}function SF(e){if(null==H$){const t=O$(e);H$=t.getParameter(t.MAX_TEXTURE_SIZE)}return H$}function IF(){H$=null}function CF(){q$=null}function EF(e){if(null==q$){const t=O$(e);q$=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,q$)}function NF(e){if(0===e)return 0;let t;const n=O$(e);return t=TF(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:TF(n,"EXT_disjoint_timer_query")?1:0,t}function TF(e,t){return null!=e.getExtension(t)}function RF(e){try{if(null!=O$(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function _F(e){if(0===e)return!1;const t=O$(e);if(1===e){if(!TF(t,"OES_texture_float"))return!1}else if(!TF(t,"EXT_color_buffer_float"))return!1;return $F(t)}function MF(e){if(0===e)return!1;const t=O$(e);if(1!==e){if(TF(t,"EXT_color_buffer_float"))return $F(t);const e="EXT_color_buffer_half_float";if(TF(t,e)){const n=t.getExtension(e);return function(e,t){const n=L$(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const a=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),i}(t,n)}return!1}if(!TF(t,"OES_texture_float"))return!1;if(!TF(t,"WEBGL_color_buffer_float"))return!1;return $F(t)}function $F(e){const t=L$(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function FF(e){if(2!==e)return!1;return null!=O$(e).fenceSync}function OF(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&wa.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var DF=qe();function zF(){let e,t,n,r,a,s,o,i,l,u;return 2===qe().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",o="out vec4 outputColor;",i="\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:l,defineRound:u}}function PF(e,t,n="index"){const r=wa.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${t}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function LF(e,t,n="index"){const r=wa.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / outShapeStrides[${a}]`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function BF(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let e=n-3;e>=0;--e)a[e]=`(${a[e+1]} * ${r[e+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${r[a]}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function WF(e){const t=wa.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}DF.registerFlag("HAS_WEBGL",(()=>DF.getNumber("WEBGL_VERSION")>0)),DF.registerFlag("WEBGL_VERSION",(()=>RF(2)?2:RF(1)?1:0)),DF.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),DF.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===DF.get("WEBGL_VERSION"))),DF.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),DF.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),DF.registerFlag("WEBGL_PACK",(()=>DF.getBool("HAS_WEBGL"))),DF.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>DF.getBool("WEBGL_PACK"))),DF.registerFlag("WEBGL_PACK_CLIP",(()=>DF.getBool("WEBGL_PACK"))),DF.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>DF.getBool("WEBGL_PACK"))),DF.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>DF.getBool("WEBGL_PACK"))),DF.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>DF.getBool("WEBGL_PACK"))),DF.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>DF.getBool("WEBGL_PACK"))),DF.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>DF.getBool("WEBGL_PACK"))),DF.registerFlag("WEBGL_PACK_REDUCE",(()=>DF.getBool("WEBGL_PACK"))),DF.registerFlag("WEBGL_LAZILY_UNPACK",(()=>DF.getBool("WEBGL_PACK"))),DF.registerFlag("WEBGL_CONV_IM2COL",(()=>DF.getBool("WEBGL_PACK"))),DF.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>SF(DF.getNumber("WEBGL_VERSION")))),DF.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>EF(DF.getNumber("WEBGL_VERSION")))),DF.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=DF.getNumber("WEBGL_VERSION");return 0===e?0:NF(e)})),DF.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>DF.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ns.isMobile())),DF.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>_F(DF.getNumber("WEBGL_VERSION")))),DF.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!DF.getBool("WEBGL_FORCE_F16_TEXTURES")&&DF.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),DF.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>MF(DF.getNumber("WEBGL_VERSION")))),DF.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>FF(DF.getNumber("WEBGL_VERSION")))),DF.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>DF.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),DF.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),DF.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Ns.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),DF.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),DF.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),DF.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),DF.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));var UF="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:VF}=ff;function jF(e,t,n){const r=[];if(e.forEach((e=>{const t=wa.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=tO(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const a=r.join("\n"),s=e.map((e=>function(e,t,n=!1,r){let a="";a+=n?HF(e,r):GF(e,r);const s=e.shapeInfo.logicalShape,o=t.logicalShape;s.length<=o.length&&(a+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=VF(e.shapeInfo.logicalShape,t.logicalShape),l=eO(o),u=o-s;let c;const d=["x","y","z","w","u","v"];c=0===s?"":o<2&&i.length>=1?"coords = 0;":i.map((e=>`coords.${d[e+u]} = 0;`)).join("\n");let h="";h=o<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+u]}`)).join(", ");let p="return outputValue;";const f=1===wa.sizeFromShape(e.shapeInfo.logicalShape),m=1===wa.sizeFromShape(t.logicalShape);if(1!==s||f||m){if(f&&!m)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=s-2,t=s-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?p="return vec4(outputValue.x);":i.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${a}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,o=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===l&&null==e.shapeInfo.flatOffset&&wa.arraysEqual(o,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=eO(l),c=VF(e.shapeInfo.logicalShape,t.logicalShape),d=l-i;let h;const p=["x","y","z","w","u","v"];h=0===i?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+d]} = 0;`)).join("\n");let f="";f=l<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+d]}`)).join(", ");return`\n    float ${a}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(e,t));return a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=t.texShape,i=zF(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(i);let u,c,d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${qF}\n    ${XF}\n    ${KF}\n  `}(i);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return YF();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(wa.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const a=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2);let o=s,i="",l="b, r, c";for(let t=2;t<e.length-1;t++)o*=e[e.length-t-1],i=`\n      int b${t} = index / ${o};\n      index -= b${t} * ${o};\n    `+i,l=`b${t}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,o,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(i)):(u=function(e,t,n){switch(e.length){case 0:return YF();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(wa.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${LF(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=PF(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${LF(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=PF(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=PF(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=PF(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(i)),n.packedInputs&&(d+=ZF);return[d,l,c,a,u,s,n.userCode].join("\n")}function GF(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=JF(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[i,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${i}, ${l}, ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${QF(e)}\n      }\n    `;const a=e.shapeInfo.texShape,s=a[0],o=a[1];if(1===o&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=JF(n);if(1===o)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===s)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&wa.arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:o,keptDims:i}=wa.squeezeShape(n),l=o;if(l.length<n.length){const n=["row","col"];return`\n      ${GF(nO(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${rO(n,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${QF(e)}\n      }\n    `;const u=s[0],c=s[1],d=JF(r);if(1===c)return t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===u)return t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:l}=wa.squeezeShape(n),u=i;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${GF(nO(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${rO(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${QF(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===o&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=JF(r);if(t)return`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${s} + col * ${o} + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:l,keptDims:u}=wa.squeezeShape(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${GF(nO(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${rO(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${o}, ${s}, 1)));\n        ${QF(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,A=`int stride0 = ${r}Shape[1] * stride1;`;if(p===i&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const g=JF(r);if(t)return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${A}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${g});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${g});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,o=t[2]*s,i=t[1]*o,{newShape:l,keptDims:u}=wa.squeezeShape(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${GF(nO(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${rO(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${i}, ${o}, ${s}, ${a})) +\n          depth3;\n        ${QF(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===i&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=JF(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=wa.squeezeShape(t);if(a.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${GF(nO(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${rO(t,s)});\n      }\n    `}const o=t[5],i=t[4]*o,l=t[3]*i,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${QF(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${i}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===o&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=JF(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${i} + depth3 * ${o} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function HF(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=zF();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=zF();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,o=s[0],i=s[1],l=zF();if(null!=s&&wa.arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=["b","row","col"];return`\n        ${HF(nO(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${rO(s,r)});\n        }\n      `}const i=zF();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${i.texture2D}(${r}, uv);\n    }\n  `;const l=o[0],u=o[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${c}, b, row, col);\n      return ${i.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=zF();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;const s=e.shapeInfo.logicalShape,o=s.length,i=e.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=l[0],c=l[1],d=Math.ceil(s[o-1]/2);let h=d*Math.ceil(s[o-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<o-1;e++)p=`int b${e}, `+p,h*=s[o-e-1],f=`b${e} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}var qF="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",XF="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",KF="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ZF="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function YF(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function JF(e){return`offset${e}`}function QF(e){const t=e.name,n=wa.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function eO(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function tO(e,t,n){const{newShape:r,keptDims:a}=wa.squeezeShape(t),s=t.length,o=e&&3===s&&1===t[0],i=o?t.slice(1):r,l=!e&&s>1&&!wa.arraysEqual(t,n)&&r.length<s||o;return{useSqueezeShape:l,uniformShape:l?i:t,keptDims:a}}function nO(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function rO(e,t){return t.map((t=>e[t])).join(", ")}function aO(e,t,n){const r={},a={},s={},o=[];let i,l,u,c=null,d=null;d=e.getUniformLocation(n,"NAN",!1),1===qe().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const h=!1;for(let o=0;o<t.variableNames.length;o++){const i=t.variableNames[o];r[i]=e.getUniformLocation(n,i,h),r[`offset${i}`]=e.getUniformLocation(n,`offset${i}`,h),t.enableShapeUniforms&&(a[`${i}Shape`]=e.getUniformLocation(n,`${i}Shape`,h),s[`${i}TexShape`]=e.getUniformLocation(n,`${i}TexShape`,h))}return t.enableShapeUniforms&&(i=e.getUniformLocation(n,"outShape",h),u=e.getUniformLocation(n,"outShapeStrides",h),l=e.getUniformLocation(n,"outTexShape",h)),t.customUniforms&&t.customUniforms.forEach(((t,r)=>{o[r]=e.getUniformLocation(n,t.name,h)})),{uniformLocations:r,customUniformLocations:o,infLoc:c,nanLoc:d,inShapesLocations:a,inTexShapesLocations:s,outShapeLocation:i,outShapeStridesLocation:u,outTexShapeLocation:l}}function sO(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,a=t[n],s=a.shape;if(!wa.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;const o=e.texShape,i=a.isUniform?null:a.texData.texShape;if(!wa.arraysEqual(o,i))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${i} must match`)}))}function oO(e){return qe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var iO={};function lO(e){const t=zF();return j$(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function uO(e){return Q$(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function cO(e){return eF(e,new Uint16Array([0,1,2,2,1,3]))}function dO(e,t,n,r,a,s){rF(t,n);const o=nF(e),i=e.TEXTURE_2D;return B$(e,(()=>e.bindTexture(i,o))),B$(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),B$(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),B$(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),B$(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===qe().getNumber("WEBGL_VERSION")?B$(e,(()=>e.texImage2D(i,0,r,t,n,0,a,s,null))):B$(e,(()=>e.texStorage2D(i,1,r,t,n))),B$(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:o,texShape:[n,t]}}function hO(e){return e.internalFormatFloat}function pO(e,t,n,r){const[a,s]=D$(t,n);return dO(e,a,s,hO(r),r.textureFormatFloat,e.FLOAT)}function fO(e){return e.internalFormatHalfFloat}function mO(e,t,n,r){const[a,s]=D$(t,n);return dO(e,a,s,fO(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function AO(e){return e.downloadTextureFormat}function gO(e,t,n,r){const[a,s]=D$(t,n);return dO(e,a,s,AO(r),e.RGBA,e.UNSIGNED_BYTE)}function yO(e){return e.internalFormatPackedFloat}function xO(e,t,n,r){const[a,s]=P$(t,n);return dO(e,a,s,yO(r),e.RGBA,e.FLOAT)}function bO(e){return e.internalFormatPackedHalfFloat}function vO(e,t,n,r){const[a,s]=P$(t,n);return dO(e,a,s,bO(r),e.RGBA,r.textureTypeHalfFloat)}function wO(e,t,n){B$(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));return sF(e,t,"clipSpacePos",n,3,20,0)&&sF(e,t,"uv",n,2,20,12)}function kO(e,t,n,r,a,s){let o,i,l;B$(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(o=new Uint8Array(n*r*4),i=e.UNSIGNED_BYTE,l=e.RGBA):(o=new Float32Array(n*r*4),i=e.FLOAT,l=s.internalFormatPackedFloat),o.set(a),2===qe().getNumber("WEBGL_VERSION")?B$(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,i,o))):B$(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,i,o))),B$(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function SO(e,t,n){B$(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===qe().getNumber("WEBGL_VERSION")?B$(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):B$(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===qe().getNumber("WEBGL_VERSION")?B$(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):B$(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),B$(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function IO(e,t,n,r){const a=e.createBuffer();B$(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));const s=16*t*n;return B$(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),B$(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),B$(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function CO(e,t,n){const r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function EO(e,t,n,r){const[a,s]=D$(t,n),o=new Uint8Array(t*n*4);return B$(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}function NO(e,t,n,r,a,s,o,i){const l=e,u=new Float32Array(function(e,t){const[n,r]=P$(e,t);return n*r*4}(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function TO(e,t,n){const r=new Float32Array(t*n*4);return B$(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}S(iO,{bindVertexProgramAttributeStreams:()=>wO,createBufferFromOutputTexture:()=>IO,createFloat16MatrixTexture:()=>mO,createFloat16PackedMatrixTexture:()=>vO,createFloat32MatrixTexture:()=>pO,createIndexBuffer:()=>cO,createPackedMatrixTexture:()=>xO,createUnsignedBytesMatrixTexture:()=>gO,createVertexBuffer:()=>uO,createVertexShader:()=>lO,downloadByteEncodedFloatMatrixFromOutputTexture:()=>EO,downloadFloat32MatrixFromBuffer:()=>CO,downloadMatrixFromPackedOutputTexture:()=>TO,downloadPackedMatrixFromBuffer:()=>NO,getInternalFormatForFloat16MatrixTexture:()=>fO,getInternalFormatForFloat16PackedMatrixTexture:()=>bO,getInternalFormatForFloat32MatrixTexture:()=>hO,getInternalFormatForPackedMatrixTexture:()=>yO,getInternalFormatForUnsignedBytesMatrixTexture:()=>AO,uploadDenseMatrixToTexture:()=>kO,uploadPixelDataToTexture:()=>SO});var RO=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=qe().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,F$(t,e)):this.gl=O$(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===qe().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=V$(this.gl,e),TF(this.gl,t))this.textureHalfFloatExtension=V$(this.gl,t);else if(qe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),TF(this.gl,r))this.colorBufferHalfFloatExtension=V$(this.gl,r);else if(qe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",TF(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!TF(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=uO(this.gl),this.indexBuffer=cO(this.gl),this.framebuffer=aF(this.gl),this.textureConfig=L$(this.gl,this.textureHalfFloatExtension)}get debug(){return qe().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;B$(e,(()=>e.finish())),B$(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),B$(e,(()=>e.deleteFramebuffer(this.framebuffer))),B$(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),B$(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),B$(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),pO(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),mO(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),gO(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),SO(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),kO(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),vO(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),xO(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(pF(this.gl,this.framebuffer),this.outputTexture=null),B$(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>EO(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return NO(this.gl,e,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return CO(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=IO(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(qe().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>TO(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=lO(t));const n=Z$(t);return B$(t,(()=>t.attachShader(n,this.vertexShader))),B$(t,(()=>t.attachShader(n,e))),Y$(t,n),this.debug&&J$(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=wO(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&B$(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&J$(this.gl,this.program),B$(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?lF(this.gl,e,t):uF(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),B$(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),cF(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=P$(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&J$(this.gl,this.program),fF(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),B$(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),B$(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=V$(this.gl,2===qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await wa.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||wa.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),hF(this.gl,e,this.framebuffer),this.debug&&fF(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(hF(this.gl,this.outputTexture,this.framebuffer),this.debug&&fF(this.gl)):pF(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;hF(r,e,this.framebuffer),this.debug&&fF(r),this.outputTexture=e,B$(r,(()=>r.viewport(0,0,t,n))),B$(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),B$(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};var{addImpl:_O,bincountImpl:MO,bincountReduceImpl:$O,ceilImpl:FO,concatImpl:OO,equalImpl:DO,expImpl:zO,expm1Impl:PO,floorImpl:LO,gatherNdImpl:BO,gatherV2Impl:WO,greaterImpl:UO,greaterEqualImpl:VO,lessImpl:jO,lessEqualImpl:GO,linSpaceImpl:HO,logImpl:qO,maxImpl:XO,maximumImpl:KO,minimumImpl:ZO,multiplyImpl:YO,negImpl:JO,notEqualImpl:QO,prodImpl:eD,rangeImpl:tD,rsqrtImpl:nD,scatterImpl:rD,sigmoidImpl:aD,simpleAbsImpl:sD,sliceImpl:oD,sparseFillEmptyRowsImpl:iD,sparseReshapeImpl:lD,sparseSegmentReductionImpl:uD,sqrtImpl:cD,stridedSliceImpl:dD,stringNGramsImpl:hD,stringSplitImpl:pD,stringToHashBucketFastImpl:fD,subImpl:mD,tileImpl:AD,topKImpl:gD,transposeImpl:yD,uniqueImpl:xD}=wE;function bD(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function vD(e,t){return 1===t?[e]:bD(e,t)}var wD=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=oO(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r,a;this.userCode=`\n      ${r=t,a=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${a?BF(["r","c","d"],"inputShape"):PF(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":WF(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};function kD(e,t,n,r,a){const s=function(e,t){switch(e){case R$.PACKED_2X2_FLOAT32:return yO(t);case R$.PACKED_2X2_FLOAT16:return bO(t);case R$.UNPACKED_FLOAT32:return hO(t);case R$.UNPACKED_FLOAT16:return fO(t);case R$.PACKED_4X1_UNSIGNED_BYTE:return AO(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let o;if(a){const[t,n]=P$(e[0],e[1]);o=t*n}else{const[t,n]=D$(e[0],e[1]);o=t*n}const i=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,s);return o*i}function SD(e,t){if(e===N$.UPLOAD)return R$.PACKED_2X2_FLOAT32;if(e===N$.RENDER||null==e)return function(e){return qe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?R$.PACKED_2X2_FLOAT32:R$.UNPACKED_FLOAT32:e?R$.PACKED_2X2_FLOAT16:R$.UNPACKED_FLOAT16}(t);if(e===N$.DOWNLOAD||e===N$.PIXELS)return R$.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function ID(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var CD=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=oO(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},ED="return abs(x);",ND="return x;",TD=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=oO(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},RD=fm.whereImpl,_D={};var MD=qe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");var $D=class extends X{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!qe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof RO)t=e;else{const n=O$(qe().getNumber("WEBGL_VERSION"),e);t=new RO(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=O$(qe().getNumber("WEBGL_VERSION"));t=new RO(e),this.binaryCache=((n=qe().getNumber("WEBGL_VERSION"))in _D||(_D[n]={}),_D[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=SD(t,n),a=ID(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const s=kD(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[a].shift();return this.usedTextures[a].push(e),e}let o;return r===R$.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===R$.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===R$.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===R$.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===R$.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const a=SD(n,r),s=ID(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const o=kD(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),i=qe().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[s],u=l.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}(this.gpgpu),this.numMBBeforeWarning=null==qe().global.screen?1024:qe().global.screen.height*qe().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new q(this,fi())}nextDataId(){return $D.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((qe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||qe().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:N$.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(qe().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:N$.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:o,isPacked:i}=t;if(null!=s){let t;t=i?new TD(o,ND):new CD(o,ND);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=wa.now()),"complex64"===r){const e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);c=ff.mergeRealAndImagArrays(e,t)}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=wa.now()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:o,isPacked:i}=t;if(null!=a){let t;t=i?new TD(r,ND):new CD(r,ND);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(qe().getBool("DEBUG")&&!qe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===qe().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&qe().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...z$(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),t=e[0],n=e[1];u=ff.mergeRealAndImagArrays(t,n)}else if(null==c)u=this.getValuesFromTexture(e);else{const e=wa.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;B$(e,(()=>e.deleteBuffer(c)))}const d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&fi().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:o,isPacked:i,texture:l}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=i?new TD(a,ND):new CD(a,ND);const r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:o}],o),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=fi().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>wa.decodeString(e)));return Do(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Do(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!W$(n)){if(qe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=wa.sizeFromShape(t);if(qe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...z$(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}const s=qe().getBool("WEBGL_PACK")&&!0===r,o=s?bF(t):t,i=s?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=N$.DOWNLOAD;const t=zF();this.outputShape=e,this.userCode=`\n      ${UF}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}(o):new class{constructor(e){this.variableNames=["A"],this.outTexUsage=N$.DOWNLOAD;const t=zF();this.outputShape=e,this.userCode=`\n      ${UF}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}(o),l=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=wa.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=wa.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);o.kernelMs=wa.sum(e),o.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:wa.now(),endMs:null}}endTimer(e){return qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=wa.now(),e)}async getQueryTime(e){if(qe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:o}=this.texData.get(e),i=o&&o.origDataId||e,l=this.dataRefCount.get(i);l>1?this.dataRefCount.set(i,l-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=MD){return qe().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&wa.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){ff.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return RD(e.shape,t)}packedUnaryOp(e,t,n){const r=new TD(e.shape,t),a=this.compileAndRun(r,[e],n);return fi().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=sD(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(qe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ED,e.dtype);const t=new CD(e.shape,ED),n=this.compileAndRun(t,[e]);return fi().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&wa.isString(n[0])){const a=n.map((e=>wa.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return fi().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=oO(this.outputShape.length);const t=e.length,n=vD("rc",t),r=eO(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),o=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=oO(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=vD("rc",this.rank),t=eO(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[yF(e.shape),...xF(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[yF(t),...xF(t)],s=new wD(a,n),o=[n],i=this.runWebGLProgram(s,[r],e.dtype,o,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){const e=wa.sizeFromShape(a),n=t[0]*t[1]*4;wa.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const o=bF(a);let i;i=r?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=C$.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=zF();this.outputShape=e,this.enableShapeUniforms=oO(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?LF(["r","c","d"],e):PF(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}(o):new class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=C$.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=zF();this.outputShape=e,this.enableShapeUniforms=oO(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?LF(["r","c","d"],e):PF(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}(o);const l=[null!=t?t:z$(o)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r,a=!1,s){const o=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(o.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===C$.DENSE){const t=null!=s?s:z$(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===wa.sizeFromShape(o.shape))return i.values=wa.getTypedArrayFromDType(o.dtype,0),o;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&wa.sizeFromShape(t.shape)<=qe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!kF(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);const c={shape:o.shape,texData:i,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach((t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:o,uniformShape:i,keptDims:l}=tO(e.packedInputs,t.shape,s);let u="",c="",d="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=wa.computeStrides(i);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${i[0]>1}_${i[1]>1}`;const h=t.shape.length,p=2===i.length&&wa.arraysEqual(t.shape,s),f=1===wa.sizeFromShape(t.shape),m=ff.getBroadcastDims(t.shape,n.shape),A=!e.packedInputs&&h===n.shape.length&&wa.arraysEqual(s,n.texData.texShape),g=e.packedInputs||i.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${h}_${A}_${o?l:""}_${i.length}_${f}_${m}_${p}_${u}_${c}_${d}_${g}_${a}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));const a=e.userCode;let s=e.constructor.name;return s+="_"+r+"_"+a+`${qe().getNumber("WEBGL_VERSION")}`,s}(e,u,c),h=this.getAndSaveBinary(d,(()=>function(e,t,n,r){const a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=jF(a,o,t),l=G$(e.gl,i),u=e.createProgram(l);return qe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:i,webGLProgram:u,inShapeInfos:s,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:i,webGLProgram:u,inShapeInfos:s,outShapeInfo:o},aO(e,t,u))}(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),qe().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(sO(t.inShapeInfos,n),sO([t.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):e.setOutputMatrixTexture(s.texture,o[0],o[1]),e.setProgram(t.webGLProgram),1===qe().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,r)=>{const a=t.program.variableNames[r],s=t.uniformLocations[a],o=t.uniformLocations[`offset${a}`],i=t.inShapesLocations[`${a}Shape`],l=t.inTexShapesLocations[`${a}TexShape`];if(i){const{uniformShape:r}=tO(t.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(i,new Int32Array(r));break;case 2:e.gl.uniform2iv(i,new Int32Array(r));break;case 3:e.gl.uniform3iv(i,new Int32Array(r));break;case 4:e.gl.uniform4iv(i,new Int32Array(r))}}if(l&&e.gl.uniform2i(l,n.texData.texShape[0],n.texData.texShape[1]),null!=s)if(n.isUniform)if(wa.sizeFromShape(n.shape)<2)e.gl.uniform1f(s,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=n.texData.slice&&null!=o&&e.gl.uniform1i(o,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture.texture,s,r)}));const i=t.outShapeLocation;if(i)switch(r.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=wa.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a&&t.program.customUniforms.forEach(((n,r)=>{const s=t.customUniformLocations[r],o=a[r];if("float"===n.type)e.gl.uniform1fv(s,o);else if("vec2"===n.type)e.gl.uniform2fv(s,o);else if("vec3"===n.type)e.gl.uniform3fv(s,o);else if("vec4"===n.type)e.gl.uniform4fv(s,o);else if("int"===n.type)e.gl.uniform1iv(s,o);else if("ivec2"===n.type)e.gl.uniform2iv(s,o);else if("ivec3"===n.type)e.gl.uniform3iv(s,o);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(s,o)}})),e.executeProgram()}(this.gpgpu,h,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=qe().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=wa.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!qe().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===a){const e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,r,a=!1){n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!qe().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=gi((()=>{if(!qe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=qe().getBool("DEBUG");qe().set("DEBUG",!1);const t=this.abs(fc(1e-8)).dataSync()[0];if(qe().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:o,isPacked:i}=t;if(null!=s)return;const l=null!=this.activeTimers;let u;l&&(u=wa.now());let c=t.texShape;if(null==c&&(c=vF(n,i),t.texShape=c),null!=a){const e=bF(n);let s,o=c[1],d=c[0];const h=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!i&&h||([o,d]=P$(c[0],c[1])),s=i?new class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=zF();this.outputShape=e,this.enableShapeUniforms=oO(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let a=0;a<=1;a++){const s=2*t+a;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":WF(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}}(e,h):new class{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=zF();this.outputShape=e,this.enableShapeUniforms=oO(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":WF(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}}(e,h);const p=h?[d,o]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?N$.PIXELS:N$.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,d,a);const A=[[d,o]],g=!0,y=this.runWebGLProgram(s,[f],r,A,g),x=this.texData.get(y.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,qe().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=wa.now()-u)}else{const e=this.acquireTexture(c,o,r,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*wa.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await pf(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw K$(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,inShapesLocations:s,inTexShapesLocations:o,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:u}=aO(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.inShapesLocations=s,e.inTexShapesLocations=o,e.outShapeLocation=i,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}};$D.nextDataId=0;var FD="3.19.0";function OD(){qe().set("WEBGL_FORCE_F16_TEXTURES",!0)}Ns.isBrowser()&&Ei("webgl",(()=>new $D),2);var DD={forceHalfFloat:OD},zD=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=ff.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=oO(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},PD=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ff.assertAndGetBroadcastShape(t,n);const a=this.outputShape.length;this.enableShapeUniforms=oO(a);let s="";if(r)if(0===a||1===wa.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(s=`\n          ${eO(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=vD("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function LD(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var BD={kernelName:pn,backendName:"webgl",kernelFunc:LD};function WD(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(s.dataId),i=LD({inputs:{x:r},backend:n}),l=LD({inputs:{x:a},backend:n});return o.complexTensorInfos={real:i,imag:l},s}var UD={kernelName:St,backendName:"webgl",kernelFunc:WD},VD="return (a < 0.) ? b * a : a;",jD="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var GD={kernelName:xn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,o=n.makeTensorInfo([],"float32",wa.createScalarValue(s,"float32")),i=qe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new PD(jD,a.shape,o.shape):new zD(VD,a.shape,o.shape),l=n.runWebGLProgram(i,[a,o],"float32");return n.disposeIntermediateTensorInfo(o),l}},HD="return (a < 0.) ? b * a : a;",qD="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var XD={kernelName:ar,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=qe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new PD(qD,r.shape,a.shape):new zD(HD,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}};function KD({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{const{x:o}=a,i=s,l=r||o.dtype;if(i.shouldExecuteOnCPU([o])&&null!=n){const e=i.texData.get(o.dataId),t=n(e.values,l);return i.makeTensorInfo(o.shape,l,t)}let u;return u=qe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new TD(o.shape,t):new CD(o.shape,e),i.runWebGLProgram(u,[o],l)}}function ZD({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:o,backend:i})=>{const{a:l,b:u}=o,c=i;if(r&&"complex64"===l.dtype){const t=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:r.dataId,dtype:r.dtype,shape:u.shape},o=new zD(e,l.shape,u.shape);return c.runWebGLProgram(o,[a,s],fs(n.dtype,r.dtype))})),s=WD({inputs:{real:r,imag:a},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(a),s}const d=s||fs(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=a){const e=c.texData.get(l.dataId).values,t=c.texData.get(u.dataId).values,n="string"===l.dtype?ff.fromUint8ToStringArray(e):e,r="string"===l.dtype?ff.fromUint8ToStringArray(t):t,[s,o]=a(l.shape,u.shape,n,r,d),i=c.makeTensorInfo(o,d);return c.texData.get(i.dataId).values=s,i}let h;return h=qe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new PD(t,l.shape,u.shape,n):new zD(e,l.shape,u.shape),c.runWebGLProgram(h,[l,u],d)}}function YD(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?qD:HD;if("leakyrelu"===e)return t?jD:VD;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var JD=class{constructor(e,t,n,r=!1,a=!1,s=!1,o=null,i=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=oO(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",A="";o&&(m=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,A="result = activation(result);");const g=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(x=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${y};\n          int batchB = ${x};\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${A}\n\n        setOutput(result);\n      }\n    `}},QD="return areal * breal - aimag * bimag;",ez="return areal * bimag + aimag * breal;",tz=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ff.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},nz="return a * b;";function rz(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=ff.upcastType(r.dtype,a.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),s=new tz(QD,r.shape,a.shape),o=new tz(ez,r.shape,a.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}],l=n.runWebGLProgram(s,i,"float32"),u=n.runWebGLProgram(o,i,"float32"),c=WD({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),[o,i]=YO(r.shape,a.shape,e.values,t.values,s),l=n.makeTensorInfo(i,s);return n.texData.get(l.dataId).values=o,l}let o;return o=qe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new PD(nz,r.shape,a.shape):new zD(nz,r.shape,a.shape),n.runWebGLProgram(o,[r,a],s)}var az={kernelName:Hn,backendName:"webgl",kernelFunc:rz};function sz(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,o=n,i=wa.sizeFromShape(a.shape),l=wa.inferFromImplicitShape(s,i),u=wa.sizeFromShape(l);wa.assert(i===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`));const c=o.texData.get(a.dataId);return!c.isPacked||kF(a.shape,l)||null!==c.texture&&kF(c.shape,l)?(o.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){const r=[yF(e.shape),...xF(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[yF(t),...xF(t)],o=new wD(s,r),i=[r],l=n.runWebGLProgram(o,[a],e.dtype,i,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,o)}var oz={kernelName:cr,backendName:"webgl",kernelFunc:sz},iz=class{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];const o=4*Math.floor(n/4),i=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${wa.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===i}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},lz=class{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let o="0.0",i="";"prod"===t?o="1.0":"min"===t?(o="1.0 / 1e-20",i="min"):"max"===t&&(o="-1.0 / 1e-20",i="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${i}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(o="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(o="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function uz(e,t,n,r){const a=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=ff.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let s=e;for(let o=0;o<a.length;o++){const{inSize:i,windowSize:l,outSize:u}=a[o];let c,d;c="mean"===n?0===o?new iz({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u},i):new iz({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u}):new lz({windowSize:l,inSize:i,batchSize:e.shape[0],outSize:u},n),d=s,s=r.runWebGLProgram(c,[s],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return s}function cz(e,t,n){const r=qe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=eO(this.rank),a=bD("rc",this.rank),s=new Array(this.rank);for(let e=0;e<t.length;e++)s[t[e]]=a[e];const o=`vec2(${s.slice(-2).join()})`,i=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${i}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${i}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}(e.shape,t):new class{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=eO(this.rank),a=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function dz(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;return function(e,t,n,r){const a=t,s=e.shape.length,o=wa.parseAxisParam(a,e.shape);let i=o;const l=ff.getAxesPermutation(i,s),u=null!=l;let c=e;u&&(c=cz(e,l,r),i=ff.getInnerMostAxes(i.length,s)),ff.assertAxesAreInnerMostDims("sum",i,s);const[d,h]=ff.computeOutAndReduceShapes(c.shape,i);let p=d;n&&(p=ff.expandShapeToKeepDim(d,o));const f=wa.sizeFromShape(h),m=sz({inputs:{x:c},attrs:{shape:[wa.sizeFromShape(e.shape)/f,f]},backend:r}),A=uz(m,ms(e.dtype),"sum",r),g=sz({inputs:{x:A},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(A),u&&r.disposeIntermediateTensorInfo(c),g}(a,s,o,n)}var hz={kernelName:Rr,backendName:"webgl",kernelFunc:dz};function pz(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,o=n,i=a.shape.length,l=new Array(i);for(let e=0;e<l.length;e++)l[e]=a.shape[s[e]];let u;if(o.shouldExecuteOnCPU([a])){const e=o.texData.get(a.dataId).values,t=yD(e,a.shape,a.dtype,s,l);u=o.makeTensorInfo(l,a.dtype);o.texData.get(u.dataId).values=t}else u=cz(a,s,o);return u}var fz={kernelName:Yr,backendName:"webgl",kernelFunc:pz};function mz({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],h=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),A=t.shape.slice(0,-2),g=wa.sizeFromShape(m),y=wa.sizeFromShape(A),x=Oi.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);wa.assert(d===h,(()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const b=n?[g,d,p]:[g,p,d],v=r?[y,f,h]:[y,h,f],w=sz({inputs:{x:e},backend:a,attrs:{shape:b}}),k=sz({inputs:{x:t},backend:a,attrs:{shape:v}}),S=[w,k],I=Math.max(g,y),C=n?w.shape[1]:w.shape[2],E=null!=s,N=null!=o,T="leakyrelu"===l,R=null!=l?YD(l,!0):null;let _;if((1===p||1===f)&&C>1e3&&!1===(E||N||T||null!=R)){let e=w,t=k;n&&(e=pz({inputs:{x:w},backend:a,attrs:{perm:[0,2,1]}}),S.push(e)),r&&(t=pz({inputs:{x:k},backend:a,attrs:{perm:[0,2,1]}}),S.push(t));const s=1===f;let o=e;1!==f&&(o=sz({inputs:{x:e},backend:a,attrs:{shape:[I,C,1]}}),S.push(o));const i=1===f?2:1;let l=t;s&&(l=sz({inputs:{x:t},backend:a,attrs:{shape:[I,1,C]}}),S.push(l));const u=rz({inputs:{a:o,b:l},backend:a});_=dz({inputs:{x:u},backend:a,attrs:{axis:i,keepDims:!0}}),S.push(u)}else{const l=fs(e.dtype,t.dtype),u=new JD(b,v,[I,p,f],n,r,E,R,N,T),c=[w,k];if(null!=s&&c.push(s),N&&c.push(o),T){const e=a.makeTensorInfo([],"float32",wa.createScalarValue(i,"float32"));c.push(e),S.push(e)}_=a.runWebGLProgram(u,c,l)}const M=sz({inputs:{x:_},backend:a,attrs:{shape:x}});S.push(_);for(const e of S)a.disposeIntermediateTensorInfo(e);return M}var Az={kernelName:oa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return mz({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}},gz="return abs(x);";var yz={kernelName:Je,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=sD(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let a;return a=qe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new TD(r.shape,gz):new CD(r.shape,gz),n.runWebGLProgram(a,[r],r.dtype)}},xz=KD({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),bz={kernelName:Qe,backendName:"webgl",kernelFunc:xz},vz=KD({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),wz={kernelName:et,backendName:"webgl",kernelFunc:vz},kz="return a + b;",Sz=ZD({opSnippet:kz,packedOpSnippet:kz,supportsComplex:!0,cpuKernelImpl:_O}),Iz={kernelName:tt,backendName:"webgl",kernelFunc:Sz};var Cz={kernelName:nt,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,a=n;if(1===a.length)return LD({inputs:{x:a[0]},backend:r});if(a.length>qe().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),s=e({inputs:a.slice(t),backend:r});return e({inputs:[n,s],backend:r})}const s=a.map((e=>e.dtype)).reduce(((e,t)=>fs(e,t))),o=a.map((e=>e.shape)),i=qe().getBool("WEBGL_PACK")?new class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}(a[0].shape,o):new class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}(a[0].shape,o);return r.runWebGLProgram(i,a,s)}};var Ez={kernelName:rt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,l=wa.parseAxisParam(s,a.shape);let u=l;const c=ff.getAxesPermutation(u,i);let d=a;null!=c&&(d=pz({inputs:{x:a},backend:n,attrs:{perm:c}}),u=ff.getInnerMostAxes(u.length,i)),ff.assertAxesAreInnerMostDims("all",u,i);const[h,p]=ff.computeOutAndReduceShapes(d.shape,u),f=sz({inputs:{x:d},backend:n,attrs:{shape:[-1,wa.sizeFromShape(p)]}}),m=uz(f,f.dtype,"all",n);let A;if(o){A=sz({inputs:{x:m},backend:n,attrs:{shape:ff.expandShapeToKeepDim(h,l)}})}else A=sz({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),A}};var Nz={kernelName:at,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,l=wa.parseAxisParam(s,a.shape);let u=l;const c=ff.getAxesPermutation(u,i);let d=a;null!=c&&(d=pz({inputs:{x:a},backend:n,attrs:{perm:c}}),u=ff.getInnerMostAxes(u.length,i)),ff.assertAxesAreInnerMostDims("any",u,i);const[h,p]=ff.computeOutAndReduceShapes(d.shape,u),f=sz({inputs:{x:d},backend:n,attrs:{shape:[-1,wa.sizeFromShape(p)]}}),m=uz(f,f.dtype,"any",n);let A;if(o){A=sz({inputs:{x:m},backend:n,attrs:{shape:ff.expandShapeToKeepDim(h,l)}})}else A=sz({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),A}};function Tz(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const o=ff.computeOptimalWindowSize(s),i={windowSize:o,inSize:s,batchSize:a,outSize:Math.ceil(s/o)},l=new class{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];const o="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${i};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}(i,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=Tz(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function Rz(e,t,n,r=null){const a=null!=r?r.shape:t.shape,s=a[a.length-1],o=ff.computeOptimalWindowSize(s),i=new class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,wa.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,l=eO(i),u=vD("coords",i);let c,d;if(1===s){d=i+1;const e=eO(d);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[i-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[i-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[i-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[i-2]};`}else d=i,c=`\n        ${l} sourceLocR = coords;\n        ++${u[i-1]};\n        ${l} sourceLocG = coords;\n        ++${u[i-2]};\n        ${l} sourceLocA = coords;\n        --${u[i-1]};\n        ${l} sourceLocB = coords;\n        --${u[i-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=vD("sourceLocR",d-1).concat("inIdx.r"),A=vD("sourceLocG",d-1).concat("inIdx.g"),g=vD("sourceLocB",d-1).concat("inIdx.b"),y=vD("sourceLocA",d-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",b=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${A.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,v=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${A.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,w=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[i-1]} < ${o[i-1]-1};\n        bool hasNextRow = ${u[i-2]} < ${o[i-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${b}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}(a,o,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(i,l,"int32");if(u.shape.length===t.shape.length){const r=Rz(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function _z(e,t,n,r){const a=[n];if(ff.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!qe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let o=t;null!==s&&s.isPacked&&(o=e.unpackTensor(t),n.push(o));const[i,l]=ff.computeOutAndReduceShapes(o.shape,a),u=wa.sizeFromShape(l),c=sz({inputs:{x:o},backend:e,attrs:{shape:[-1,u]}});n.push(c);const d=Tz(e,c,r);n.push(d);const h=sz({inputs:{x:d},backend:e,attrs:{shape:i}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return Rz(e,t,r)}var Mz={kernelName:st,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=wa.parseAxisParam(s,a.shape);const i=ff.getAxesPermutation(o,a.shape.length);let l=a;const u=[];null!=i&&(l=pz({inputs:{x:a},backend:n,attrs:{perm:i}}),u.push(l),o=ff.getInnerMostAxes(o.length,l.shape.length)),ff.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);const c=_z(n,l,o[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};var $z={kernelName:ot,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=wa.parseAxisParam(s,a.shape);const i=ff.getAxesPermutation(o,a.shape.length);let l=a;const u=[];null!=i&&(l=pz({inputs:{x:a},backend:n,attrs:{perm:i}}),u.push(l),o=ff.getInnerMostAxes(o.length,l.shape.length)),ff.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);const c=_z(n,l,o[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},Fz=KD({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Oz={kernelName:it,backendName:"webgl",kernelFunc:Fz},Dz=KD({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),zz={kernelName:lt,backendName:"webgl",kernelFunc:Dz},Pz=KD({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),Lz={kernelName:ut,backendName:"webgl",kernelFunc:Pz},Bz=ZD({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Wz={kernelName:dt,backendName:"webgl",kernelFunc:Bz},Uz=KD({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Vz={kernelName:ct,backendName:"webgl",kernelFunc:Uz},jz=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideHeight,i=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,A=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let g="0.0";if(f||(g="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${i});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:A:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(y="avgValue / count");const x=4*Math.floor(s/4),b=s%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${g};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${g});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${y});\n      }\n    `}},Gz=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,A=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let x="0.0";if(y||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${i}, ${l});\n        const ivec3 pads = ivec3(${m}, ${A}, ${g});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / count");const v=4*Math.floor(s/4),w=s%4,k=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${i}, ${l});\n      const ivec3 pads = ivec3(${m}, ${A}, ${g});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${v};\n            if (${1===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n          setOutput(${b});\n        }\n      }\n    `}};var Hz={kernelName:ht,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;OF(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;wa.assert(ff.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=ff.computePool2DInfo(a.shape,s,o,1,i,l);if(1===u.filterWidth&&1===u.filterHeight&&wa.arraysEqual(u.inShape,u.outShape))return LD({inputs:{x:a},backend:n});const c=new jz(u,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}};var qz={kernelName:ft,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l,dataFormat:u}=r,c=ff.computePool3DInfo(a.shape,s,o,[1,1,1],i,l,u),d=new Gz(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}};var Xz={kernelName:mt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=r,d=ff.computePool3DInfo(o.shape,i,l,[1,1,1],u,c),h=new class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,A=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${A});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(d);return n.runWebGLProgram(h,[a],o.dtype)}};var Kz={kernelName:pt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s;OF([a,s],"avgPoolGrad");const{filterSize:i,strides:l,pad:u}=r,c=ff.computePool2DInfo(o.shape,i,l,1,u),d=new class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=i-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${o}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(c);return n.runWebGLProgram(d,[a],o.dtype)}};var Zz={kernelName:At,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:o,transposeB:i}=r;return mz({a:a,b:s,transposeA:o,transposeB:i,backend:n})}},Yz={kernelName:ln,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:a,variance:s,offset:o,scale:i}=e;wa.assert(a.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),wa.assert(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),wa.assert(null==i||a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[r,a,s];let c=null;null!=o&&(c=o.shape,u.push(o));let d=null;null!=i&&(d=i.shape,u.push(i));const h=qe().getBool("WEBGL_PACK_NORMALIZATION")?new class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ff.assertAndGetBroadcastShape(e,t),ff.assertAndGetBroadcastShape(e,n);let o="vec4(0.0)";null!=r&&(ff.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=a&&(ff.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}(r.shape,a.shape,s.shape,c,d,l):new class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],ff.assertAndGetBroadcastShape(e,t),ff.assertAndGetBroadcastShape(e,n);let o="0.0";null!=r&&(ff.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=a&&(ff.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}(r.shape,a.shape,s.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)}},Jz=["x","y","z","w","u","v"];function Qz(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:o}=r,[i,l]=Qi.parseSliceParams(a,s,o);if(Qi.assertParamsValid(a,i,l),0===wa.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.texData.get(a.dataId),t=oD(e.values,i,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}const{isPacked:u}=n.texData.get(a.dataId),c=Qi.isSliceContinous(a.shape,i,l);if(u||!c){const e=qe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=eO(this.rank),n=vD("coords",this.rank),r=vD("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,o=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${o}\n        ${i}\n        setOutput(result);\n      }\n    `}}(l):new class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=eO(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return Jz.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${Jz[t]} = start[${t}] + coords.${Jz[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}(l),t=[i];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){const a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),o=r.texData.get(s.dataId);Object.assign(o,a),o.refCount=1,o.shape=n,o.dtype=e.dtype;let i=Qi.computeFlatOffset(t,wa.computeStrides(e.shape));a.slice&&(i+=a.slice.flatOffset),o.slice={flatOffset:i,origDataId:a.slice&&a.slice.origDataId||e.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),s}(a,i,l,n)}var eP={kernelName:kr,backendName:"webgl",kernelFunc:Qz},tP={kernelName:gt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:o}=r;wa.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),l=ff.getReshaped(a.shape,s,i),u=ff.getPermuted(l.length,s.length),c=ff.getReshapedPermuted(a.shape,s,i),d=ff.getSliceBeginCoords(o,s.length),h=ff.getSliceSize(c,o,s.length),p=[],f=sz({inputs:{x:a},backend:n,attrs:{shape:l}}),m=pz({inputs:{x:f},backend:n,attrs:{perm:u}}),A=sz({inputs:{x:m},backend:n,attrs:{shape:c}}),g=Qz({inputs:{x:A},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(A),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};var nP={kernelName:yt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:o}=r,i=n.readSync(a.dataId),l=n.readSync(s.dataId),u=MO(i,l,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,u)}};var rP={kernelName:bt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),o=n.readSync(a.dataId),i=ff.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},aP=ZD({opSnippet:"return float(a != b);",cpuKernelImpl:QO,dtype:"bool"}),sP={kernelName:Xn,backendName:"webgl",kernelFunc:aP};function oP(e){const{inputs:t,backend:n}=e,{input:r}=t;return LD({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}var iP={kernelName:ir,backendName:"webgl",kernelFunc:oP};var lP={kernelName:vt,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:o}=a;if("complex64"===o){if("complex64"===s.dtype)return LD({inputs:{x:s},backend:r});const t=dd(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=WD({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){const t=oP({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(t),n}if(!wa.hasEncodingLoss(s.dtype,o)){const e=LD({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:o}}if("int32"===o)return function(e,t){const n=new CD(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===o){const e=r.makeTensorInfo([],"bool",wa.getTypedArrayFromDType("bool",1)),t=aP({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},uP="return ceil(x);",cP=KD({opSnippet:uP,packedOpSnippet:uP,cpuKernelImpl:FO}),dP={kernelName:wt,backendName:"webgl",kernelFunc:cP};var hP={kernelName:kt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:o}=r;let i;i=qe().getBool("WEBGL_PACK_CLIP")?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}(a.shape):new class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}(a.shape);const l=[[s],[o]];return n.runWebGLProgram(i,[a],a.dtype,l)}};function pP(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var fP={kernelName:It,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}(r.shape),o=[pP(r,a.complexTensorInfos.real),pP(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}};function mP(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function AP(e){const{inputs:t,backend:n}=e,{input:r}=t;return LD({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}var gP={kernelName:mn,backendName:"webgl",kernelFunc:AP};function yP(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>oP({inputs:{input:e},backend:n}))),a=e.map((e=>AP({inputs:{input:e},backend:n}))),s=yP(r,t,n),o=yP(a,t,n),i=WD({inputs:{real:s,imag:o},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=wa.sizeFromShape(e.shape.slice(t));return sz({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=ff.computeOutShape(a.map((e=>e.shape)),1),i=1===a[0].shape[0],l=OO(s,o,r,i),u=ff.computeOutShape(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const s=qe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(e.length>s){const r=[];for(let a=0;a<e.length;a+=s){const o=e.slice(a,a+s);r.push(yP(o,t,n))}const a=yP(r,t,n);for(const e of r)n.disposeIntermediateTensorInfo(e);return a}if(qe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const a=new class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ff.computeOutShape(e,t);const n=this.outputShape,r=n.length,a=eO(r),s=vD("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const i=new Array(e.length-1);i[0]=e[0][t];for(let n=1;n<i.length;n++)i[n]=i[n-1]+e[n][t];const l=o[t],u=o.slice(-2),c=o.join();let d=`if (${l} < ${i[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let e=1;e<i.length;e++){const t=i[e-1];d+=`\n        if (${l} < ${i[e]}  && ${l} >= ${i[e-1]}) {\n          return getChannel(\n            getT${e}(${mP(o,l,t)}),\n            vec2(${mP(u,l,t)}));\n        }`}const h=i.length,p=i[i.length-1];d+=`\n        return getChannel(\n          getT${h}(${mP(o,l,p)}),\n          vec2(${mP(u,l,p)}));`,this.userCode=`\n      float getValue(${o.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}(e.map((e=>e.shape)),t);return n.runWebGLProgram(a,e,r)}const{tensors2D:o,outShape:i}=function(e,t,n){const r=ff.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>sz({inputs:{x:e},attrs:{shape:[-1,wa.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(e,t,n),l=new class{constructor(e){this.outputShape=[],this.outputShape=ff.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}(o.map((e=>e.shape))),u=n.runWebGLProgram(l,o,r);o.forEach((e=>n.disposeIntermediateTensorInfo(e)));const c=sz({inputs:{x:u},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(u),c}function xP(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=wa.parseAxisParam(a,t[0].shape)[0],o=ff.computeOutShape(t.map((e=>e.shape)),s);if(0===wa.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>wa.sizeFromShape(e.shape)>0));if(1===i.length)return LD({inputs:{x:i[0]},backend:n});const l=i.map((e=>e.shape));return ff.assertParamsConsistent(l,s),yP(i,s,n)}var bP={kernelName:Ct,backendName:"webgl",kernelFunc:xP},vP=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,o=e.padInfo.left,i=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,A=m?1:2,g=m?2:3,y=m?3:1;let x="",b="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,b="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${i}, ${l});\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${A}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${b}\n        setOutput(result);\n      }\n    `}};function wP(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function kP({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],h=n.outChannels,p="channelsLast"===n.dataFormat;let f;const m=[];if(null!=s){const e=wP(s.shape,p);null!=e&&(s=sz({inputs:{x:s},backend:r,attrs:{shape:e}}),m.push(s))}if(null!=a){const e=wP(a.shape,p);null!=e&&(a=sz({inputs:{x:a},backend:r,attrs:{shape:e}}),m.push(a))}if(!((1===d||1===h)&&c>1e3)&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&wa.arraysEqual(u.shape.slice(-3),l.slice(-3))){const c=l[0]*l[1]*(l[2]+1),d={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},h=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,wa.assert(kF(u.shape,d.shape),(()=>`packed reshape ${u.shape} to ${d.shape} isn't free`));const p=sz({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(p);const A=mz({a:d,b:p,backend:r,transposeA:false,transposeB:false,bias:a,activation:i,preluActivationWeights:s,leakyreluAlpha:o}),g=r.texData.get(A.dataId);wa.assert(g.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=h,g.shape=n.outShape,f=LD({inputs:{x:A},backend:r}),f.shape=n.outShape,m.push(A)}else{const l=n.outHeight*n.outWidth,u=sz({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,l,n.inChannels]:[n.batchSize,n.inChannels,l]}}),c=sz({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=mz({a:p?u:c,b:p?c:u,transposeA:!p,transposeB:false,backend:r,bias:a,activation:i,preluActivationWeights:s,leakyreluAlpha:o});f=sz({inputs:{x:d},backend:r,attrs:{shape:n.outShape}}),m.push(u),m.push(c),m.push(d)}for(const e of m)r.disposeIntermediateTensorInfo(e);return f}function SP({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=n,f="channelsLast"===p,m=l*u*c,A=h*d,g=[n.batchSize,m,A],y=[];if(null!=s){const e=wP(s.shape,f);null!=e&&(s=sz({inputs:{x:s},backend:r,attrs:{shape:e}}),y.push(s))}if(null!=a){const e=wP(a.shape,f);null!=e&&(a=sz({inputs:{x:a},backend:r,attrs:{shape:e}}),y.push(a))}const x=sz({inputs:{x:t},backend:r,attrs:{shape:[1,m,wa.sizeFromShape(t.shape)/m]}});y.push(x);const b=new class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=oO(this.outputShape.length);const{dataFormat:n}=t,r=zF(),a="channelsLast"===n,s=a?1:2,o=a?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)l+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${i}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${o}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}(g,n),v=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],w=r.runWebGLProgram(b,[e],"float32",v),k=sz({inputs:{x:w},backend:r,attrs:{shape:g}});y.push(w),y.push(k);const S=null!=a,I=null!=s,C="leakyrelu"===i,E=i?YD(i,!0):null,N=new JD(f?k.shape:x.shape,f?x.shape:k.shape,f?[n.batchSize,A,n.outChannels]:[n.batchSize,n.outChannels,A],!0,!1,S,E,I,C),T=f?[k,x]:[x,k];if(a&&T.push(a),I&&T.push(s),C){const e=r.makeTensorInfo([],"float32",wa.createScalarValue(o,"float32"));T.push(e),y.push(e)}const R=r.runWebGLProgram(N,T,"float32"),_=sz({inputs:{x:R},backend:r,attrs:{shape:n.outShape}});y.push(R);for(const e of y)r.disposeIntermediateTensorInfo(e);return _}var IP={kernelName:Et,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=ff.convertConv2DDataFormat(l),h=ff.computeConv2DInfo(a.shape,s.shape,o,u,i,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(qe().getBool("WEBGL_CONV_IM2COL"))p=SP({x:a,filter:s,convInfo:h,backend:n});else{const e=new vP(h);p=n.runWebGLProgram(e,[a,s],"float32")}else p=kP({x:a,filter:s,convInfo:h,backend:n});const f=sz({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};var CP={kernelName:Nt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=ff.convertConv2DDataFormat(l),h=ff.computeConv2DInfo(a.shape,c,o,1,i,u,!1,d),p=new class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${s}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(h);return n.runWebGLProgram(p,[a,s],"float32")}};var EP={kernelName:Tt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:o,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=ff.convertConv2DDataFormat(u),h=ff.computeConv2DInfo(o,s.shape,i,1,l,c,!1,d),p=new class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(h);return n.runWebGLProgram(p,[a,s],"float32")}};var NP={kernelName:Rt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:l}=r,u=ff.computeConv3DInfo(a.shape,s.shape,o,l,i),c=new class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${o});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(u);return n.runWebGLProgram(c,[a,s],"float32")}};var TP={kernelName:_t,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,pad:i,filterShape:l}=r,u=ff.computeConv3DInfo(a.shape,l,o,1,i),c=new class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,o=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${o};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(u);return n.runWebGLProgram(c,[a,s],"float32")}};var RP,_P,MP={kernelName:Mt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:o,strides:i,inputShape:l}=r,u=ff.computeConv3DInfo(l,s.shape,i,1,o),c=new class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(u);return n.runWebGLProgram(c,[a,s],"float32")}},$P=KD({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),FP={kernelName:$t,backendName:"webgl",kernelFunc:$P},OP=KD({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),DP={kernelName:Ft,backendName:"webgl",kernelFunc:OP},zP={kernelName:zt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:o}=t,{cropSize:i,method:l,extrapolationValue:u}=r,c=new class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,i,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];const h="bilinear"===r?1:0,[p,f]=[o-1+".0",i-1+".0"],[m,A,g]=c>1?[""+(o-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[y,x,b]=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${A};\n        float width_scale = ${x};\n\n        float in_y = ${g};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${b};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}(a.shape,s.shape,i,l,u);return n.runWebGLProgram(c,[a,s,o],"float32")}};(_P=RP||(RP={})).Prod="*",_P.Sum="+";var PP=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===RP.Prod?"1.0":"0.0",o=n?s:`getX(${LP(a,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(i-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${i}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${eO(a)} coords = getOutputCoords();\n        int end = ${BP(a,"coords",this.op)};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${BP(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${LP(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function LP(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function BP(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function WP(e,t,n,r,a,s){const o=t.shape.length,i=ff.getAxesPermutation([r],o);let l=t;null!=i&&(l=pz({inputs:{x:t},backend:n,attrs:{perm:i}}));const u=ff.getInnerMostAxes(1,o)[0];if(u!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=LD({inputs:{x:l},backend:n});for(let t=0;t<=Math.ceil(Math.log2(c))-1;t++){const r=new PP(e,l.shape,!1,s),a=[[t]],o=d;d=n.runWebGLProgram(r,[d],d.dtype,a),n.disposeIntermediateTensorInfo(o)}if(a){const t=new PP(e,l.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=i){const e=pz({inputs:{x:d},backend:n,attrs:{perm:ff.getUndoAxesPermutation(i)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}var UP={kernelName:Ot,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;return WP(RP.Prod,a,n,s,o,i)}};var VP={kernelName:Dt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;return WP(RP.Sum,a,n,s,o,i)}};var jP={kernelName:Pt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:o,binaryOutput:i}=r;if(1===a.shape.length){const e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=MO(e,t,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,r)}if(2===a.shape.length){const e=n.bufferSync(a),t=n.bufferSync(s),r=$O(e,t,o,i);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};var GP={kernelName:Lt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:o}=r,i=a.shape[0],l=("NHWC"===o?a.shape[1]:a.shape[2])*s,u=("NHWC"===o?a.shape[2]:a.shape[3])*s,c=("NHWC"===o?a.shape[3]:a.shape[1])/(s*s),d="NHWC"===o?[i,l,u,c]:[i,c,l,u],h=new class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}(d,s,o);return n.runWebGLProgram(h,[a],a.dtype)}},HP=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=oO(this.outputShape.length);const s=e.filterHeight,o=e.filterWidth,i=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}},qP=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=oO(this.outputShape.length);const s=e.outChannels/e.inChannels,o=e.padInfo.left,i=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<c;e++)h+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let e=0;e<c;e++)h+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(d+1)/2;e++){const t=2*e;if(h+=`\n          xC = xCCorner + ${t*l};\n          `,1===i){if(t<c&&(o%2==1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,h+=1===l&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<c)){const e=o%2==0?wa.nearestLargerEven(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,l>1&&(h+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                      xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${t}Ready = 1;\n                    }\n                    `),h+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                  `):h+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<c&&(o%2==1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<c&&(h+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<c&&(h+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<c&&(h+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}};var XP={kernelName:Bt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),wa.assert(ff.eitherStridesOrDilationsAreOne(o,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`));const d=ff.computeConv2DInfo(a.shape,s.shape,o,c,i,u,!0);let h;h=qe().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new qP(d):new HP(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[a,s],"float32",p)}};var KP={kernelName:Wt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=r,d=ff.computeConv2DInfo(a.shape,c,o,i,l,u,!0),h=new class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(d);return n.runWebGLProgram(h,[a,s],"float32")}};var ZP={kernelName:Ut,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=r,d=ff.computeConv2DInfo(c,s.shape,o,i,l,u,!0),h=new class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,o=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(d);return n.runWebGLProgram(h,[a,s],"float32")}};var YP={kernelName:Vt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=wa.sizeFromShape(r.shape),o=sz({inputs:{x:r},backend:n,attrs:{shape:[s]}}),i=new class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}(s),l=n.runWebGLProgram(i,[o],o.dtype),u=sz({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}};var JP={kernelName:jt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dilations:l}=r,u=ff.computeDilation2DInfo(a.shape,s.shape,o,i,"NHWC",l);let c;const d=new class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:o,filterWidth:i,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${i}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}(u);c=n.runWebGLProgram(d,[a,s],"float32");const h=sz({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}};var QP={kernelName:Xt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:o,summedDims:i,idDims:l}=ff.decodeEinsumEquation(a,s.length);ff.checkEinsumDimSizes(o.length,l,s);const{path:u,steps:c}=ff.getEinsumComputePath(i,l),d=c.length;let h=null,p=o.length;const f=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:r}=ff.getEinsumPermutation(p,l[t]);let a;ff.isIdentityPermutation(e)?a=s[t]:(a=pz({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(a));const o=a.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);wa.arraysEqual(a.shape,o)||(a=sz({inputs:{x:a},backend:n,attrs:{shape:o}}),f.push(a)),null===h?h=a:(h=rz({inputs:{a:a,b:h},backend:n}),f.push(h))}e<d-1&&(u[e]>=0&&(h=dz({inputs:{x:h},backend:n,attrs:{axis:u[e]-(o.length-p),keepDims:!1}}),f.push(h)),p--)}for(const e of f)e!==h&&n.disposeIntermediateTensorInfo(e);return h}},eL=KD({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),tL={kernelName:Kt,backendName:"webgl",kernelFunc:eL},nL={kernelName:Zt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=qe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new PD("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new zD("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},rL=ZD({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:DO}),aL={kernelName:Jt,backendName:"webgl",kernelFunc:rL},sL=KD({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${ff.ERF_P};\n  float a1 = ${ff.ERF_A1};\n  float a2 = ${ff.ERF_A2};\n  float a3 = ${ff.ERF_A3};\n  float a4 = ${ff.ERF_A4};\n  float a5 = ${ff.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),oL={kernelName:Yt,backendName:"webgl",kernelFunc:sL},iL=KD({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:zO,dtype:"float32"}),lL={kernelName:Qt,backendName:"webgl",kernelFunc:iL};function uL(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,o=s.shape.length,i=s.shape.slice();let l=a;return a<0&&(wa.assert(-(o+1)<=a,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+a+1),i.splice(l,0,1),sz({inputs:{x:s},backend:r,attrs:{shape:i}})}var cL={kernelName:en,backendName:"webgl",kernelFunc:uL},dL="return exp(x) - 1.0;",hL=KD({opSnippet:dL,packedOpSnippet:dL,cpuKernelImpl:PO}),pL={kernelName:tn,backendName:"webgl",kernelFunc:hL},fL=class{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0";let o;if("real"===e)o="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function mL(e,t,n){const r=n.texData.get(e.dataId),a=wa.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],o=sz({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),i=o.shape,l=new fL("real",i,t),u=new fL("imag",i,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:i},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:i}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=WD({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=sz({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(p),f}var AL={kernelName:nn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return mL(r,!1,n)}};function gL(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||wa.inferDtype(a),"string"===s){const e=wa.getArrayFromDType(s,wa.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{const e=new class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}var yL,xL={kernelName:rn,backendName:"webgl",kernelFunc:gL},bL={kernelName:an,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,a=new class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},vL="return floor(x);",wL=KD({opSnippet:vL,packedOpSnippet:vL,cpuKernelImpl:LO}),kL={kernelName:sn,backendName:"webgl",kernelFunc:wL},SL=ZD({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),IL={kernelName:on,backendName:"webgl",kernelFunc:SL},CL={kernelName:aa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:s}=r,o="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,i="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[u,l],d=[u,l,s];(i||o)&&(null==yL&&(yL=document.createElement("canvas").getContext("2d")),yL.canvas.width=l,yL.canvas.height=u,yL.drawImage(a,0,0,l,u),a=yL.canvas);const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=N$.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);const p=qe().getBool("WEBGL_PACK")?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=zF(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}(d):new class{constructor(e){this.variableNames=["A"];const t=zF(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};var EL={kernelName:ia,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=ff.convertConv2DDataFormat(c),A=ff.computeConv2DInfo(a.shape,s.shape,l,d,u,h,!1,m);let g;const y=[];if(1!==A.filterHeight||1!==A.filterWidth||1!==A.dilationHeight||1!==A.dilationWidth||1!==A.strideHeight||1!==A.strideWidth||"SAME"!==A.padInfo.type&&"VALID"!==A.padInfo.type)if(qe().getBool("WEBGL_CONV_IM2COL"))g=SP({x:a,filter:s,convInfo:A,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const e=null!=o,t=null!=i,r="leakyrelu"===p,l=p?YD(p,!1):null,u=new vP(A,e,l,t,r),d=[a,s],h=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=sz({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(e&&d.push(h(o,c)),t&&d.push(h(i,c)),r){const e=n.makeTensorInfo([],"float32",wa.createScalarValue(f,"float32"));d.push(e),y.push(e)}g=n.runWebGLProgram(u,d,"float32")}else g=kP({x:a,filter:s,convInfo:A,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const x=sz({inputs:{x:g},backend:n,attrs:{shape:A.outShape}});return y.push(g),y.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}};var NL={kernelName:la,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),wa.assert(ff.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const A=ff.computeConv2DInfo(a.shape,s.shape,l,m,u,d,!0),g=qe().getBool("WEBGL_PACK_DEPTHWISECONV")&&A.strideWidth<=2&&A.outChannels/A.inChannels==1,y=h?YD(h,g):null,x=[a,s],b=null!=o,v=null!=i,w="leakyrelu"===h;if(b&&x.push(o),v&&x.push(i),w){const e=n.makeTensorInfo([],"float32",wa.createScalarValue(p,"float32"));x.push(e),f.push(e)}let k;k=g?new qP(A,b,y,v,w):new HP(A,b,y,v,w);const S=[[A.padInfo.top,A.padInfo.left],[A.strideHeight,A.strideWidth],[A.dilationHeight,A.dilationWidth],[A.inHeight,A.inWidth]],I=n.runWebGLProgram(k,x,"float32",S);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}};var TL={kernelName:cn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,o=s[s.length-1],i=wa.sizeFromShape(r.shape),[l,u,c,d]=ff.prepareAndValidate(r,a),h=sz({inputs:{x:a},backend:n,attrs:{shape:[u,o]}}),p=sz({inputs:{x:r},backend:n,attrs:{shape:[wa.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),s=BO(e,t,r.dtype,u,o,c,d,r.shape,i);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=eO(t.length),s=eO(n.length),o=this.sliceDim>1?"strides[j]":"strides",i=eO(r.length),l=r.length>1?"paramsShape[j]":"paramsShape";this.userCode=`\n        ${a} strides = ${a}(${this.strides});\n        ${i} paramsShape = ${i}(${this.paramsShape});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            out_of_bounds = out_of_bounds || index < 0;\n            out_of_bounds = out_of_bounds || index >= ${l};\n            flattenIndex += index * ${o};\n          }\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}(o,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),A=sz({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),A}};function RL(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:o,batchDims:i}=r,l=wa.parseAxisParam(o,a.shape)[0];if(qe().get("DEBUG")){const e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){const r=e[n];wa.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const u=ff.segment_util.collectGatherOpShapeInfo(a,s,l,i),c=wa.sizeFromShape(s.shape),d=[],h=sz({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=sz({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),r=WO(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=eO(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let t=0;t<e.length;t++)2===t?r.push("index"):r.push(`${n[t]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}(h.shape,f),A=n.runWebGLProgram(m,[h,p],h.dtype);d.push(A);const g=sz({inputs:{x:A},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}var _L={kernelName:un,backendName:"webgl",kernelFunc:RL},ML=ZD({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:UO,dtype:"bool"}),$L={kernelName:dn,backendName:"webgl",kernelFunc:ML},FL=ZD({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:VO}),OL={kernelName:hn,backendName:"webgl",kernelFunc:FL};var DL={kernelName:fn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return mL(r,!0,n)}},zL=KD({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),PL={kernelName:An,backendName:"webgl",kernelFunc:zL},LL=KD({opSnippet:"return float(isinf(x));",dtype:"bool"}),BL={kernelName:gn,backendName:"webgl",kernelFunc:LL},WL=KD({opSnippet:"return float(isnan(x));",dtype:"bool"}),UL={kernelName:yn,backendName:"webgl",kernelFunc:WL},VL=ZD({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:jO,dtype:"bool"}),jL={kernelName:bn,backendName:"webgl",kernelFunc:VL},GL=ZD({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:GO,dtype:"bool"}),HL={kernelName:vn,backendName:"webgl",kernelFunc:GL};var qL={kernelName:wn,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,o=HO(r,a,s);return t.makeTensorInfo([o.length],"float32",o)}},XL=KD({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:qO}),KL={kernelName:kn,backendName:"webgl",kernelFunc:XL},ZL=KD({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),YL={kernelName:Sn,backendName:"webgl",kernelFunc:ZL},JL=ZD({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),QL={kernelName:In,backendName:"webgl",kernelFunc:JL},eB=KD({opSnippet:"return float(!(x >= 1.0));"}),tB={kernelName:Cn,backendName:"webgl",kernelFunc:eB},nB=ZD({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),rB={kernelName:En,backendName:"webgl",kernelFunc:nB},aB={kernelName:_n,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:o,alpha:i,beta:l}=r,u=qe().getBool("WEBGL_PACK_NORMALIZATION")?new class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,o=e[3]-1;let i;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;i=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}(a.shape,s,o,i,l):new class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const s=t,o=e[3]-1;let i;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;i=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}(a.shape,s,o,i,l);return n.runWebGLProgram(u,[a],a.dtype)}},sB={kernelName:Mn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:o}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=r,d=new class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}(a.shape,i,l,u,c);return n.runWebGLProgram(d,[a,s,o],a.dtype)}};function oB(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:o}=r,i=a.shape.length,l=wa.parseAxisParam(s,a.shape);let u=l;const c=ff.getAxesPermutation(u,i),d=null!=c,h=n.shouldExecuteOnCPU([a]);let p=a;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(i);for(let e=0;e<t.length;e++)t[e]=a.shape[c[e]];const r=yD(e,a.shape,a.dtype,c,t);p=n.makeTensorInfo(t,a.dtype);n.texData.get(p.dataId).values=r}else p=cz(a,c,n);u=ff.getInnerMostAxes(u.length,i)}ff.assertAxesAreInnerMostDims("max",u,i);const[f,m]=ff.computeOutAndReduceShapes(p.shape,u);let A,g=f;if(o&&(g=ff.expandShapeToKeepDim(f,l)),h){const e=n.texData.get(p.dataId).values,t=XO(e,wa.sizeFromShape(m),g,a.dtype);A=n.makeTensorInfo(g,a.dtype);n.texData.get(A.dataId).values=t}else A=function(e,t,n,r){const a=wa.sizeFromShape(t),s=sz({inputs:{x:e},attrs:{shape:[wa.sizeFromShape(e.shape)/a,a]},backend:r}),o=uz(s,e.dtype,"max",r),i=sz({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}(p,m,g,n);return d&&n.disposeIntermediateTensorInfo(p),A}var iB={kernelName:$n,backendName:"webgl",kernelFunc:oB},lB=ZD({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:KO}),uB={kernelName:Fn,backendName:"webgl",kernelFunc:lB};var cB={kernelName:On,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;OF(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r;wa.assert(ff.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));const u=ff.computePool2DInfo(a.shape,s,o,1,i,l);if(1===u.filterWidth&&1===u.filterHeight&&wa.arraysEqual(u.inShape,u.outShape))return LD({inputs:{x:a},backend:n});const c=new jz(u,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}};var dB={kernelName:zn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:i,dataFormat:l,dimRoundingMode:u}=r,c=ff.computePool3DInfo(a.shape,s,o,[1,1,1],i,u,l),d=new Gz(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}};var hB={kernelName:Pn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,o=s,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=r,d=ff.computePool3DInfo(o.shape,i,l,[1,1,1],u,c),h=new Gz(d,"max",!0),p=n.runWebGLProgram(h,[o],o.dtype),f=new class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=i-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=i*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${o}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(d),m=n.runWebGLProgram(f,[a,p],o.dtype);return n.disposeIntermediateTensorInfo(p),m}};var pB={kernelName:Dn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:o}=t,i=s;OF([s,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=ff.computePool2DInfo(i.shape,l,u,1,c,d),p=new jz(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,o=a-1-e.padInfo.top,i=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(h),A=n.runWebGLProgram(m,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),A}};var fB={kernelName:Ln,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:a,strides:s,pad:o,includeBatchInIndex:i}=t,l=n;wa.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const u=[1,1];wa.assert(ff.eitherStridesOrDilationsAreOne(s,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`));const c=ff.computePool2DInfo(r.shape,a,s,u,o),[d,h]=function(e,t,n,r){let a=new jz(n,"max",!1);const s=r.runWebGLProgram(a,[e],"float32");return a=new jz(n,"max",!0,!0,t),[s,r.runWebGLProgram(a,[e],"float32")]}(r,i,c,l);return[d,h]}};var mB={kernelName:Bn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:a,axis:s}=t,o=n,i=r.shape.length,l=wa.parseAxisParam(s,r.shape);let u=l;const c=ff.getAxesPermutation(u,i),d=null!=c,h=o.shouldExecuteOnCPU([r]),p=[];let f=r;if(d){if(h){const e=o.texData.get(f.dataId).values,t=new Array(i);for(let e=0;e<t.length;e++)t[e]=r.shape[c[e]];const n=yD(e,r.shape,r.dtype,c,t);f=o.makeTensorInfo(t,r.dtype);o.texData.get(f.dataId).values=n}else f=cz(r,c,o);p.push(f),u=ff.getInnerMostAxes(u.length,i)}ff.assertAxesAreInnerMostDims("sum",u,i);const[m,A]=ff.computeOutAndReduceShapes(f.shape,u);let g=m;a&&(g=ff.expandShapeToKeepDim(m,l));const y=function(e,t,n,r){const a=wa.sizeFromShape(t),s=sz({inputs:{x:e},attrs:{shape:[wa.sizeFromShape(e.shape)/a,a]},backend:r}),o=uz(s,"float32","mean",r),i=sz({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}(f,A,g,o);for(const e of p)o.disposeIntermediateTensorInfo(e);return y}};var AB={kernelName:Wn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,l=wa.parseAxisParam(s,a.shape);let u=l;const c=ff.getAxesPermutation(u,i);let d=a;null!=c&&(d=pz({inputs:{x:a},backend:n,attrs:{perm:c}}),u=ff.getInnerMostAxes(u.length,a.shape.length)),ff.assertAxesAreInnerMostDims("min",u,i);const[h,p]=ff.computeOutAndReduceShapes(d.shape,u),f=sz({inputs:{x:d},backend:n,attrs:{shape:[-1,wa.sizeFromShape(p)]}}),m=uz(f,f.dtype,"min",n);let A;if(o){A=sz({inputs:{x:m},backend:n,attrs:{shape:ff.expandShapeToKeepDim(h,l)}})}else A=sz({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),A}},gB=ZD({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:ZO}),yB={kernelName:Un,backendName:"webgl",kernelFunc:gB},xB={kernelName:Vn,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:a,mode:s}=n,o=qe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=eO(r),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=vD("rc",r),l=vD("source",r),u=`${i[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1;let h="";if(1===r){const e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${i[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${i[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${i[r-2]} += 1;\n        if(${i[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${i[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}(r.shape,a,s):new class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=eO(r),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${i}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}(r.shape,a,s);return t.runWebGLProgram(o,[r],r.dtype)}},bB=ZD({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),vB={kernelName:jn,backendName:"webgl",kernelFunc:bB},wB=ZD({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),kB={kernelName:qt,backendName:"webgl",kernelFunc:wB},SB="return a - b;",IB=ZD({opSnippet:SB,packedOpSnippet:SB,supportsComplex:!0,cpuKernelImpl:mD}),CB={kernelName:Gr,backendName:"webgl",kernelFunc:IB};function EB(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,o=wa.parseAxisParam([s],a.shape),i=oB({inputs:{x:a},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=ff.expandShapeToKeepDim(i.shape,o),u=sz({inputs:{x:i},backend:n,attrs:{shape:l}}),c=IB({inputs:{a:a,b:u},backend:n}),d=iL({inputs:{x:c},backend:n}),h=dz({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),p=sz({inputs:{x:h},backend:n,attrs:{shape:l}}),f=wB({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}var NB={kernelName:$r,backendName:"webgl",kernelFunc:EB};var TB={kernelName:Gn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:o,normalized:i}=r,l=i?a:EB({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}(u,c,s),h=[[o]],p=n.runWebGLProgram(d,[l],"int32",h);return i||n.disposeIntermediateTensorInfo(l),p}};var RB={kernelName:qn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,a]=JO(e.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,t)}let a;return a=qe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new TD(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new CD(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),n.runWebGLProgram(a,[r],r.dtype)}},_B=fm.nonMaxSuppressionV3Impl;var MB={kernelName:Kn,backendName:"webgl",kernelFunc:function(e){ff.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=_B(u,c,o,i,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},$B=fm.nonMaxSuppressionV4Impl;var FB={kernelName:Zn,backendName:"webgl",kernelFunc:function(e){ff.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=$B(c,d,o,i,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},OB=fm.nonMaxSuppressionV5Impl;var DB={kernelName:Yn,backendName:"webgl",kernelFunc:function(e){ff.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),h=o,p=i,f=l,m=u,{selectedIndices:A,selectedScores:g}=OB(c,d,h,p,f,m);return[n.makeTensorInfo([A.length],"int32",new Int32Array(A)),n.makeTensorInfo([g.length],"float32",new Float32Array(g))]}},zB={kernelName:Qn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{depth:s,onValue:o,offValue:i}=r,l=wa.sizeFromShape(a.shape),u=new class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}(l,s,o,i),c=sz({inputs:{x:a},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(u,[c],a.dtype);n.disposeIntermediateTensorInfo(c);const h=sz({inputs:{x:d},backend:n,attrs:{shape:[...a.shape,s]}});return n.disposeIntermediateTensorInfo(d),h}};function PB(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=oP({inputs:{input:r},backend:n}),t=PB({inputs:{x:e},backend:n}),a=AP({inputs:{input:r},backend:n}),s=PB({inputs:{x:a},backend:n}),o=WD({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),o}return gL({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var LB={kernelName:na,backendName:"webgl",kernelFunc:PB};var BB={kernelName:Jn,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const t=oP({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=AP({inputs:{input:a},backend:r}),o=PB({inputs:{x:s},backend:r}),i=WD({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),i}return gL({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};var WB={kernelName:er,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return uL({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{wa.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),wa.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=xP({inputs:t.map((e=>{const t=uL({inputs:{input:e},backend:n,attrs:{dim:a}});return i.push(t),t})),backend:n,attrs:{axis:a}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}},UB=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:o}=r;if(0===wa.sizeFromShape(a.shape)){return gL({backend:n,attrs:{shape:s.map(((e,t)=>e[0]+a.shape[t]+e[1])),value:o,dtype:a.dtype}})}const i=qe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=eO(r),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=vD("rc",r),l=vD("source",r),u=`${i[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${i[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${i[r-2]} += 1;\n       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${i[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let e=0,t=1===r?2:4;e<t;e++)p+=`\n        ${d[e]}\n        if (${h}) {\n          result[${e}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${e}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}(a.shape,s,o):new class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=eO(r),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}(a.shape,s,o),l=[[o]];return n.runWebGLProgram(i,[a],a.dtype,l)},VB={kernelName:tr,backendName:"webgl",kernelFunc:UB},jB=ZD({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),GB={kernelName:rr,backendName:"webgl",kernelFunc:jB};var HB={kernelName:sr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,l=[],u=wa.parseAxisParam(s,a.shape);let c=u;const d=ff.getAxesPermutation(c,i);let h,p=a;if(null!=d&&(p=pz({inputs:{x:a},backend:n,attrs:{perm:d}}),c=ff.getInnerMostAxes(c.length,i),l.push(p)),ff.assertAxesAreInnerMostDims("prod",c,i),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:a}=eD(p.shape,p.dtype,e,c);h=n.makeTensorInfo(r,a,t)}else{const[e,t]=ff.computeOutAndReduceShapes(p.shape,c),r=wa.sizeFromShape(t),s=sz({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),o=uz(s,ms(a.dtype),"prod",n);h=sz({inputs:{x:o},backend:n,attrs:{shape:e}}),l.push(s),l.push(o)}if(o){l.push(h);const e=ff.expandShapeToKeepDim(h.shape,u);h=sz({inputs:{x:h},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},qB=e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:o}=n,i=tD(r,a,s,o);return t.makeTensorInfo([i.length],o,i)},XB={kernelName:or,backendName:"webgl",kernelFunc:qB},KB=KD({opSnippet:"return 1.0 / x;"}),ZB={kernelName:lr,backendName:"webgl",kernelFunc:KB},YB=KD({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),JB={kernelName:ur,backendName:"webgl",kernelFunc:YB},QB=KD({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),eW={kernelName:mr,backendName:"webgl",kernelFunc:QB};var tW={kernelName:pr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,u]=i,c=qe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}(a.shape,l,u,s,o):new class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}(a.shape,l,u,s,o);return n.runWebGLProgram(c,[a],"float32")}};var nW={kernelName:fr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:o}=r,i=new class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,o]=e,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],u=i[0]/l[0],c=i[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};var rW={kernelName:dr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,u]=i,c=qe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}(a.shape,l,u,s,o):new class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,o,i,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?o-1:o,r&&n>1?i-1:i],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}(a.shape,l,u,s,o);return n.runWebGLProgram(c,[a],a.dtype)}};var aW={kernelName:hr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:o}=r,i=new class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,o]=e,i=[n&&s>1?r-1:r,n&&o>1?a-1:a],l=[n&&s>1?s-1:s,n&&o>1?o-1:o],u=i[0]/l[0],c=i[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}(s.shape,a.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};var sW={kernelName:Ar,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,o=a.shape.length,i=wa.parseAxisParam(s,a.shape);if(0===o)return LD({inputs:{x:a},backend:n});const l=qe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=vD("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=eO(n);var i;function l(n){const r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${i=r.slice(),l(i)};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",l(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}(a.shape,i):new class{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=eO(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}(a.shape,i);return n.runWebGLProgram(l,[a],a.dtype)}},oW={kernelName:sa,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:a,fillValue:s,center:o}=t,i=n,l=new class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}(r.shape,s),[u,c]=ff.getImageCenter(o,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(a),Math.cos(a)]];return i.runWebGLProgram(l,[r],r.dtype,d)}},iW=KD({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),lW={kernelName:gr,backendName:"webgl",kernelFunc:iW},uW=KD({opSnippet:"return inversesqrt(x);",cpuKernelImpl:nD}),cW={kernelName:yr,backendName:"webgl",kernelFunc:uW},dW=class{constructor(e,t,n,r,a,s,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=eO(a.length),l=eO(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`,p=t>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${p};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}};var hW={kernelName:xr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:o}=r,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ff.calculateShapes(s,a,o),h=[d/u,u];if(0===d)return n.makeTensorInfo(o,a.dtype);const p=sz({inputs:{x:a},backend:n,attrs:{shape:[l,i]}}),f=sz({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),A=new dW(l,i,p.shape.length,f.shape.length,c,h),g=n.runWebGLProgram(A,[f,p,m],f.dtype),y=sz({inputs:{x:g},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),y}};var pW={kernelName:br,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:o}=r,i=new class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===qe().getNumber("WEBGL_VERSION")?"while (left < right) {":a,o="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}(a.shape[0],a.shape[1],s.shape[1],o),l=[[a.shape[1]]];return n.runWebGLProgram(i,[a,s],"int32",l)}};var fW={kernelName:vr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,o=new class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let r=0;r<t.length;r++)o.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=o.join()}const s=eO(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(o,[r,a,s],fs(a.dtype,s.dtype))}},mW=KD({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${ff.SELU_SCALEALPHA};\n  float scale = ${ff.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),AW={kernelName:wr,backendName:"webgl",kernelFunc:mW},gW=KD({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:aD}),yW={kernelName:Er,backendName:"webgl",kernelFunc:gW},xW=KD({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),bW={kernelName:Cr,backendName:"webgl",kernelFunc:xW},vW=KD({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),wW={kernelName:Sr,backendName:"webgl",kernelFunc:vW},kW=KD({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),SW={kernelName:Ir,backendName:"webgl",kernelFunc:kW},IW=KD({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),CW={kernelName:Nr,backendName:"webgl",kernelFunc:IW},EW={kernelName:_r,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:o}=r;wa.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...o);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);const u=[],c=UB({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=ff.getReshaped(c.shape,s,i,!1),h=ff.getPermuted(d.length,s.length,!1),p=ff.getReshapedPermuted(c.shape,s,i,!1),f=sz({inputs:{x:c},backend:n,attrs:{shape:d}}),m=pz({inputs:{x:f},backend:n,attrs:{perm:h}}),A=sz({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),A}};var NW={kernelName:Fr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const i=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),c=n.readSync(o.dataId)[0],[d,h,p,f,m]=iD(i,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var TW={kernelName:Or,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.readSync(a.dataId)),i=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,d]=lD(i,r.shape,r.dtype,o,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var RW={kernelName:Dr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=uD(o,r.shape,r.dtype,i,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};var _W={kernelName:zr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const o=n.readSync(r.dataId),i=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=uD(o,r.shape,r.dtype,i,l);return n.makeTensorInfo(c,r.dtype,u)}};var MW={kernelName:Pr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ff.calculateShapes(s,a,i);if("string"===s.dtype){const e=n.bufferSync(a),t=n.bufferSync(s),r=wa.decodeString(n.readSync(o.dataId)[0]),p=rD(e,t,i,h,c,u,l,d,r,false);return n.makeTensorInfo(i,p.dtype,p.values)}const p=new dW(u,l,a.shape.length,s.shape.length,d,[h,1],false),f=n.runWebGLProgram(p,[s,a,o],s.dtype),m=sz({inputs:{x:f},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),m}};var $W={kernelName:Mr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:o}=r,i=wa.parseAxisParam(o,a.shape)[0],l=ff.prepareSplitSize(a,s,i),u=a.shape.length,c=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{const t=[...d];t[i]=e;const r=Qz({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[i]+=e,r}))}},FW="return sqrt(x);",OW=KD({opSnippet:FW,packedOpSnippet:FW,cpuKernelImpl:cD}),DW={kernelName:Tr,backendName:"webgl",kernelFunc:OW},zW=KD({opSnippet:"return x * x;"}),PW={kernelName:Br,backendName:"webgl",kernelFunc:zW},LW="return (a - b) * (a - b);",BW=ZD({opSnippet:LW,packedOpSnippet:LW}),WW={kernelName:Lr,backendName:"webgl",kernelFunc:BW};var UW={kernelName:ra,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,a=`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new CD(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}};var VW={kernelName:Wr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:o,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:A,isSimpleSlice:g,begin:y,end:x,strides:b}=Qi.sliceInfo(a.shape,s,o,i,l,u,c,d,h);let v;if(m)v=sz({inputs:{x:a},backend:n,attrs:{shape:f}});else if(A||g){wa.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=Qi.computeOutShape(y,x,b),t=Qz({inputs:{x:a},backend:n,attrs:{begin:y,size:e}});v=sz({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=Do(a.shape,a.dtype,e),r=dD(p,t,b,y);v=n.makeTensorInfo(f,a.dtype,r.values)}else{const e=new class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=eO(n.length),s=eO(n.length);let o="";if(1===r)o="coords * strides + begin";else{let e=0;o=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}(y,b,p);v=n.runWebGLProgram(e,[a],a.dtype)}}const w=sz({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(v),w}};var jW={kernelName:Ur,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=hD(h,p,a,s,o,i,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var GW={kernelName:Vr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=n.readSync(s.dataId),l=n.readSync(o.dataId)[0],[u,c,d]=pD(i,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var HW={kernelName:jr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),i=fD(o,a);return n.makeTensorInfo(s.shape,"int32",i)}},qW=KD({opSnippet:"return tan(x);"}),XW={kernelName:Hr,backendName:"webgl",kernelFunc:qW},KW=KD({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),ZW={kernelName:qr,backendName:"webgl",kernelFunc:KW};function YW(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>wa.decodeString(e))):e,r=Do(a.shape,a.dtype,t),o=AD(r,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new class{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=eO(this.rank),a=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}(a.shape,s);return n.runWebGLProgram(o,[a],a.dtype)}var JW={kernelName:Xr,backendName:"webgl",kernelFunc:YW},QW=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function eU(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function tU(e){let t=1;for(;t<e;)t*=2;return t}var nU={kernelName:Kr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:o}=r,i=qe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=qe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([a])||c<i||s>l){const e=n.readSync(a.dataId),[t,r]=gD(e,u,a.dtype,s,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[a,gL({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(a.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(a):a,f=wa.sizeFromShape(u)/c,m=sz({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&eU(n,p);const A=tU(s),g=tU(c);let y=null;const x=()=>null===y?[m,m]:[m,y],b=(e,t,r)=>{const a=x(),s=new class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}(r),o=[[c],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=y;y=n.runWebGLProgram(s,a,"int32",o),eU(n,i)};for(let e=1;e<A;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)b(t,n,[f,g])}for(let e=g;e>A;e/=2){const t=x(),r=new QW([f,e/2]),a=[[c],[null===y?1:0],[A]],s=y;y=n.runWebGLProgram(r,t,"int32",a),eU(n,s);const o=A/2,i=2*o;for(let e=o;e>=1;e/=2)b(i,e,y.shape)}let v=y;y=Qz({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,s]}}),eU(n,v);let w=RL({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});eU(n,m);const k=u.slice(0,-1);k.push(s),v=y,y=sz({inputs:{x:y},attrs:{shape:k},backend:n}),eU(n,v);const S=w;return w=sz({inputs:{x:w},attrs:{shape:k},backend:n}),eU(n,S),[w,y]}};var rU={kernelName:Zr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:l,outputShape:u}=r,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],A=[c,f,m,p],g=new class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let i;switch(r){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}(d,h,o,i,l,A);return n.runWebGLProgram(g,[a,s],"float32")}};var aU={kernelName:Jr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;OF(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:i,outputShape:l,indices:u}=xD(o,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,i),r.makeTensorInfo([u.length],"int32",u)]}};var sU={kernelName:Qr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a,i=o.shape.length,l=a.shape[s],u=new Array(i-1);let c=0;for(let e=0;e<i;e++)e!==s&&(u[c++]=o.shape[e]);const d=[],h=new Array(i).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(l);for(let e=0;e<f.length;e++){h[s]=e;const t=Qz({inputs:{x:o},backend:n,attrs:{begin:h,size:p}}),r=sz({inputs:{x:t},backend:n,attrs:{shape:u}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};var oU,iU,lU,uU,cU,dU=[Az,yz,bz,wz,Iz,Cz,Ez,Nz,Mz,$z,Oz,zz,Lz,Wz,Vz,Hz,qz,Xz,Kz,Zz,Yz,tP,nP,rP,lP,dP,hP,UD,fP,bP,IP,CP,EP,NP,TP,MP,FP,DP,zP,UP,VP,jP,GP,XP,KP,ZP,YP,JP,QP,tL,nL,aL,oL,lL,cL,pL,AL,xL,bL,kL,IL,CL,EL,NL,TL,_L,$L,OL,BD,DL,gP,PL,BL,UL,GD,jL,HL,qL,KL,YL,QL,tB,rB,aB,sB,iB,uB,cB,dB,hB,pB,fB,mB,AB,yB,xB,vB,TB,az,RB,MB,FB,DB,sP,zB,BB,WB,VB,GB,XD,HB,XB,iP,kB,ZB,JB,eW,oz,tW,nW,rW,aW,sW,oW,lW,cW,hW,pW,fW,AW,yW,bW,wW,SW,eP,NB,CW,EW,NW,TW,RW,_W,MW,$W,DW,PW,WW,UW,VW,jW,GW,HW,CB,hz,XW,ZW,JW,nU,rU,fz,aU,sU,{kernelName:ea,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:o}=r,i=a.shape.length,l=[];let u=0;const c=ff.getAxesPermutation([u],i);let d=a;null!=c&&(d=pz({inputs:{x:a},backend:n,attrs:{perm:c}}),l.push(d),u=ff.getInnerMostAxes(1,i)[0]);const h=ff.segment_util.computeOutShape(d.shape,u,o),p=wa.sizeFromShape([d.shape[u]]),f=sz({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=ms(a.dtype),A=(e,t,r,a,s)=>{const o=e.shape[0],i=e.shape[1],u=ff.segment_util.segOpComputeOptimalWindowSize(i,s),c={windowSize:u,inSize:i,batchSize:o,numSegments:s},d=new class{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,o=s*Math.ceil(a/n);this.outputShape=[r,o];const i=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}(c,t),h=n.compileAndRun(d,[e,r],a);if(l.push(h),h.shape[1]===s)return h;const p=qB({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),f=YW({inputs:{x:p},backend:n,attrs:{reps:[i/u]}});l.push(p),l.push(f);return A(h,t,f,a,s)},g=sz({inputs:{x:A(f,"unsortedSegmentSum",s,m,o)},backend:n,attrs:{shape:h}});let y=g;if(null!=c){l.push(g);const e=ff.getUndoAxesPermutation(c);y=pz({inputs:{x:y},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},LB];for(const e of dU)Aa(e);(iU=oU||(oU={}))[iU.float32=0]="float32",iU[iU.int32=1]="int32",iU[iU.bool=2]="bool",iU[iU.string=3]="string",iU[iU.complex64=4]="complex64",(uU=lU||(lU={}))[uU.linear=0]="linear",uU[uU.relu=1]="relu",uU[uU.relu6=2]="relu6",uU[uU.prelu=3]="prelu",uU[uU.leakyrelu=4]="leakyrelu",uU[uU.sigmoid=5]="sigmoid",uU[uU.elu=6]="elu";var hU={kernelName:oa,backendName:"wasm",setupFunc:function(e){cU=e.wasm.cwrap(oa,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:o,preluActivationWeights:i}=t;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,h=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id;let f=0;if(null!=o){const e=n.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}const m=null==i?0:n.dataIdMap.get(i.dataId).id,A=lU[c];if(null==A)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);const g=l?a.shape[2]:a.shape[1],y=u?s.shape[1]:s.shape[2],x=Oi.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),b=n.makeOutput([...x,g,y],a.dtype),v=n.dataIdMap.get(b.dataId).id,w=new Uint8Array(new Int32Array(a.shape).buffer),k=new Uint8Array(new Int32Array(s.shape).buffer);return cU(h,w,a.shape.length,p,k,s.shape.length,l,u,A,f,m,d||0,v),b}};function pU(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){const{backend:r,inputs:{x:a}}=e,s=r.dataIdMap.get(a.dataId).id,o=r.makeOutput(a.shape,t||a.dtype),i=r.dataIdMap.get(o.dataId).id;return 0===wa.sizeFromShape(o.shape)||n(s,oU[a.dtype],i),o}}}var fU=pU(Je);function mU(e,t,n){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:a}=e,{a:s,b:o}=a,i=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(o.dataId).id,u=null!=n?n:s.dtype,c=ff.assertAndGetBroadcastShape(s.shape,o.shape),d=t.makeOutput(c,u);if(0===wa.sizeFromShape(c))return d;const h=new Uint8Array(new Int32Array(s.shape).buffer),p=new Uint8Array(new Int32Array(o.shape).buffer),f=t.dataIdMap.get(d.dataId).id;return r(i,h,s.shape.length,l,p,o.shape.length,oU[s.dtype],f),d}}}var AU,gU=mU(tt);var yU={kernelName:nt,backendName:"wasm",setupFunc:function(e){AU=e.wasm.cwrap(nt,null,["array","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===wa.sizeFromShape(r.shape))return r;const a=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(a).buffer),o=n.dataIdMap.get(r.dataId).id;return AU(s,a.length,oU[r.dtype],o),r}};function xU(e){const{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var bU,vU={kernelName:pn,backendName:"wasm",kernelFunc:xU};function wU(e){const{inputs:t,backend:n,attrs:r}=e,[a,s]=function(e,t){const n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let e=0;e<r.length;++e){let t=-1;for(let n=0;n<r.length;++n)r[n]>=e&&(-1===t||r[t]>r[n])&&(t=n);r[t]=e}return[n,r]}(t.x.shape,r.perm);let o=!0;for(let e=0;e<s.length;e++)s[e]!==e&&(o=!1);const i=function(e,t){const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(o){const e=xU({inputs:t,backend:n});return e.shape=i,e}const u=n.makeOutput(i,l.dtype),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,h=new Uint8Array(new Int32Array(s).buffer),p=new Uint8Array(new Int32Array(l.shape).buffer);return bU(c,p,l.shape.length,oU[l.dtype],d,h,s.length),u}var kU,SU={kernelName:Yr,backendName:"wasm",kernelFunc:wU,setupFunc:function(e){bU=e.wasm.cwrap(Yr,null,["number","array","number","number","number","array","number"])}};function IU(e,t,n){const r=e.shape,a=e.shape.length,s=wa.parseAxisParam(t,r);let o=s;const i=ff.getAxesPermutation(o,a);let l=null,u=!1;if(null!=i){const t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[i[e]];o=ff.getInnerMostAxes(o.length,a),l=wU({inputs:{x:e},attrs:{perm:i},backend:n});const s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==s&&(u=!0)}return{transposed:l,originalAxes:s,axes:o,inputWasTransposed:u}}var CU,EU={kernelName:rt,backendName:"wasm",setupFunc:function(e){kU=e.wasm.cwrap(rt,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n;let i=t.dataIdMap.get(o.dataId).id,l=o;const{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=IU(o,a,t);if(h){l=u,i=t.dataIdMap.get(u.dataId).id}const p=l.shape.length;ff.assertAxesAreInnerMostDims("all",c,p);const[f,m]=ff.computeOutAndReduceShapes(l.shape,c),A=wa.sizeFromShape(m),g=t.makeOutput(f,o.dtype);if(0!==wa.sizeFromShape(l.shape)){const e=t.dataIdMap.get(g.dataId).id;kU(i,A,e)}if(h&&t.disposeData(u.dataId),s){const e=ff.expandShapeToKeepDim(g.shape,d);g.shape=e}return g}};var NU,TU={kernelName:at,backendName:"wasm",setupFunc:function(e){CU=e.wasm.cwrap(at,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n;let i=t.dataIdMap.get(o.dataId).id,l=o;const{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=IU(o,a,t);if(h){l=u,i=t.dataIdMap.get(u.dataId).id}const p=l.shape.length;ff.assertAxesAreInnerMostDims("any",c,p);const[f,m]=ff.computeOutAndReduceShapes(l.shape,c),A=wa.sizeFromShape(m),g=t.makeOutput(f,o.dtype);if(0!==wa.sizeFromShape(l.shape)){const e=t.dataIdMap.get(g.dataId).id;CU(i,A,e)}if(h&&t.disposeData(u.dataId),s){const e=ff.expandShapeToKeepDim(g.shape,d);g.shape=e}return g}};var RU,_U={kernelName:st,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id;let i=o,l=s;const{transposed:u,axes:c,inputWasTransposed:d}=IU(s,a,t);if(d){const e=t.dataIdMap.get(u.dataId).id;e!==o&&(l=u,i=e)}const h=l.shape.slice(0,-1),p=t.makeOutput(h,"int32"),f=t.dataIdMap.get(p.dataId).id,m=wa.sizeFromShape(p.shape),A=l.shape[c[0]];return NU(i,oU[l.dtype],m,A,f),d&&t.disposeData(u.dataId),p},setupFunc:function(e){NU=e.wasm.cwrap(st,null,["number","number","number","number","number"])}};var MU={kernelName:ht,backendName:"wasm",setupFunc:function(e){RU=e.wasm.cwrap(ht,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=n,c=ff.computePool2DInfo(a.shape,o,i,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,A=c.padInfo.left,g=c.strideHeight,y=c.strideWidth,x=c.inChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(1!==c.dilationWidth||1!==c.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);const b=r.makeOutput(c.outShape,"float32"),v=r.dataIdMap.get(b.dataId).id;return RU(s,a.shape[0],a.shape[1],a.shape[2],d,h,p,f,m,A,g,y,x,v),b}};function $U(e){const{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=wa.sizeFromShape(r.shape),o=wa.inferFromImplicitShape(a,s);return wa.assert(s===wa.sizeFromShape(o),(()=>`new shape: ${o}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}var FU,OU={kernelName:cr,backendName:"wasm",kernelFunc:$U};var DU={kernelName:At,backendName:"wasm",setupFunc:function(e){FU=e.wasm.cwrap(At,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:o,transposeB:i}=r;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const l=a.shape.length,u=s.shape.length,c=o?a.shape[l-2]:a.shape[l-1],d=i?s.shape[u-1]:s.shape[u-2],h=o?a.shape[l-1]:a.shape[l-2],p=i?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),A=wa.sizeFromShape(f),g=wa.sizeFromShape(m),y=Oi.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);wa.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${o} and transposeB=${i} must match.`));const x=i?[g,p,d]:[g,d,p],b=$U({inputs:{x:a},backend:n,attrs:{shape:o?[A,c,h]:[A,h,c]}}),v=$U({inputs:{x:s},backend:n,attrs:{shape:x}}),w=n.dataIdMap.get(b.dataId).id,k=n.dataIdMap.get(v.dataId).id,S=o?b.shape[2]:b.shape[1],I=i?v.shape[1]:v.shape[2],C=Math.max(A,g),E=n.makeOutput([C,S,I],b.dtype),N=n.dataIdMap.get(E.dataId).id,T=new Uint8Array(new Int32Array(b.shape).buffer),R=new Uint8Array(new Int32Array(v.shape).buffer);return FU(w,T,b.shape.length,k,R,v.shape.length,o,i,N),n.disposeData(b.dataId),n.disposeData(v.dataId),E.shape=y,E}};function zU(e){const{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,o]=Qi.parseSliceParams(t,n,r),i=Qi.isSliceContinous(t.shape,s,o),l=a.readSync(t.dataId),u=a.makeOutput(o,t.dtype),c=wa.computeStrides(t.shape),d=a.dataIdMap.get(u.dataId);if(i){const e=Qi.computeFlatOffset(s,c);if("string"===t.dtype)d.stringBytes=l.slice(e,e+wa.sizeFromShape(o));else{a.typedArrayFromHeap(u).set(l.subarray(e,e+wa.sizeFromShape(o)))}return u}if("string"===t.dtype){const e=tT(l,s,o,t.shape,t.dtype);return d.stringBytes=e,u}const h=a.typedArrayFromHeap(u),p=t.shape.length;if(2===p)!function(e,t,n,r,a){let s=0;const o=r[0],i=r[1],l=o+a[0];for(let r=o;r<l;r++){const o=r*t+i;n.set(e.subarray(o,o+a[1]),s),s+=a[1]}}(l,c[0],h,s,o);else if(3===p)!function(e,t,n,r,a,s){let o=0;const i=a[0],l=a[1],u=a[2],c=i+s[0],d=l+s[1];for(let a=i;a<c;a++)for(let i=l;i<d;i++){const l=a*t+i*n+u;r.set(e.subarray(l,l+s[2]),o),o+=s[2]}}(l,c[0],c[1],h,s,o);else if(4===p)!function(e,t,n,r,a,s,o){let i=0;const l=s[0],u=s[1],c=s[2],d=l+o[0],h=u+o[1],p=c+o[2],f=s[3];for(let s=l;s<d;s++)for(let l=u;l<h;l++)for(let u=c;u<p;u++){const c=s*t+l*n+u*r+f;a.set(e.subarray(c,c+o[3]),i),i+=o[3]}}(l,c[0],c[1],c[2],h,s,o);else{const e=tT(l,s,o,t.shape,t.dtype);h.set(e)}return u}var PU={kernelName:kr,backendName:"wasm",kernelFunc:zU};var LU={kernelName:gt,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:o}=r,i=s.reduce(((e,t)=>e*t)),l=ff.getReshaped(a.shape,s,i),u=ff.getPermuted(l.length,s.length),c=ff.getReshapedPermuted(a.shape,s,i),d=ff.getSliceBeginCoords(o,s.length),h=ff.getSliceSize(c,o,s.length),p=$U({inputs:{x:a},backend:n,attrs:{shape:l}}),f=wU({inputs:{x:p},backend:n,attrs:{perm:u}}),m=zU({inputs:{x:$U({inputs:{x:f},backend:n,attrs:{shape:c}})},backend:n,attrs:{begin:d,size:h}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(p.dataId),m}};function BU(e){const{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var WU,UU={kernelName:vt,backendName:"wasm",kernelFunc:BU},VU=pU(wt);var jU={kernelName:kt,backendName:"wasm",setupFunc:function(e){WU=e.wasm.cwrap(kt,null,["number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:o}=r,i=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return WU(i,s,o,u),l}};function GU(e){const{inputs:t,backend:n}=e,r=wa.parseAxisParam(e.attrs.axis,t[0].shape)[0];let a=ff.computeOutShape(t.map((e=>e.shape)),r);const s=t.filter((e=>wa.sizeFromShape(e.shape)>0));if(1===s.length)return xU({inputs:{x:s[0]},backend:n});const o=n.makeOutput(a,t[0].dtype);if(0===wa.sizeFromShape(a))return o;const i=s.map((e=>e.shape));if(ff.assertParamsConsistent(i,r),"string"===s[0].dtype){const e=s.map((e=>{const t=wa.sizeFromShape(e.shape.slice(r));return $U({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),i=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));a=ff.computeOutShape(e.map((e=>e.shape)),1);const l=1===e[0].shape[0],u=KE(i,a,t[0].dtype,l),c=ff.computeOutShape(s.map((e=>e.shape)),r);o.shape=c;return n.dataIdMap.get(o.dataId).stringBytes=ff.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),o}const l=wa.sizeFromShape(s[0].shape.slice(0,r));let u=0;const c=s.map((e=>{const t=wa.sizeFromShape(e.shape.slice(r));return u+=t,t})),d=s.map((e=>n.typedArrayFromHeap(e))),h=n.typedArrayFromHeap(o);for(let e=0;e<l;e++){let t=e*u;for(let n=0;n<d.length;n++){const r=c[n],a=e*r,s=d[n].subarray(a,a+r);h.set(s,t),t+=r}}return o}var HU,qU={kernelName:Ct,backendName:"wasm",kernelFunc:GU};var XU,KU={kernelName:Et,backendName:"wasm",setupFunc:function(e){HU=e.wasm.cwrap(Et,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,o=r.dataIdMap.get(a.dataId).id,i=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d,dataFormat:h}=n,p=ff.convertConv2DDataFormat(h),f=ff.computeConv2DInfo(a.shape,s.shape,l,u,c,d,!1,p),m=f.filterHeight,A=f.filterWidth,g=f.padInfo.top,y=f.padInfo.right,x=f.padInfo.bottom,b=f.padInfo.left,v=f.dilationHeight,w=f.dilationWidth,k=f.strideHeight,S=f.strideWidth,I=f.inChannels,C=f.outChannels,E="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);const N=r.makeOutput(f.outShape,"float32"),T=r.dataIdMap.get(N.dataId).id;return HU(o,a.shape[0],a.shape[1],a.shape[2],i,m,A,g,y,x,b,E,v,w,k,S,I,C,T),N}};var ZU,YU,JU,QU={kernelName:Tt,backendName:"wasm",setupFunc:function(e){XU=e.wasm.cwrap(Tt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:o,pad:i,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,d=ff.convertConv2DDataFormat(l),h=ff.computeConv2DInfo(c,s.shape,o,1,i,u,!1,d),{batchSize:p,filterHeight:f,filterWidth:m,inChannels:A,inHeight:g,inWidth:y,outChannels:x,outHeight:b,outWidth:v,strideHeight:w,strideWidth:k}=h,S=f-1-h.padInfo.top,I=m-1-h.padInfo.left,C="channelsLast"===h.dataFormat,E=wa.computeStrides(h.inShape),N=wa.computeStrides(a.shape),[T,R,_]=wa.computeStrides(s.shape),M=E[0],$=C?E[1]:E[2],F=C?E[2]:1,O=C?1:E[1],D=N[0],z=C?N[1]:N[2],P=C?N[2]:1,L=C?1:N[1],B=t.makeOutput(h.inShape,"float32"),W=t.dataIdMap.get(B.dataId).id,U=t.dataIdMap.get(a.dataId).id,V=t.dataIdMap.get(s.dataId).id;return XU(U,V,p,f,m,g,y,A,b,v,x,w,k,S,I,T,R,_,M,$,F,O,D,z,P,L,W),B}},eV=pU($t),tV=pU(Ft);(YU=ZU||(ZU={}))[YU.bilinear=0]="bilinear",YU[YU.nearest=1]="nearest";var nV,rV={kernelName:zt,backendName:"wasm",setupFunc:function(e){JU=e.wasm.cwrap(zt,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{method:a,extrapolationValue:s,cropSize:o}=r,{image:i,boxes:l,boxInd:u}=n,c=l.shape[0],[d,h]=o,p=[c,d,h,i.shape[3]];let f,m=t.dataIdMap.get(i.dataId);"float32"!==i.dtype&&(f=BU({backend:t,inputs:{x:i},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(f.dataId));const A=m.id,g=t.dataIdMap.get(l.dataId).id,y=t.dataIdMap.get(u.dataId).id,x=t.makeOutput(p,"float32"),b=t.dataIdMap.get(x.dataId).id,v=new Uint8Array(new Int32Array(i.shape).buffer);return JU(A,g,y,c,v,d,h,ZU[a],s,b),null!=f&&t.disposeData(f.dataId),x}};var aV,sV={kernelName:Ot,backendName:"wasm",setupFunc:function(e){nV=e.wasm.cwrap(Ot,null,["number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r,l=a.shape.length;wa.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));const u=ff.getAxesPermutation([s],l);let c=a;null!==u&&(c=wU({inputs:{x:a},attrs:{perm:u},backend:n}));const d=ff.getInnerMostAxes(1,l)[0];ff.assertAxesAreInnerMostDims("cumprod",[d],l);const h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;nV(f,o?1:0,i?1:0,p,m,oU[a.dtype]);let A=h;if(null!==u){A=wU({inputs:{x:h},attrs:{perm:ff.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return A}};var oV,iV={kernelName:Dt,backendName:"wasm",setupFunc:function(e){aV=e.wasm.cwrap(Dt,null,["number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r,l=a.shape.length;wa.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));const u=ff.getAxesPermutation([s],l);let c=a;null!==u&&(c=wU({inputs:{x:a},attrs:{perm:u},backend:n}));const d=ff.getInnerMostAxes(1,l)[0];ff.assertAxesAreInnerMostDims("cumsum",[d],l);const h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;aV(f,o?1:0,i?1:0,p,m,oU[a.dtype]);let A=h;if(null!==u){A=wU({inputs:{x:h},attrs:{perm:ff.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return A}};var lV,uV={kernelName:Lt,backendName:"wasm",setupFunc:function(e){oV=e.wasm.cwrap(Lt,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:o}=r,i=a.shape[0],l=("NHWC"===o?a.shape[1]:a.shape[2])*s,u=("NHWC"===o?a.shape[2]:a.shape[3])*s,c=("NHWC"===o?a.shape[3]:a.shape[1])/(s*s),d="NHWC"===o?[i,l,u,c]:[i,c,l,u],h=t.makeOutput(d,"float32"),p=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(wa.computeStrides(a.shape)).buffer),m=new Uint8Array(new Int32Array(d).buffer),A=new Uint8Array(new Int32Array(wa.computeStrides(d)).buffer),g=t.dataIdMap.get(h.dataId).id;return oV(p,s,"NHWC"===o?1:0,f,a.shape.length-1,m,A,d.length,g),h}};var cV={kernelName:Bt,backendName:"wasm",setupFunc:function(e){lV=e.wasm.cwrap(Bt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,o=r.dataIdMap.get(a.dataId).id,i=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d}=n,h=null==u?[1,1]:u,p=ff.computeConv2DInfo(a.shape,s.shape,l,h,c,d,!0),f=p.filterHeight,m=p.filterWidth,A=p.padInfo.top,g=p.padInfo.right,y=p.padInfo.bottom,x=p.padInfo.left,b=p.dilationHeight,v=p.dilationWidth,w=p.strideHeight,k=p.strideWidth,S=p.inChannels,I=p.outChannels,C="SAME"===p.padInfo.type?1:0;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);const E=r.makeOutput(p.outShape,"float32"),N=r.dataIdMap.get(E.dataId).id;return lV(o,a.shape[0],a.shape[1],a.shape[2],i,f,m,A,g,y,x,C,b,v,w,k,S,I,N),E}},dV=pU(Kt),hV=mU(Jt,0,"bool"),pV=pU(Qt,"float32");function fV(e){const{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,o=a.shape.length,i=a.shape.slice();let l=s;return s<0&&(wa.assert(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+s+1),i.splice(l,0,1),$U({inputs:{x:a},backend:r,attrs:{shape:i}})}var mV={kernelName:en,backendName:"wasm",kernelFunc:fV};function AV(e){const{attrs:{shape:t,value:n,dtype:r},backend:a}=e,s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}var gV,yV={kernelName:rn,backendName:"wasm",kernelFunc:AV};var xV,bV={kernelName:an,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,[i,l,u,c]=r.shape;return gV(s,i,l,u,c,o),a},setupFunc:function(e){gV=e.wasm.cwrap(an,null,["number","number","number","number","number","number"])}},vV=pU(sn),wV=mU(on);var kV,SV={kernelName:ln,backendName:"wasm",setupFunc:function(e){xV=e.wasm.cwrap(ln,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:o,variance:i,offset:l,scale:u}=n,c=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(o.dataId).id,h=t.dataIdMap.get(i.dataId).id,p=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(0===wa.sizeFromShape(s.shape))return m;const A=t.dataIdMap.get(m.dataId).id;return xV(c,d,h,p,f,a,A),m}};var IV,CV={kernelName:ia,backendName:"wasm",setupFunc:function(e){kV=e.wasm.cwrap(ia,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=ff.computeConv2DInfo(a.shape,s.shape,l,c,u,h),A=lU[p];if(null==A)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);const g=r.dataIdMap.get(a.dataId).id,y=r.dataIdMap.get(s.dataId).id,x=m.outChannels;let b=0;if(null!=o){const e=r.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${x})`);b=e.id}const v=m.filterHeight,w=m.filterWidth,k=m.padInfo.top,S=m.padInfo.right,I=m.padInfo.bottom,C=m.padInfo.left,E=m.dilationHeight,N=m.dilationWidth,T=m.strideHeight,R=m.strideWidth,_=m.inChannels,M="SAME"===m.padInfo.type?1:0,$=m.batchSize,F=m.inHeight,O=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const D=r.makeOutput(m.outShape,"float32"),z=r.dataIdMap.get(D.dataId).id,P=null==i?0:r.dataIdMap.get(i.dataId).id;return kV(g,$,F,O,y,v,w,b,k,S,I,C,M,E,N,T,R,_,x,A,P,f||0,z),D}};var EV,NV={kernelName:la,backendName:"wasm",setupFunc:function(e){IV=e.wasm.cwrap(la,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=ff.computeConv2DInfo(a.shape,s.shape,l,c,u,h,!0),A=lU[p];if(null==A)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const g=r.dataIdMap.get(a.dataId).id,y=r.dataIdMap.get(s.dataId).id,x=m.outChannels;let b=0;if(null!=o){const e=r.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${x})`);b=e.id}const v=m.filterHeight,w=m.filterWidth,k=m.padInfo.top,S=m.padInfo.right,I=m.padInfo.bottom,C=m.padInfo.left,E=m.dilationHeight,N=m.dilationWidth,T=m.strideHeight,R=m.strideWidth,_=m.inChannels,M="SAME"===m.padInfo.type?1:0,$=m.batchSize,F=m.inHeight,O=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const D=r.makeOutput(m.outShape,"float32"),z=r.dataIdMap.get(D.dataId).id,P=null==i?0:r.dataIdMap.get(i.dataId).id;return IV(g,$,F,O,y,v,w,b,k,S,I,C,M,E,N,T,R,_,x,A,P,f||0,z),D}};var TV,RV={kernelName:cn,backendName:"wasm",setupFunc:function(e){EV=e.wasm.cwrap(cn,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){const{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,o,i,l]=qi.prepareAndValidate(r,a),u=t.makeOutput(s,r.dtype);if(0===o)return u;const c=a.shape,d=c[c.length-1],h=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return EV(h,oU[r.dtype],p,o,d,i,f,m),u}};var _V,MV={kernelName:un,backendName:"wasm",setupFunc:function(e){TV=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:o,batchDims:i}=r,l=wa.parseAxisParam(o,a.shape)[0],u=t.readSync(s.dataId),c=a.shape[l];for(let e=0;e<u.length;++e){const t=u[e];wa.assert(t<=c-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${c-1}]`))}const d=ff.segment_util.collectGatherOpShapeInfo(a,s,l,i),h=$U({inputs:{x:a},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),p=wa.sizeFromShape(s.shape),f=$U({inputs:{x:s},attrs:{shape:[d.batchSize,p/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],A=t.makeOutput(m,a.dtype);if(0===wa.sizeFromShape(a.shape))return A;const g=h.shape.length-1,y=t.dataIdMap.get(h.dataId).id,x=t.dataIdMap.get(f.dataId).id,b=t.dataIdMap.get(A.dataId).id,v=new Uint8Array(new Int32Array(wa.computeStrides(h.shape)).buffer),w=new Uint8Array(new Int32Array(wa.computeStrides(m)).buffer);return TV(y,oU[a.dtype],v,g,x,d.batchSize,w,b),t.disposeData(h.dataId),t.disposeData(f.dataId),A.shape=d.outputShape,A}},$V=mU(dn,0,"bool"),FV=mU(hn,0,"bool");var OV,DV={kernelName:xn,backendName:"wasm",setupFunc:function(e){_V=e.wasm.cwrap(xn,null,["number","number","number","number"])},kernelFunc:function(e){const{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(0!==wa.sizeFromShape(t.shape)){const e=r.dataIdMap.get(s.dataId).id;_V(a,oU[t.dtype],n,e)}return s}},zV=mU(bn,0,"bool"),PV=mU(vn,0,"bool"),LV=pU(kn),BV=mU(In,0,"bool"),WV=pU(Cn),UV=mU(En,0,"bool"),VV=mU(Nn,0,"bool");var jV,GV={kernelName:$n,backendName:"wasm",setupFunc:function(e){OV=e.wasm.cwrap($n,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:o}=n;let i=t.dataIdMap.get(o.dataId).id,l=o;const{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=IU(o,a,t);if(h){l=u,i=t.dataIdMap.get(u.dataId).id}const p=l.shape.length;ff.assertAxesAreInnerMostDims("max",c,p);const[f,m]=ff.computeOutAndReduceShapes(l.shape,c),A=wa.sizeFromShape(m),g=t.makeOutput(f,o.dtype);if(0!==wa.sizeFromShape(l.shape)){const e=t.dataIdMap.get(g.dataId).id;OV(i,oU[o.dtype],A,e)}if(h&&t.disposeData(u.dataId),s){const e=ff.expandShapeToKeepDim(g.shape,d);g.shape=e}return g}},HV=mU(Fn);var qV,XV={kernelName:On,backendName:"wasm",setupFunc:function(e){jV=e.wasm.cwrap(On,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;wa.assert("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));const{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=n,c=ff.computePool2DInfo(a.shape,o,i,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,A=c.padInfo.left,g=c.dilationHeight,y=c.dilationWidth,x=c.strideHeight,b=c.strideWidth,v=c.inChannels,w=c.outChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);const k=r.makeOutput(c.outShape,"float32"),S=r.dataIdMap.get(k.dataId).id;return jV(s,a.shape[0],a.shape[1],a.shape[2],d,h,p,f,m,A,g,y,x,b,v,w,S),k}};var KV,ZV={kernelName:Bn,backendName:"wasm",setupFunc:function(e){qV=e.wasm.cwrap(Bn,null,["number, number, number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let l=i,u=o;const{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=IU(o,a,t);let f=d;if(p){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(u=c,l=e,f=ff.getInnerMostAxes(f.length,u.shape.length))}ff.assertAxesAreInnerMostDims("mean",f,u.shape.length);const[m,A]=ff.computeOutAndReduceShapes(u.shape,f),g=wa.sizeFromShape(A);let y=u;"float32"!==u.dtype&&(y=BU({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(y.dataId).id);const x=t.makeOutput(m,"float32");if(0!==wa.sizeFromShape(u.shape)){const e=t.dataIdMap.get(x.dataId).id;qV(l,g,e)}if(p&&t.disposeData(c.dataId),s){const e=ff.expandShapeToKeepDim(x.shape,h);x.shape=e}return"float32"!==u.dtype&&t.disposeData(y.dataId),x}};var YV,JV,QV,ej={kernelName:Wn,backendName:"wasm",setupFunc:function(e){KV=e.wasm.cwrap(Wn,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let l=i,u=o;const{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=IU(o,a,t);if(p){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(u=c,l=e)}const f=u.shape.length;ff.assertAxesAreInnerMostDims("min",d,f);const[m,A]=ff.computeOutAndReduceShapes(u.shape,d),g=wa.sizeFromShape(A),y=t.makeOutput(m,u.dtype);if(0!==wa.sizeFromShape(u.shape)){const e=t.dataIdMap.get(y.dataId).id;KV(l,oU[o.dtype],g,e)}if(p&&t.disposeData(c.dataId),s){const e=ff.expandShapeToKeepDim(y.shape,h);y.shape=e}return y}},tj=mU(Un);(JV=YV||(YV={}))[JV.reflect=0]="reflect",JV[JV.symmetric=1]="symmetric";var nj,rj={kernelName:Vn,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),o=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(i.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),d=r.map((e=>e[1])),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return QV(o,u,t.shape.length,oU[t.dtype],h,p,YV[a],l),i},setupFunc:function(e){QV=e.wasm.cwrap(Vn,null,["number","array","number","number","array","array","number","number"])}},aj=mU(Hn),sj=pU(qn);function oj(e,t){const n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],o=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:o}}var ij,lj={kernelName:Kn,backendName:"wasm",setupFunc:function(e){nj=e.wasm.cwrap(Kn,"number",["number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:o}=r,{boxes:i,scores:l}=n,u=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(l.dataId).id,d=nj(u,c,s,a,o),{pSelectedIndices:h,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=oj(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",h)}};var uj,cj={kernelName:Zn,backendName:"wasm",setupFunc:function(e){ij=e.wasm.cwrap(Zn,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:o,padToMaxOutputSize:i}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=ij(c,d,s,a,o,i),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:A}=oj(t,h);return t.wasm._free(m),[t.makeOutput([f],"int32",p),t.makeOutput([],"int32",A)]}};var dj,hj={kernelName:Yn,backendName:"wasm",setupFunc:function(e){uj=e.wasm.cwrap(Yn,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:o,softNmsSigma:i}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=uj(c,d,s,a,o,i),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:A}=oj(t,h);return t.wasm._free(A),[t.makeOutput([f],"int32",p),t.makeOutput([f],"float32",m)]}},pj=mU(Xn,0,"bool");var fj={kernelName:Qn,backendName:"wasm",setupFunc:function(e){dj=e.wasm.cwrap(Qn,null,["number","number","number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{depth:s,onValue:o,offValue:i}=r,l=n.makeOutput([...a.shape,s],"int32"),u=n.dataIdMap.get(l.dataId).id,c=n.dataIdMap.get(a.dataId).id;return dj(c,s,o,i,u),l}};var mj={kernelName:Jn,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}};var Aj,gj={kernelName:er,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return fV({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{wa.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),wa.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=GU({inputs:t.map((e=>{const t=fV({inputs:{input:e},backend:n,attrs:{dim:a}});return i.push(t),t})),backend:n,attrs:{axis:a}});return i.forEach((e=>n.disposeData(e.dataId))),l}};var yj,xj={kernelName:tr,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===wa.sizeFromShape(t.shape))return AV({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});const o=n.dataIdMap.get(t.dataId).id,i=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(i.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),d=r.map((e=>e[1])),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return Aj(o,u,t.shape.length,oU[t.dtype],h,p,a,l),i},setupFunc:function(e){Aj=e.wasm.cwrap(tr,null,["number","array","number","number","array","array","number","number"])}},bj=mU(rr);var vj,wj={kernelName:ar,backendName:"wasm",setupFunc:function(e){yj=e.wasm.cwrap(ar,null,["number","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id;let i=s;const l=r;let u=l;"float32"!==l.dtype&&(u=BU({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),i=n.dataIdMap.get(u.dataId).id);const c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return yj(i,o,d),"float32"!==l.dtype&&n.disposeData(u.dataId),c}};var kj,Sj={kernelName:sr,backendName:"wasm",setupFunc:function(e){vj=e.wasm.cwrap(sr,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let l=i,u=o;const{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=IU(o,a,t);let f=d;if(p){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(u=c,l=e,f=ff.getInnerMostAxes(f.length,u.shape.length))}ff.assertAxesAreInnerMostDims("prod",f,u.shape.length);const[m,A]=ff.computeOutAndReduceShapes(u.shape,f),g=wa.sizeFromShape(A),y=t.makeOutput(m,u.dtype);if(0!==wa.sizeFromShape(u.shape)){const e=t.dataIdMap.get(y.dataId).id;vj(l,g,oU[y.dtype],e)}if(p&&t.disposeData(c.dataId),s){const e=ff.expandShapeToKeepDim(y.shape,h);y.shape=e}return y}},Ij={kernelName:or,backendName:"wasm",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:o}=n,i=qN(r,a,s,o),l=t.makeOutput([i.length],o);return t.typedArrayFromHeap(l).set(i),l}},Cj=mU(qt),Ej=pU(ur),Nj=pU(mr);var Tj,Rj={kernelName:pr,backendName:"wasm",setupFunc:function(e){kj=e.wasm.cwrap(pr,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,u]=i,[c,d,h,p]=a.shape,f=[c,l,u,p];let m,A=t.dataIdMap.get(a.dataId);"float32"!==A.dtype&&(m=BU({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),A=t.dataIdMap.get(m.dataId));const g=A.id,y=t.makeOutput(f,"float32");if(0===wa.sizeFromShape(a.shape))return y;const x=t.dataIdMap.get(y.dataId).id;return kj(g,c,d,h,p,l,u,s?1:0,o?1:0,x),null!=m&&t.disposeData(m.dataId),y}};var _j,Mj={kernelName:dr,backendName:"wasm",setupFunc:function(e){Tj=e.wasm.cwrap(dr,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,u]=i,[c,d,h,p]=a.shape,f=[c,l,u,p],m=t.makeOutput(f,"float32");if(0===wa.sizeFromShape(a.shape))return m;let A,g=t.dataIdMap.get(a.dataId);"float32"!==g.dtype&&(A=BU({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(A.dataId));const y=g.id,x=t.dataIdMap.get(m.dataId).id;return Tj(y,c,d,h,p,l,u,s?1:0,o?1:0,x),null!=A&&t.disposeData(A.dataId),m}};var $j,Fj={kernelName:Ar,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,o=wa.parseAxisParam(s,a.shape);if(0===a.shape.length)return xU({inputs:{x:a},backend:n});const i=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(o).buffer),d=new Uint8Array(new Int32Array(a.shape).buffer);_j(l,c,o.length,d,a.shape.length,u);const h=$U({inputs:{x:i},attrs:{shape:a.shape},backend:n});return n.disposeData(i.dataId),h},setupFunc:function(e){_j=e.wasm.cwrap(Ar,null,["number","array","number","array","number","number"])}};var Oj,Dj={kernelName:sa,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:o,center:i}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(l.dataId).id,[d,h,p,f]=a.shape,[m,A]=ff.getImageCenter(i,h,p),g="number"==typeof o?[o,o,o,0===o?0:255]:[...o,255],y=new Uint8Array(new Int32Array(g).buffer);return $j(u,d,h,p,f,s,m,A,y,g.length,c),l},setupFunc:function(e){$j=e.wasm.cwrap(sa,null,["number","number","number","number","number","number","number","number","array","number","number"])}},zj=pU(gr),Pj=pU(yr);var Lj,Bj={kernelName:xr,backendName:"wasm",setupFunc:function(e){Oj=e.wasm.cwrap(xr,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:o}=r,i=t.makeOutput(o,s.dtype);if(0===wa.sizeFromShape(o))return i;const{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Ki.calculateShapes(s,a,o),p=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),A=t.dataIdMap.get(i.dataId).id;return Oj(p,f,oU[s.dtype],l,u,c,m,h,A),i}};var Wj,Uj={kernelName:vr,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,o=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(a.shape,a.dtype),c=n.dataIdMap.get(u.dataId).id,d=r.shape.length,h=a.shape.length,p=0===d||d>1||1===h?1:wa.sizeFromShape(a.shape.slice(1));return Lj(o,i,l,p,c),u},setupFunc:function(e){Lj=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}};var Vj,jj={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){Wj=e.wasm.cwrap(Er,null,["number","number"])},kernelFunc:function(e){const{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return 0===wa.sizeFromShape(a.shape)||Wj(r,s),a}},Gj=pU(Sr);var Hj={kernelName:$r,backendName:"wasm",setupFunc:function(e){Vj=e.wasm.cwrap($r,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),o=t.dataIdMap.get(s.dataId).id,i=n.shape[r],l=wa.sizeFromShape(n.shape)/i;return 0===wa.sizeFromShape(s.shape)||Vj(a,o,i,l),s}};var qj,Xj={kernelName:_r,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:o}=r,i=wa.sizeFromShape(s),l=[[0,0]];l.push(...o);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);const u=xj.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=ff.getReshaped(u.shape,s,i,!1),d=ff.getPermuted(c.length,s.length,!1),h=ff.getReshapedPermuted(u.shape,s,i,!1),p=$U({inputs:{x:u},backend:n,attrs:{shape:c}}),f=wU({inputs:{x:p},backend:n,attrs:{perm:d}}),m=$U({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(u.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}};var Kj,Zj={kernelName:Fr,backendName:"wasm",setupFunc:function(e){qj=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n}=e,{indices:r,values:a,denseShape:s,defaultValue:o}=n,i=r.shape[0],l=r.shape[1],u=t.readSync(s.dataId)[0],c=[i+u,l],d=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(a.dataId).id,p=t.dataIdMap.get(o.dataId).id,f=t.makeOutput(c,r.dtype),m=t.dataIdMap.get(f.dataId).id,A=t.makeOutput(c.slice(0,1),a.dtype),g=t.dataIdMap.get(A.dataId).id,y=t.makeOutput([u],"bool"),x=t.dataIdMap.get(y.dataId).id,b=t.makeOutput([i],r.dtype),v=t.dataIdMap.get(b.dataId).id,w=t.makeOutput([4],"int32"),k=t.dataIdMap.get(w.dataId).id,S=qj(d,h,oU[a.dtype],i,u,l,p,m,g,x,v,k),I=t.readSync(w.dataId);let C;switch(I[0]){case 1:C=ff.getSparseFillEmptyRowsIndicesDenseShapeMismatch(I[1]);break;case 2:C=ff.getSparseFillEmptyRowsNegativeIndexErrorMessage(I[1],I[2]);break;case 3:C=ff.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(I[1],I[2],I[3]);break;default:C=""}if(t.disposeData(w.dataId),C)throw t.disposeData(f.dataId),t.disposeData(A.dataId),t.disposeData(y.dataId),t.disposeData(b.dataId),new Error(C);let E=f,N=A;return S!==c[0]&&(E=zU({inputs:{x:f},attrs:{begin:0,size:[S,l]},backend:t}),N=zU({inputs:{x:A},attrs:{begin:0,size:S},backend:t}),t.disposeData(f.dataId),t.disposeData(A.dataId)),[E,N,y,b]}};var Yj,Jj={kernelName:Or,backendName:"wasm",setupFunc:function(e){Kj=e.wasm.cwrap(Or,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=t.dataIdMap.get(r.dataId).id,i=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=r.shape[0],c=wa.sizeFromShape(s.shape),d=t.makeOutput([u,c],r.dtype),h=t.dataIdMap.get(d.dataId).id,p=t.makeOutput([c],s.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),A=t.dataIdMap.get(m.dataId).id;Kj(o,i,l,u,h,f,A);const g=t.readSync(m.dataId);let y;switch(g[0]){case 0:y=ff.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(g[1],g[2]);break;case 1:y=ff.getSparseReshapeNegativeOutputDimErrorMessage(g[1],g[2]);break;case 2:y=ff.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{const e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(p.dataId));y=ff.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{const e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(p.dataId));y=ff.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(d.dataId),t.disposeData(p.dataId),new Error(y);return[d,p]}};function Qj(e){Yj=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function eG(e,t){const{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:o}=r,i=s.shape[0],l=n.readSync(o.dataId,i-1,i)[0],u=i>0?l+1:0;if(u<0)throw new Error(ff.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const c=a.shape.slice();c[0]=u;const d=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(o.dataId).id,f=n.makeOutput(c,a.dtype),m=n.dataIdMap.get(f.dataId).id,A=n.makeOutput([4],"int32"),g=n.dataIdMap.get(A.dataId).id;Yj(d,oU[a.dtype],a.shape[0],h,p,m,g,t,0);const y=n.readSync(A.dataId);let x;switch(y[0]){case 0:x=ff.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:x=ff.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:x=ff.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y[1],y[2]);break;case 3:x=ff.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(y[1],y[2],y[3]);break;default:x=""}if(n.disposeData(A.dataId),x)throw n.disposeData(f.dataId),new Error(x);return f}var tG={kernelName:Dr,backendName:"wasm",setupFunc:Qj,kernelFunc:function(e){return eG(e,!0)}};var nG={kernelName:zr,backendName:"wasm",setupFunc:Qj,kernelFunc:function(e){return eG(e,!1)}};var rG,aG={kernelName:Mr,backendName:"wasm",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:o}=n,i=wa.parseAxisParam(o,a.shape)[0],l=ff.prepareSplitSize(a,s,i),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{const t=[...c];t[i]=e;const n=zU({inputs:{x:a},attrs:{begin:u,size:t},backend:r});return u[i]+=e,n}))}},sG=pU(Tr),oG=pU(Br),iG=mU(Lr);var lG,uG={kernelName:ra,backendName:"wasm",setupFunc:function(e){rG=e.wasm.cwrap(ra,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,o=t.dataIdMap.get(s.dataId).id,i=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(i.dataId).id;return rG(o,a,oU[s.dtype],l),i}};var cG={kernelName:Wr,backendName:"wasm",setupFunc:function(e){lG=e.wasm.cwrap(Wr,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{begin:s,end:o,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:A,isSimpleSlice:g,begin:y,end:x,strides:b}=Qi.sliceInfo(a.shape,s,o,i,l,u,c,d,h);let v;if(m)v=$U({inputs:{x:a},backend:t,attrs:{shape:f}});else if(A||g){wa.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=Qi.computeOutShape(y,x,b),n=zU({inputs:{x:a},backend:t,attrs:{begin:y,size:e}});v=$U({inputs:{x:n},backend:t,attrs:{shape:f}}),t.disposeData(n.dataId)}else{const e=t.makeOutput(p,"float32"),n=t.dataIdMap.get(a.dataId).id,r=new Uint8Array(new Int32Array(wa.computeStrides(a.shape)).buffer),s=new Uint8Array(new Int32Array(y).buffer),o=new Uint8Array(new Int32Array(x).buffer),i=new Uint8Array(new Int32Array(b).buffer),l=new Uint8Array(new Int32Array(p).buffer),u=new Uint8Array(new Int32Array(wa.computeStrides(p)).buffer),c=t.dataIdMap.get(e.dataId).id;lG(n,r,a.shape.length,s,o,i,l,u,p.length,c),v=$U({inputs:{x:e},backend:t,attrs:{shape:f}}),t.disposeData(e.dataId)}return v}};var dG={kernelName:Ur,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:o,nGramWidths:i,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:d}=r,h=t.readSync(a.dataId),p=t.readSync(s.dataId),[f,m]=fT(h,p,o,i,l,u,c,d),A=t.makeOutput([f.length],"string");t.dataIdMap.get(A.dataId).stringBytes=f;const g=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(g).set(m),[A,g]}};var hG={kernelName:Vr,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:o}=r,i=t.readSync(a.dataId),l=t.readSync(s.dataId),[u,c,d]=AT(i,l[0],o),h=c.length,p=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(p).set(u);const f=t.makeOutput([h],"string");t.dataIdMap.get(f.dataId).stringBytes=c;const m=t.makeOutput([2],"int32");return t.typedArrayFromHeap(m).set(d),[p,f,m]}};var pG,fG={kernelName:jr,backendName:"wasm",kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,o=gT(t.readSync(a.dataId),s),i=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(i).set(o),i}},mG=mU(Gr);var AG,gG,yG={kernelName:Rr,backendName:"wasm",setupFunc:function(e){pG=e.wasm.cwrap(Rr,null,["number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:o}=n,i=t.dataIdMap.get(o.dataId).id;let l=i,u=o;const{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=IU(o,a,t);let f=d;if(p){const e=t.dataIdMap.get(c.dataId).id;e!==i&&(u=c,l=e,f=ff.getInnerMostAxes(f.length,u.shape.length))}ff.assertAxesAreInnerMostDims("sum",f,u.shape.length);const[m,A]=ff.computeOutAndReduceShapes(u.shape,f),g=wa.sizeFromShape(A),y=t.makeOutput(m,u.dtype);if(0!==wa.sizeFromShape(u.shape)){const e=t.dataIdMap.get(y.dataId).id;pG(l,g,oU[y.dtype],e)}if(p&&t.disposeData(c.dataId),s){const e=ff.expandShapeToKeepDim(y.shape,h);y.shape=e}return y}},xG=pU(Hr),bG=pU(qr);var vG;var wG=[hU,fU,gU,yU,EU,TU,_U,MU,DU,LU,UU,VU,jU,qU,KU,QU,eV,tV,rV,sV,iV,uV,cV,dV,hV,pV,mV,yV,bV,vV,wV,SV,CV,NV,RV,MV,$V,FV,vU,DV,zV,PV,LV,BV,WV,UV,VV,GV,HV,XV,ZV,ej,tj,rj,aj,sj,lj,cj,hj,pj,fj,mj,gj,xj,bj,wj,Sj,Ij,Cj,Ej,Nj,OU,Rj,Mj,Fj,Dj,zj,Pj,Bj,Uj,jj,Gj,PU,Hj,Xj,Zj,Jj,tG,nG,aG,sG,oG,iG,uG,cG,dG,hG,fG,mG,yG,xG,bG,{kernelName:Xr,backendName:"wasm",setupFunc:function(e){AG=e.wasm.cwrap(Xr,null,["number","array","number","array","number","number"])},kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:o}=r,i=new Array(a.shape.length);for(let e=0;e<i.length;e++)i[e]=a.shape[e]*o[e];const l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(i).buffer),c=n.makeOutput(i,a.dtype),d=n.dataIdMap.get(c.dataId).id;return AG(s,l,a.shape.length,u,i.length,oU[c.dtype],d),c}},{kernelName:Kr,backendName:"wasm",setupFunc:function(e){gG=e.wasm.cwrap(Kr,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{k:a,sorted:s}=n,o=t.dataIdMap.get(r.dataId).id,i=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;const u=t.makeOutput(l,r.dtype),c=t.dataIdMap.get(u.dataId).id,d=t.makeOutput(l,"int32"),h=t.dataIdMap.get(d.dataId).id;return gG(o,i,r.shape.length,oU[r.dtype],a,s,c,h),[u,d]}},{kernelName:Zr,backendName:"wasm",setupFunc:function(e){vG=e.wasm.cwrap(Zr,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){const{backend:t,inputs:n,attrs:r}=e,{image:a,transforms:s}=n,{interpolation:o,fillMode:i,fillValue:l,outputShape:u}=r,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],A=[c,f,m,p],g=new Uint8Array(new Int32Array(wa.computeStrides(a.shape)).buffer),y=t.makeOutput(A,a.dtype),x=t.dataIdMap.get(y.dataId).id,b=t.dataIdMap.get(a.dataId).id,v=t.dataIdMap.get(s.dataId).id,w="nearest"===o?1:2;let k;switch(i){case"constant":default:k=1;break;case"reflect":k=2;break;case"wrap":k=3;break;case"nearest":k=4}return vG(b,v,s.shape[0]>1,c,f,m,p,h,d,g,a.shape.length-1,w,k,l,x),y}},SU,{kernelName:Qr,backendName:"wasm",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a.shape[s],i=a.shape.length,l=new Array(i-1);let u=0;for(let e=0;e<i;e++)e!==s&&(l[u++]=a.shape[e]);const c=new Array(o),d=new Array(i).fill(0),h=a.shape.slice();h[s]=1;for(let e=0;e<c.length;e++)d[s]=e,c[e]=zU({inputs:{x:a},attrs:{begin:d,size:h},backend:n});return c.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:l})))}},{kernelName:na,backendName:"wasm",kernelFunc:function(e){const{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}}];for(const e of wG)Aa(e);var kG=qe();kG.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])))),kG.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(kG.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}}));var SG=I(j()),IG=I(G()),CG=I(H()),EG=SG.default||SG,NG=CG.default||CG,TG=class extends X{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(BG),WG=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new q(this,fi())}write(e,t,n){const r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){const t=wa.now();e();return{kernelMs:wa.now()-t}}move(e,t,n,r,a){const s=this.dataIdNextNumber++;if("string"===r){const o=t;return void this.dataIdMap.set(e,{id:s,stringBytes:o,shape:n,dtype:r,memoryOffset:null,refCount:a})}const o=wa.sizeFromShape(n),i=o*wa.bytesPerElement(r),l=this.wasm._malloc(i);this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,o,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,i),l)}async read(e){return this.readSync(e)}readSync(e,t,n){const{memoryOffset:r,dtype:a,shape:s,stringBytes:o}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=o.length)?o.slice(t,n):o;t=t||0,n=n||wa.sizeFromShape(s);const i=wa.bytesPerElement(a);return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(r+t*i,r+n*i).buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){const n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){if(this.dataIdMap.has(e)){return this.dataIdMap.get(e).refCount}return 0}incRef(e){const t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let r;if(null==n)r=this.write(null,e,t);else{const a=this.dataIdNextNumber++;r={id:a},this.dataIdMap.set(r,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});const s=wa.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,s,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){const r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=wa.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}};function RG(e,t,n){if(null!=$G)return $G;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=OG&&null!=OG[r]?OG[r]:n+r}async function _G(){const[e,t]=await Promise.all([qe().getAsync("WASM_HAS_SIMD_SUPPORT"),qe().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{const a={};var s;a.locateFile=(n,r)=>{if(n.endsWith(".worker.js")){const e=IG.wasmWorkerContents.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?RG(e,t,null!=FG?FG:r):r+n},zG&&(a.instantiateWasm=(s=RG(e,t,null!=FG?FG:""),(e,t)=>(wa.fetch(s,{credentials:"same-origin"}).then((n=>{n.ok||e.env.a(`failed to load wasm binary file at '${s}'`),n.arrayBuffer().then((n=>{WebAssembly.instantiate(n,e).then((e=>{t(e.instance,e.module)}))}))})),{})));let o,i=!1;a.onAbort=()=>{if(i)return;if(DG)return;DG=!0;r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})},t&&e&&null==$G?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+EG.toString()],{type:"text/javascript"}),o=EG(a)):o=NG(a),o.then((e=>{i=!0,DG=!1;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})})).catch(r)}))}var MG=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],$G=null,FG=null,OG={},DG=!1,zG=!1;function PG(e,t=!1){if(hi("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),DG)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");$G=e,zG=t}function LG(e,t=!1){if(DG)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)FG=e;else{OG=e;const t=MG.filter((e=>null==OG[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}zG=t}var BG=-1,WG=-1;function UG(e){BG=e}function VG(){if(-1===WG)throw new Error("WASM backend not initialized.");return WG}var jG="3.19.0";Ei("wasm",(async()=>{const{wasm:e}=await _G();return new TG(e)}),2);var GG,HG,qG=qe();qG.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),qG.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),qG.registerFlag("WEBGPU_MATMUL_WORK_PER_THREAD",(()=>4)),qG.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),qG.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!1)),qG.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),qG.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),qG.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),qG.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!1)),(HG=GG||(GG={}))[HG.MUL=0]="MUL",HG[HG.ADD=1]="ADD",HG[HG.SUB=2]="SUB",HG[HG.DIV=3]="DIV",HG[HG.EQUAL=4]="EQUAL",HG[HG.GREATER=5]="GREATER",HG[HG.GREATER_EQUAL=6]="GREATER_EQUAL",HG[HG.LESS=7]="LESS",HG[HG.LESS_EQUAL=8]="LESS_EQUAL",HG[HG.LOGICAL_AND=9]="LOGICAL_AND",HG[HG.NOT_EQUAL=10]="NOT_EQUAL",HG[HG.SQUARED_DIFFERENCE=11]="SQUARED_DIFFERENCE",HG[HG.INT_DIV=12]="INT_DIV",HG[HG.POW=13]="POW",HG[HG.PRELU=14]="PRELU",HG[HG.MAX=15]="MAX",HG[HG.MIN=16]="MIN",HG[HG.COMPLEX_MULTIPLY_REAL=17]="COMPLEX_MULTIPLY_REAL",HG[HG.COMPLEX_MULTIPLY_IMAG=18]="COMPLEX_MULTIPLY_IMAG";var XG,KG,ZG="\n  if (isNaN.r) {\n    resultTemp.r = uniforms.NAN;\n  }\n  if (isNaN.g) {\n    resultTemp.g = uniforms.NAN;\n  }\n  if (isNaN.b) {\n    resultTemp.b = uniforms.NAN;\n  }\n  if (isNaN.a) {\n    resultTemp.a = uniforms.NAN;\n  }\n  ",YG=`\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = a < vec4<f32>(0.0) & floor(b) < b;\n  ${ZG}\n  return resultTemp;\n  `;function JG(e,t){const n=t?ZG:"\n  if (isnan(a)) { return a; }\n  if (isnan(b)) { return b; }\n  ";return t?`\n    var resultTemp = vec4<f32>(${e}(a, b));\n    let isNaN = isnanVec4(a) | isnanVec4(b);\n    `+n+"\n    return resultTemp;\n  ":n+`\n    return ${e}(a, b);\n  `}function QG(e,t){switch(e){case GG.MUL:return"return a * b;";case GG.ADD:return"return a + b;";case GG.SUB:return"return a - b;";case GG.DIV:return"return a / b;";case GG.EQUAL:return t?"return vec4<f32>(a == b);":"return f32(a == b);";case GG.GREATER:return t?"return vec4<f32>(a > b);":"return f32(a > b);";case GG.GREATER_EQUAL:return t?"return vec4<f32>(a >= b);":"return f32(a >= b);";case GG.LESS:return t?"return vec4<f32>(a < b);":"return f32(a < b);";case GG.LESS_EQUAL:return t?"return vec4<f32>(a <= b);":"return f32(a <= b);";case GG.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(f32(a) >= 1.0 && f32(b) >= 1.0);";case GG.NOT_EQUAL:return t?"return vec4<f32>(a != b);":"return f32(a != b);";case GG.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case GG.INT_DIV:return t?"\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n  ":"\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n  ";case GG.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n  ":"if (a < 0.0) { return b * a; }  return a;";case GG.MAX:return JG("max",t);case GG.MIN:return JG("min",t);case GG.POW:return t?YG:"\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n  ";case GG.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case GG.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";default:throw new Error(`BinaryType ${e} is not implemented!`)}}(KG=XG||(XG={}))[KG.ABS=0]="ABS",KG[KG.CEIL=1]="CEIL",KG[KG.COS=2]="COS",KG[KG.COSH=3]="COSH",KG[KG.ELU=4]="ELU",KG[KG.EXP=5]="EXP",KG[KG.EXPM1=6]="EXPM1",KG[KG.FLOOR=7]="FLOOR",KG[KG.LINEAR=8]="LINEAR",KG[KG.LOG=9]="LOG",KG[KG.LOGICAL_NOT=10]="LOGICAL_NOT",KG[KG.NEG=11]="NEG",KG[KG.RELU=12]="RELU",KG[KG.RELU6=13]="RELU6",KG[KG.LEAKYRELU=14]="LEAKYRELU",KG[KG.RSQRT=15]="RSQRT",KG[KG.SIN=16]="SIN",KG[KG.SINH=17]="SINH",KG[KG.SIGMOID=18]="SIGMOID",KG[KG.SQRT=19]="SQRT",KG[KG.SQUARE=20]="SQUARE",KG[KG.TANH=21]="TANH",KG[KG.TO_INT=22]="TO_INT";function eH(e,t){switch(e){case XG.ABS:return"return abs(a);";case XG.COS:return"return cos(a);";case XG.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case XG.CEIL:return"return ceil(a);";case XG.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case XG.EXP:return"return exp(a);";case XG.EXPM1:return"return exp(a) - 1.0;";case XG.FLOOR:return"return floor(a);";case XG.LINEAR:return"return a;";case XG.LOG:return"if (a < 0.0) { return 1.0/0.0; }\n  return log(a);";case XG.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case XG.NEG:return"return -a;";case XG.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case XG.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case XG.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case XG.RSQRT:return"return 1.0/sqrt(a);";case XG.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case XG.SIN:return"return sin(a);";case XG.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case XG.SQRT:return"return sqrt(a);";case XG.SQUARE:return"return a * a;";case XG.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case XG.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${e} is not implemented!`)}}var tH=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${e}-component is not supported.`)}};function nH(e,t=!1,n=!1,r=3){if(null===e)return"";let a="";if("linear"===e)a=eH(XG.LINEAR);else if("relu"===e)a=eH(XG.RELU,n);else if("elu"===e)a=eH(XG.ELU,n);else if("relu6"===e)a=eH(XG.RELU6,n);else if("prelu"===e)a=QG(GG.PRELU,n);else if("sigmoid"===e)a=eH(XG.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);a=eH(XG.LEAKYRELU,n)}const s=tH(n?4:1);let o="";return o=t?`\n      fn activation(a : ${s}, coords : vec${r}<i32>) -> ${s} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${a}\n      }`:`\n      fn activation(a : ${s}, coords : vec${r}<i32>) -> ${s} {\n        ${a}\n      }`,o}function rH(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function aH(e,t){if(Math.max(...e)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let e=n-3;e>=0;--e)a[e]=`(${a[e+1]} * ${r[e+1]})`;return a}var sH=(e,t,n,r)=>{const a=function(e,t,n){const r=[];if(r.push(`\n      const workGroupSizeX = ${n.workGroupSize[0]}u;\n      const workGroupSizeY = ${n.workGroupSize[1]}u;\n      const workGroupSizeZ = ${n.workGroupSize[2]}u;\n\n      var<private> localId: vec3<u32>;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${fH(n)?"  return i32(globalId.x);":"  let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +\n                   localId.y * workGroupSizeX + localId.x;\n               let workGroupID = (globalId - localId)/vec3<u32>(\n                   workGroupSizeX, workGroupSizeY, workGroupSizeZ);\n\n               return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +\n                   workGroupID.y * numWorkgroups.x + workGroupID.x) *\n                   (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +\n                   localInvocationIndex);\n        "}\n      }\n    `),n.isFromPixels)return r.push(`\n        struct Uniform {\n          size            : i32,\n          numChannels     : i32,\n          outShapeStrides : vec2<i32>,\n        };\n\n        @group(0) @binding(0) var<storage, read_write> result: array<${mH(t.dtype,n.isVec4)}>;\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `),[dH,r.join("\n"),hH(t.shape),n.getUserCode()].join("\n");let a=!1,s=!1,o="struct Uniforms { NAN : f32, ";n.variableNames.forEach(((t,n)=>{const r=oH(e[n].shape.length);"vec5"!==r&&"vec6"!==r||(s=!0),(a||s)&&(o+="@align(16) "),a=s,o+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${r}, `}));const i=oH(t.shape.length);s="vec5"===i||"vec6"===i,(a||s)&&(o+="@align(16) ");a=s,o+=`outShape : ${i}, `;const l=oH(t.shape.length-1);s="vec5"===l||"vec6"===l,(a||s)&&(o+="@align(16) ");a=s,o+=`\n         outShapeStrides: ${l}, `,n.size&&(a&&(o+="@align(16) "),a=!1,o+="size : i32, ");n.uniforms&&(a&&(o+="@align(16) "),o+=n.uniforms);o+="};",r.push(o),n.atomic?r.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):r.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${mH(t.dtype,n.isVec4)}>;\n    `);n.variableNames.forEach(((t,a)=>{r.push(`\n      @group(0) @binding(${1+a}) var<storage, read> ${t}: array<${n.variableTypes?n.variableTypes[a]:mH(e[a].dtype,n.isVec4)}>;\n        `)})),""!==o&&r.push(`\n      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const u=function(e,t){const{x:n,y:r=[],z:a=[]}=t,s=e.length;if(n.length===s){return`fn getOutputCoords() -> ${oH(s)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `}let o="";const i=[n,r,a];let l=0;for(let e=0;e<i.length;e++){const t=i[e];if(0!==t.length)if(l+=t.length,1===t.length)o+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=aH(t,"uniforms.outShape");o+=`var index${e} = i32(globalId[${e}]);`;for(let r=0;r<n.length;r++)o+=`let d${t[r]} = index${e} / ${n[r]};`,r===n.length-1?o+=`let d${t[r+1]} = index${e} - d${t[r]} * ${n[r]};`:o+=`index${e} = index${e} - d${t[r]} * ${n[r]};`}}const u=[];for(let e=0;e<l;e++)u.push(`d${e}`);const c=oH(l);let d=`fn getOutputCoords() -> ${c} {\n  ${o}\n`;0===u.length?d+=`return ${c}(0); }`:d+=`return ${c}(${u.join(",")}); }`;return d}(t.shape,n.dispatchLayout),c=[dH,r.join("\n"),hH(t.shape),u,pH(t.shape.length)];n.atomic||c.push(function(e,t,n){const r=e.length,a=mH(t,n);let s;s=n?`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {\n      result[flatIndex] = ${a}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {\n      result[flatIndex] = ${a}(value);\n    }`:`fn setOutputAtIndex(flatIndex : i32, value : f32) {\n      result[flatIndex] = ${a}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {\n      result[flatIndex] = ${a}(value);\n    }`;if(r>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,r),t=oH(r);s+=n?`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : vec4<f32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex / 4, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : vec4<i32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex / 4, value);\n      }\n    `:`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : f32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : i32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex, value);\n      }\n    `}return s}(t.shape,t.dtype,n.isVec4));const d=e.map(((e,r)=>function(e,t,n,r){let a=function(e,t){const n=e.name,r=e.shape.length,a=oH(r),s="get"+n.charAt(0).toUpperCase()+n.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,r),i=o.map((e=>`${e} : i32`)).join(", ");if(r<1)return t?`\n        fn ${s}() -> vec4<f32> {\n          return vec4<f32>(${n}[0]);\n        }\n      `:`\n      fn ${s}() ->f32 {\n        return f32(${n}[0]);\n      }\n    `;const l=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let u=`${r}D`;0===r&&(u="1D");if(t)return`\n      fn ${s}(${i}) -> vec4<f32> {\n        return vec4<f32>(${n}[getIndexFromCoords${u}(${a}(${o.join(",")}),\n          ${l}) / 4]);\n      }\n      `;return`\n    fn ${s}(${i}) -> f32 {\n      return f32(${n}[getIndexFromCoords${u}(${a}(${o.join(",")}),\n        ${l})]);\n    }\n   `}(e,n);e.shape.length<=t.length&&(a+=function(e,t,n,r){const a=e.name,s=a.charAt(0).toUpperCase()+a.slice(1),o="get"+s+"ByOutput",i=e.shape.length,l=t.length,u=oH(l);if(wa.arraysEqual(e.shape,t)&&r)return n?`\n      fn ${o}Index(globalIndex : i32) -> vec4<f32> {\n        return vec4<f32>(${a}[globalIndex]);\n      }\n\n      fn ${o}Coords(coords : ${u}) -> vec4<f32> {\n        return vec4<f32>(${a}[${l>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);\n      }\n      `:`\n    fn ${o}Index(globalIndex : i32) -> f32 {\n      return f32(${a}[globalIndex]);\n    }\n\n    fn ${o}Coords(coords : ${u}) -> f32 {\n      return f32(${a}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}]);\n    }\n    `;const c=ff.getBroadcastDims(e.shape,t),d=l-i;let h="";if(0===i)return n?`\n    fn ${o}Index(globalIndex : i32) -> vec4<f32> {\n      return get${s}();\n    }\n\n    fn ${o}Coords(coords : ${u}) -> vec4<f32> {\n      return get${s}();\n    }\n  `:`\n    fn ${o}Index(globalIndex : i32) -> f32{\n      return get${s}();\n    }\n\n    fn ${o}Coords(coords : ${u}) -> f32{\n      return get${s}();\n    }\n  `;h=l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${iH(e+d)} = 0;`)).join("\n");let p="";if(l<2&&i>0)p="coords";else if(l>1){const t=oH(i),n=e.shape.map(((e,t)=>`coords.${iH(t+d)}`)).join(", ");p=`${t}(${n})`}else p="coords";const f=`uniforms.${a.charAt(0).toLowerCase()+a.slice(1)}Shape`,m=`${i}D`;if(n)return`\n    fn ${o}Index(globalIndex : i32) -> vec4<f32> {\n      var coords = getCoordsFromIndex(globalIndex);\n      ${h}\n      return ${a}[getIndexFromCoords${m}(${p}, ${f}) / 4];\n    }\n\n    fn ${o}Coords(coordsIn : ${u}) -> vec4<f32> {\n      var coords = coordsIn;\n      ${h}\n      return ${a}[getIndexFromCoords${m}(${p}, ${f}) / 4];\n    }\n  `;return`\n  fn ${o}Index(globalIndex : i32) -> f32 {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${h}\n    return f32(${a}[getIndexFromCoords${m}(${p}, ${f})]);\n  }\n\n  fn ${o}Coords(coordsIn : ${u}) -> f32 {\n    var coords = coordsIn;\n    ${h}\n    return f32(${a}[getIndexFromCoords${m}(${p}, ${f})]);\n  }\n`}(e,t,n,r));return a}(e,t.shape,n.variableTypes?"vec4<f32>"===n.variableTypes[r]:n.isVec4,n.dispatchLayout.x.length===t.shape.length))).join("\n");c.push(d),c.push(n.getUserCode());return c.join("\n")}(n,{dtype:r.dtype,shape:r.shape},t),s=e.createShaderModule({code:a,label:t.constructor.name});return e.createComputePipeline({compute:{module:s,entryPoint:"main"},label:t.constructor.name,layout:"auto"})};function oH(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function iH(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function lH(){return`\n    ${uH()}\n      let index = getGlobalIndex();\n`}function uH(){return`\n  ${cH()}\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n`}function cH(){return"\n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n"}var dH="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let mod: i32 = a % b;\n    if (sign < 0. && mod != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));\n  }\n";function hH(e){const t=e.length;if(t<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";const n=wa.computeStrides(e),r=oH(t),a=[];for(let e=0;e<t;e++)a.push(`d${e}`);if(1===n.length)return"    fn getCoordsFromIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }";let s;return s="var index2 = index;"+n.map(((e,t)=>`${`let ${a[t]} = index2 / uniforms.outShapeStrides.${iH(t)}`}; ${t===n.length-1?`let ${a[t+1]} = index2 - ${a[t]} * uniforms.outShapeStrides.${iH(t)}`:`index2 = index2 - ${a[t]} * uniforms.outShapeStrides.${iH(t)}`};`)).join(""),`\n    fn getCoordsFromIndex(index : i32) -> ${r} {\n      ${s}\n      return ${r}(${a.join(",")});\n    }\n  `}function pH(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:wa.assert(!1,(()=>`Unsupported ${e}D shape`))}return t}function fH(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function mH(e,t){return"float32"===e?t?"vec4<f32>":"f32":"int32"===e||"bool"===e?t?"vec4<i32>":"i32":e}var AH={};S(AH,{ArrayBufferToTypedArray:()=>EH,GPUBytesPerElement:()=>CH,MatMulProgramType:()=>gH,computeDispatch:()=>vH,computeWorkGroupSizeForConv2d:()=>wH,computeWorkGroupSizeForMatMul:()=>kH,computeWorkPerThreadForConv2d:()=>SH,flatDispatchLayout:()=>IH,isWebGPUSupported:()=>NH,tilesFitEvenlyIntoShape:()=>bH});var gH,yH,xH=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function bH(e,t){if(e.length!==t.length)throw new Error(`Cannot compute whether rank ${e.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);return t.every(((t,n)=>t%e[n]==0))}function vH(e,t,n=[1,1,1],r=[1,1,1]){const[a,s,o]=[Math.ceil(xH(e.x.map((e=>t[e])))/(n[0]*r[0])),e.y?Math.ceil(xH(e.y.map((e=>t[e])))/(n[1]*r[1])):1,e.z?Math.ceil(xH(e.z.map((e=>t[e])))/(n[2]*r[2])):1];return[a,s,o]}function wH(e,t,n=!1){if(n)return[8,8,1];const r=xH(e.x.map((e=>t[e]))),a=xH(e.y.map((e=>t[e])));return r<=4?[4,16,1]:a<=4?[16,4,1]:[16,16,1]}function kH(e,t,n){return 1===e?[32,1,1]:1===n?[1,32,1]:[8,8,1]}function SH(e,t,n=!1){if(n)return[4,4,1];const r=xH(e.x.map((e=>t[e]))),a=xH(e.y.map((e=>t[e])));return r<=4?[1,2,1]:a<=4?[2,1,1]:[2,2,1]}function IH(e){return{x:e.map(((e,t)=>t))}}function CH(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error(`Unknown dtype ${e}`)}function EH(e,t){if("float32"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function NH(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}function TH(e,t,n,r,a=!1,s=!1,o=!1,i=1){wa.assert(n&&1===i||!n,(()=>`transposeA ${n} is not compatible with component size ${i}`));const l=`\n      let batch = ${e?"0":"batchIn"};\n      let batchASize = uniforms.aShape[1] * uniforms.aShape[2];\n      ${n?`value = A[(batch * batchASize + col * uniforms.aShape[2] + row) / ${i}];`:`value = A[(batch * batchASize + row * uniforms.aShape[2] + col) / ${i}];`}\n\n    `;let u;return u=!1===r?`value = B[(batch * batchBSize + row * uniforms.bShape[2] + col) / ${i}];`:`value = B[(batch * batchBSize + col * uniforms.bShape[2] + row) / ${i}];`,`\n  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> ${tH(i)} {\n    var value = ${tH(i)}(0.0);\n    let col = colIn * ${i};\n    ${a&&o?l:`\n    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${l}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> ${tH(i)} {\n    let col = colIn * ${i};\n    let batch = ${t?"0":"batchIn"};\n    let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];\n    var value = ${tH(i)}(0.0);\n    ${u}\n    return value;\n  }\n  `}function RH(e,t,n,r,a,s,o=!1,i=!1,l=!1,u=1){return`\n  ${TH(n,r,a,s,o,i,l,u)}\n  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${tH(u)}) {\n    let col = colIn * ${u};\n    ${o&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${rH(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}(yH=gH||(gH={}))[yH.MatMulPackedVec4Program=0]="MatMulPackedVec4Program",yH[yH.MatMulReduceProgram=1]="MatMulReduceProgram",yH[yH.MatMulSplitKProgram=2]="MatMulSplitKProgram",yH[yH.MatMulSmallOutputSizeProgram=3]="MatMulSmallOutputSizeProgram",yH[yH.MatMulPackedProgram=4]="MatMulPackedProgram",yH[yH.MatMulMax=5]="MatMulMax";function _H(e,t,n=!1,r=32){const a=e[1]*t[1],s=e[0]*t[0],o=n?a:r,i=n?r:a;wa.assert(i%t[1]==0&&o%t[0]==0&&r%t[1]==0,(()=>`tileAHight ${i} must be divisible by workGroupSize[1]${t[1]}, tileAWidth ${o} must be divisible by workGroupSize[0]${t[0]}, tileInner ${r} must be divisible by workGroupSize[1]${t[1]}`));const l=i/t[1],u=o/t[0],c=r/t[1];return`\n    var<workgroup> mm_Asub : array<array<f32, ${o}>, ${i}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${s}>, ${r}>;\n    const RowPerThread = ${e[1]};\n    const ColPerThread = ${e[0]};\n    const TileInner = ${r};\n\n    @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n    fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n            @builtin(global_invocation_id) GlobalId : vec3<u32>,\n            @builtin(num_workgroups) NumWorkgroups: vec3<u32>,\n            @builtin(workgroup_id) workgroupId: vec3<u32>) {\n      localId = LocalId;\n      globalId = GlobalId;\n      numWorkgroups = NumWorkgroups;\n\n      let tileRow = i32(localId.y) * RowPerThread;\n      let tileCol = i32(localId.x) * ColPerThread;\n\n      let globalRow = i32(globalId.y) * RowPerThread;\n      let globalCol = i32(globalId.x) * ColPerThread;\n      let batch = i32(globalId.z);\n      let globalRowStart = i32(workgroupId.y) * ${a};\n\n      let numTiles = (uniforms.dimInner - 1) / TileInner + 1;\n\n      var acc : array<array<f32, ColPerThread>, RowPerThread>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n\n      let tileRowA = i32(localId.y) * ${l};\n      let tileColA = i32(localId.x) * ${u};\n      let tileRowB = i32(localId.y) * ${c};\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${l}; innerRow = innerRow + 1) {\n          for (var innerCol = 0; innerCol < ${u}; innerCol = innerCol + 1) {\n            let inputRow = tileRowA + innerRow;\n            let inputCol = tileColA + innerCol;\n            ${d=n,d?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          t * TileInner + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRowStart + inputRow,\n          t * TileInner + inputCol);\n        "}\n          }\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {\n          for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol + innerCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n              t * TileInner + inputRow,\n              globalCol + innerCol);\n          }\n        }\n\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ColPerThread>;\n        for (var k = 0; k < TileInner; k = k + 1) {\n          for (var inner = 0; inner < ColPerThread; inner = inner + 1) {\n            BCached[inner] = mm_Bsub[k][tileCol + inner];\n          }\n\n          for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n            ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n            for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n            }\n          }\n        }\n\n        workgroupBarrier();\n      }\n\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n              acc[innerRow][innerCol]);\n        }\n      }\n    }\n  `;var d}function MH(e,t,n,r,a=4,s=!1){const o=s?t:r,i=s?r:t,l=s?e[1]:a;return wa.assert((s&&t===n||r%4==0||r%3==0)&&4===e[0]&&(3===a||4===a),(()=>`tileInner ${r} must be divisible by 4|3. ColPerThread ${e[0]} must be 4.\n           innerElementSize ${a} must be 3|4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${l}<f32>, ${o/l}>, ${i}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${n/e[0]}>, ${r}>;\n\n  const RowPerThread = ${e[1]};\n  const ColPerThread = ${e[0]};\n  const InnerElementSize = ${a};\n  const TileInner = ${r};\n\n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>,\n          @builtin(workgroup_id) workgroupId: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n    let localRow = i32(localId.y);\n    let tileRow = ${1===t?"0":"localRow * RowPerThread"};\n    let tileCol = i32(localId.x);\n\n    let globalRow = ${1===t?"0":"i32(globalId.y) * RowPerThread"};\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let globalRowStart = i32(workgroupId.y) * ${t};\n\n    let numTiles = (uniforms.dimInner - 1) / TileInner + 1;\n\n    var acc: array<vec4<f32>, RowPerThread>;\n    var BCached : array<vec4<f32>, 4>;\n\n    // Loop over shared dimension.\n    let RowPerThreadB = TileInner / i32(workGroupSizeY);\n    let tileRowB = localRow * RowPerThreadB;\n    for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          t * TileInner + inputRow,\n          globalRowStart / ${t} + inputCol);\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          t * TileInner / ${t} + inputCol);\n        `)(s,l)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batch, t * TileInner + inputRow, globalCol);\n        }\n\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileInner / InnerElementSize; k = k + 1) {\n            BCached[0] = mm_Bsub[k * InnerElementSize][tileCol];\n            BCached[1] = mm_Bsub[k * InnerElementSize + 1][tileCol];\n            BCached[2] = mm_Bsub[k * InnerElementSize + 2][tileCol];\n            ${3===a?"":"BCached[3] = mm_Bsub[k * InnerElementSize + 3][tileCol];"}\n\n            ${((e,t)=>e?`\n        let ACached0 = mm_Asub[k * InnerElementSize][localRow];\n        let ACached1 = mm_Asub[k * InnerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * InnerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * InnerElementSize + 3][localRow];"}\n        for (var i = 0; i < RowPerThread; i = i + 1) {\n          acc[i] = BCached[0] * ACached0[i] + acc[i];\n          acc[i] = BCached[1] * ACached1[i] + acc[i];\n          acc[i] = BCached[2] * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached[3] * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < RowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached[0] * ACached.x + acc[i];\n          acc[i] = BCached[1] * ACached.y + acc[i];\n          acc[i] = BCached[2] * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached[3] * ACached.w + acc[i];"}\n        }`)(s,a)}\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}function $H(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||wa.inferDtype(a),"string"===s){const e=wa.getArrayFromDType(s,wa.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{const e=new class{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${lH()}\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}(r),n=[{type:"float32",data:[a]}];return t.runWebGPUProgram(e,[],s,n)}}var FH={kernelName:rn,backendName:"webgpu",kernelFunc:$H};function OH(e){const{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=wa.sizeFromShape(r.shape),o=wa.inferFromImplicitShape(a,s),i=wa.sizeFromShape(o);return wa.assert(s===i,(()=>`The new shape (${o}) has ${i} elements and the old shape (${r.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}var DH={kernelName:cr,backendName:"webgpu",kernelFunc:OH};function zH({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],h=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),A=t.shape.slice(0,-2),g=wa.sizeFromShape(m),y=wa.sizeFromShape(A),x=Oi.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);wa.assert(d===h,(()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const b=n?[g,d,p]:[g,p,d],v=r?[y,f,h]:[y,h,f],w=OH({inputs:{x:e},backend:a,attrs:{shape:b}}),k=OH({inputs:{x:t},backend:a,attrs:{shape:v}}),S=[w,k],I=Math.max(g,y),C=1===g,E=1===y,N=(d%4==0&&!n||p%4==0&&n)&&f%4==0&&!r,T=[w,k],R=[{type:"int32",data:[p]},{type:"int32",data:[f]},{type:"int32",data:[d]}];let _,M;const $=[I,p,f];let F=qe().get("WEBGPU_MATMUL_PROGRAM_TYPE");switch(F<0&&(F=p*f<=128?gH.MatMulReduceProgram:1===I&&p<=128&&f<=48&&h>=2e3?gH.MatMulSplitKProgram:p<=16&&(f<=512||h>=2*f)||f<=16&&(p<=512||d>=2*p)?gH.MatMulSmallOutputSizeProgram:N?gH.MatMulPackedVec4Program:gH.MatMulPackedProgram),F){case gH.MatMulPackedVec4Program:_=new class{constructor(e,t,n,r,a=!1,s=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,8,1],this.isVec4=!0,this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]},1!==t[1]||a?this.elementsPerThread=[4,4,1]:this.elementsPerThread=[4,1,1],this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread);const l=null!=s,u=null!=i;l&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.tileAOuter=1!==t[1]||a?this.workGroupSize[1]*this.elementsPerThread[1]:1,this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=this.tileBOuter,this.aShape=e,this.addBias=l,this.activation=o,this.hasPreluActivationWeights=u,this.batchAEqualOne=n,this.batchBEqualOne=r,this.transposeA=a;const c=a?e[1]:e[2];this.fitAOuter=t[1]%this.tileAOuter==0,this.fitBOuter=t[2]%this.tileBOuter==0,this.fitInner=c%this.tileInner==0,this.shaderKey=`matMulPackedVec4_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.elementsPerThread}_${this.batchAEqualOne}_${this.batchBEqualOne}_${this.transposeA}`}getUserCode(){return`\n      ${nH(this.activation,this.hasPreluActivationWeights,!0)}\n      ${RH(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,!1,this.fitAOuter,this.fitBOuter,this.fitInner,4)}\n      ${MH(this.elementsPerThread,this.tileAOuter,this.tileBOuter,this.tileInner,4,this.transposeA)}\n    `}}(b,$,C,E,n,s,l,o);break;case gH.MatMulReduceProgram:_=new class{constructor(e,t,n,r=!1,a=!1,s=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize);const l=null!=s,u=null!=i;l&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=a,this.addBias=l,this.activation=o,this.hasPreluActivationWeights=u,this.batchAEqualOne=t,this.batchBEqualOne=n,this.shaderKey=`matMulReduce_${this.activation}_${r}_${a}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`\n      ${nH(this.activation,this.hasPreluActivationWeights)}\n      ${RH(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}\n      \n    var<workgroup> sumValues : array<f32, workGroupSizeX>;\n    ${uH()}\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {\n        let dataA = mm_readA(batch, row, k);\n        let dataB = mm_readB(batch, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  \n    `}}($,C,E,n,r,s,l,o);break;case gH.MatMulSplitKProgram:if(M=$H({backend:a,attrs:{shape:$,value:0,dtype:e.dtype}}),_=new class{constructor(e,t,n,r,a=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,8,1],this.atomic=!0,this.tileInner=32,wa.assert(1===e[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.elementsPerThread=[4,4,this.tileInner],this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1),this.dispatch=vH(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workGroupSize,this.elementsPerThread),this.transposeA=a,this.transposeB=s,this.batchAEqualOne=n,this.batchBEqualOne=r,this.shaderKey=`matMulSplitK_${a}_${s}_${n}_${r}_${this.elementsPerThread}`}getUserCode(){return`\n      ${TH(this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : f32) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          var value = valueIn;\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          \n     var oldValue = atomicLoad(&(result[flatIndex]));\n     var exchanged = false;\n     for (; !exchanged;) {\n       let newValueF32 = bitcast<f32>(oldValue) + value;\n       let newValue = bitcast<i32>(newValueF32);\n       let res = atomicCompareExchangeWeak(&(result[flatIndex]), oldValue, newValue);\n       oldValue = res.old_value;\n       exchanged = res.exchanged;\n     }\n     \n        }\n      }\n\n      ${this.makeMatMulSplitKSource()}\n    `}makeMatMulSplitKSource(){const e=this.workGroupSize[1]*this.elementsPerThread[1],t=this.workGroupSize[0]*this.elementsPerThread[0],n=this.elementsPerThread[1],r=this.elementsPerThread[0],a=this.tileInner/this.workGroupSize[0],s=this.tileInner/this.workGroupSize[1];return wa.assert(this.tileInner%this.workGroupSize[0]==0&&this.tileInner%this.workGroupSize[1]==0,(()=>`tileInner ${this.tileInner} must be divisible by workGroupSize[0]${this.workGroupSize[0]} and workGroupSize[1]${this.workGroupSize[1]}`)),`\n      var<workgroup> mm_Asub : array<array<f32, ${this.tileInner}>, ${e}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${this.tileInner}>;\n      ${uH()}\n        let tileRow = i32(localId.y) * ${n};\n        let tileCol = i32(localId.x) * ${r};\n\n        let globalRow = i32(globalId.y) * ${n};\n        let globalCol = i32(globalId.x) * ${r};\n        let batch = 0;\n        let kStart = i32(globalId.z) * ${this.tileInner};\n\n        // Load one tile of A into local memory.\n        let tileColA = i32(localId.x) * ${a};\n        for (var innerRow = 0; innerRow < ${n}; innerRow = innerRow + 1) {\n          for (var innerCol = 0; innerCol < ${a}; innerCol = innerCol + 1) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileColA + innerCol;\n            mm_Asub[inputRow][inputCol] = mm_readA(${this.batchAEqualOne?0:"batch"},\n                globalRow + innerRow,\n                kStart + inputCol);\n          }\n        }\n        // Load one tile of B into local memory.\n        let tileRowB = i32(localId.y) * ${s};\n        for (var innerRow = 0; innerRow < ${s}; innerRow = innerRow + 1) {\n          for (var innerCol = 0; innerCol < ${r}; innerCol = innerCol + 1) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol + innerCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(${this.batchBEqualOne?0:"batch"},\n                kStart + inputRow,\n                globalCol + innerCol);\n          }\n        }\n\n        workgroupBarrier();\n\n        var acc : array<array<f32, ${r}>, ${n}>;\n        // Loop over shared dimension. Compute acc values for a single thread.\n        for (var k = 0; k < ${this.tileInner}; k = k + 1) {\n          var BCached : array<f32, ${r}>;\n          for (var inner = 0; inner < ${r}; inner = inner + 1) {\n            BCached[inner] = mm_Bsub[k][tileCol + inner];\n          }\n\n          for (var innerRow = 0; innerRow < ${n}; innerRow = innerRow + 1) {\n            let ACached = mm_Asub[tileRow + innerRow][k];\n            for (var innerCol = 0; innerCol < ${r}; innerCol = innerCol + 1) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n            }\n          }\n        }\n\n        for (var innerRow = 0; innerRow < ${n}; innerRow = innerRow + 1) {\n          for (var innerCol = 0; innerCol < ${r}; innerCol = innerCol + 1) {\n            mm_write(batch, globalRow + innerRow, globalCol + innerCol, acc[innerRow][innerCol]);\n          }\n        }\n      }\n    `}}($,h,C,E,n,r),s||l){M=a.runWebGPUProgram(_,T,e.dtype,R,M);const t=new class{constructor(e,t=null,n=null,r=null){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`\n    ${nH(this.activation,this.hasPreluActivationWeights)}\n    ${lH()}\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${rH(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}(M.shape,s,l,o);let n=null;const r=[M];s&&r.push(s),o&&r.push(o),"leakyrelu"===l&&(n=[{type:"float32",data:[i]}],t.uniforms+=" alpha : f32,");const u=a.runWebGPUProgram(t,r,M.dtype,n);S.push(M);const c=OH({inputs:{x:u},backend:a,attrs:{shape:x}});S.push(u);for(const e of S)a.disposeData(e.dataId);return c}break;case gH.MatMulSmallOutputSizeProgram:_=new class{constructor(e,t,n,r=!1,a=!1,s=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workGroupSize[0]),Math.ceil(n[1]/this.workGroupSize[1]),n[0]];const l=null!=s;l&&this.variableNames.push("bias");const u=null!=i;u&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=a,this.addBias=l,this.activation=o,this.hasPreluActivationWeights=u,this.batchAEqualOne=1===e[0],this.batchBEqualOne=1===t[0],this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${a}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`\n      ${nH(this.activation,this.hasPreluActivationWeights)}\n      ${RH(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],r=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${uH()}\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batch, globalRow, globalColA);\n    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${r};\n    globalRowB = globalRowB + ${r};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batch, globalRow, globalColA);\n      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${r};\n      globalRowB = globalRowB + ${r};\n\n      for (var k = 0; k < ${r}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workGroupSize)}\n    `}}(b,v,$,n,r,s,l,o);break;case gH.MatMulPackedProgram:_=new class{constructor(e,t,n,r,a,s=!1,o=!1,i=null,l=null,u=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[16,16,1],this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=s?e[1]:e[2];this.workGroupSize=kH(t[1],0,t[2]),1!==t[1]&&1!==t[2]||(n=1),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[n,n,1]),wa.arraysEqual(this.dispatch,[1,1,1])&&(n=1,this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[n,n,1]));const d=null!=i,h=null!=u;d&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.workPerThread=n,this.transposeA=s,this.transposeB=o,this.addBias=d,this.activation=l,this.hasPreluActivationWeights=h,this.batchAEqualOne=r,this.batchBEqualOne=a,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey=`matMulPacked_${this.workPerThread}_${s}_${o}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.outputShape[1]>1}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getShapeFit(e,t,n){const r=this.workGroupSize[1]*this.workPerThread,a=this.workGroupSize[0]*this.workPerThread;return this.tileInner=32,1===this.outputShape[1]&&(this.tileInner=4*this.workGroupSize[0]),[e%r==0,t%a==0,n%this.tileInner==0]}getUserCode(){return`\n      ${nH(this.activation,this.hasPreluActivationWeights)}\n      ${RH(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner)}\n      ${this.outputShape[1]>1?_H([this.workPerThread,this.workPerThread,1],this.workGroupSize,this.transposeA,this.tileInner):function(e,t=!1){return wa.assert(1===e[1]&&1===e[2],(()=>`A linear work group size is required. But got ${e}.`)),`\n    const TileSize = ${4*e[0]};\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${uH()}\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;\n      let batch = i32(globalId.z);\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        let colA = t * TileSize + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${n=t,n?"\n      mm_readA(batch, colA, globalRow),\n      mm_readA(batch, colA + 1, globalRow),\n      mm_readA(batch, colA + 2, globalRow),\n      mm_readA(batch, colA + 3, globalRow)\n  ":"\n      mm_readA(batch, globalRow, colA),\n      mm_readA(batch, globalRow, colA + 1),\n      mm_readA(batch, globalRow, colA + 2),\n      mm_readA(batch, globalRow, colA + 3)\n  "});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileSize / 4; k = k + 1) {\n          let rowB = t * TileSize + k * 4;\n          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),\n                              mm_readB(batch, rowB + 1, globalCol),\n                              mm_readB(batch, rowB + 2, globalCol),\n                              mm_readB(batch, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `;var n}(this.workGroupSize,this.transposeA)}\n    `}}(b,$,qe().get("WEBGPU_MATMUL_WORK_PER_THREAD"),C,E,n,r,s,l,o);break;default:throw new Error(`Unsupported MatMulProgramType ${F}.`)}s&&T.push(s),o&&T.push(o),"leakyrelu"===l&&(R.push({type:"float32",data:[i]}),_.uniforms+=" alpha : f32,"),M=a.runWebGPUProgram(_,T,e.dtype,R,M);const O=OH({inputs:{x:M},backend:a,attrs:{shape:x}});S.push(M);for(const e of S)a.disposeData(e.dataId);return O}var PH={kernelName:oa,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return zH({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}},LH=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=ff.assertAndGetBroadcastShape(t,n),this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${QG(this.op,!1)}\n      }\n\n      ${lH()}\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}},BH=class{constructor(e,t,n){this.size=!0,this.variableNames=["A","B"],this.outputShape=ff.assertAndGetBroadcastShape(t,n),this.dispatchLayout=IH(this.outputShape),this.op=e,this.useSharedMemoryWithA=1===t.length&&n.length>1&&t[0]<1024,this.useSharedMemoryWithB=1===n.length&&t.length>1&&n[0]<1024,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workGroupSize=[256,1,1],this.lastDimensionSize<256?this.workPerThread=1:this.lastDimensionSize<512?this.workPerThread=2:this.workPerThread=4):(wa.arraysEqual(t,n)&&wa.sizeFromShape(t)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workGroupSize=[128,1,1]),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1])}getUserCode(){let e;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",n=this.useSharedMemoryWithB?`let a = getAByOutputCoords(coords);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputCoords(coords);`;e=`\n        fn binaryOperation(a : f32, b : f32) -> f32 {\n          ${QG(this.op,this.isVec4)}\n        }\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${lH()}\n\n          // Fill in the shared memory buffer. Here we need a loop to make sure\n          // that all data in A|B are uploaded when |sharedMemorySize| is larger\n          // than work group size.\n          for(var localIndex = i32(localId.x); localIndex < ${this.lastDimensionSize}; localIndex = localIndex + ${this.workGroupSize[0]}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n            let flatIndex = index * ${this.workPerThread} + i;\n            if(flatIndex < uniforms.size) {\n              let coords = getCoordsFromIndex(flatIndex);\n\n              ${n}\n              setOutputAtIndex(flatIndex, binaryOperation(a, b));\n            }\n          }\n        }\n        `}else{const t="vec4"===this.type?"vec4<f32>":"f32";e=`\n       fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n         ${QG(this.op,this.isVec4)}\n       }\n       ${lH()}\n         if (index < uniforms.size) {\n           let a = getAByOutputIndex(index);\n           let b = getBByOutputIndex(index);\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `}return e}};function WH(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var UH={kernelName:pn,backendName:"webgpu",kernelFunc:WH};function VH(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),o=n.tensorMap.get(s.dataId),i=WH({inputs:{x:r},backend:n}),l=WH({inputs:{x:a},backend:n});return o.complexTensorInfos={real:i,imag:l},s}var jH={kernelName:St,backendName:"webgpu",kernelFunc:VH},GH=class{constructor(e,t){this.variableNames=["A"],this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=t,this.shaderKey=`unary_${t}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${eH(this.op,!1)}\n      }\n      ${lH()}\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}};function HH({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:r,backend:a})=>{const{x:s}=r,o=a,i=n||s.dtype;if(o.shouldExecuteOnCPU([s])&&null!=t){const e=o.tensorMap.get(s.dataId),n=t(e.values,i);return o.makeTensorInfo(s.shape,i,n)}const l=new GH(s.shape,e);return o.runWebGPUProgram(l,[s],i)}}function qH({opType:e,cpuKernelImpl:t,supportsComplex:n=!1,dtype:r}){return({inputs:a,backend:s})=>{const{a:o,b:i}=a,l=s;if(n&&"complex64"===o.dtype){const t=l.tensorMap.get(o.dataId),n=l.tensorMap.get(i.dataId);let r,a;if(e!==GG.MUL)[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:o.shape},s={dataId:r.dataId,dtype:r.dtype,shape:i.shape},u=new BH(e,o.shape,i.shape);return l.runWebGPUProgram(u,[a,s],fs(n.dtype,r.dtype))}));else{const e=new LH(GG.COMPLEX_MULTIPLY_REAL,o.shape,i.shape),s=new LH(GG.COMPLEX_MULTIPLY_IMAG,o.shape,i.shape),u=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:i.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:i.shape}];r=l.runWebGPUProgram(e,u,"float32"),a=l.runWebGPUProgram(s,u,"float32")}const s=VH({inputs:{real:r,imag:a},backend:l});return l.disposeData(r.dataId),l.disposeData(a.dataId),s}const u=r||fs(o.dtype,i.dtype);if(("string"===o.dtype||"string"===i.dtype||l.shouldExecuteOnCPU([o,i]))&&null!=t){const e=l.tensorMap.get(o.dataId).values,n=l.tensorMap.get(i.dataId).values,r="string"===o.dtype?ff.fromUint8ToStringArray(e):e,a="string"===o.dtype?ff.fromUint8ToStringArray(n):n,[s,c]=t(o.shape,i.shape,r,a,u);return l.makeTensorInfo(c,u,s)}const c=new BH(e,o.shape,i.shape);return l.runWebGPUProgram(c,[o,i],u)}}var{addImpl:XH,ceilImpl:KH,concatImpl:ZH,equalImpl:YH,expImpl:JH,expm1Impl:QH,floorImpl:eq,gatherNdImpl:tq,gatherV2Impl:nq,greaterEqualImpl:rq,greaterImpl:aq,lessEqualImpl:sq,lessImpl:oq,logImpl:iq,maxImpl:lq,maximumImpl:uq,minimumImpl:cq,multiplyImpl:dq,negImpl:hq,notEqualImpl:pq,prodImpl:fq,rangeImpl:mq,rsqrtImpl:Aq,scatterImpl:gq,simpleAbsImpl:yq,sliceImpl:xq,stridedSliceImpl:bq,stringNGramsImpl:vq,subImpl:wq,tileImpl:kq,topKImpl:Sq,transposeImpl:Iq,uniqueImpl:Cq}=wE,Eq=HH({opType:XG.ABS,cpuKernelImpl:yq}),Nq={kernelName:Je,backendName:"webgpu",kernelFunc:Eq},Tq=qH({opType:GG.ADD,cpuKernelImpl:XH,supportsComplex:!0}),Rq={kernelName:tt,backendName:"webgpu",kernelFunc:Tq};var _q={kernelName:nt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;if(1===r.length)return WH({inputs:{x:r[0]},backend:n});const a=r.map((e=>e.dtype)).reduce(((e,t)=>fs(e,t))),s=r.map((e=>e.shape)),o=new class{constructor(e){this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)}));const t=this.variableNames.map((e=>`v${e}`)).join(" + ");return`\n      ${lH()}\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}(s);return n.runWebGPUProgram(o,r,a)}},Mq=class{constructor(e,t,n){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[t];ff.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,e.length),this.op="min"===n?"<":">";const[a]=ff.computeOutAndReduceShapes(e,r);this.outputShape=0===a.length?[1]:a,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,[1,1,1]),this.inputShape=e,this.shaderKey=`argMinMax${this.op}`}getUserCode(){return`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${`\n      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;\n      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;\n    `}\n\n      ${lH()}\n        let outputIndex = index / i32(workGroupSizeX);\n        let reduceLength = ${(()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${iH(this.inputShape.length-1)}`)()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + i32(workGroupSizeX)) {\n          let candidate = getX(${(()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${iH(t)},`;return e})()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), workGroupSizeX);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `}};function $q(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,o=n,i=a.shape.length,l=new Array(i);for(let e=0;e<l.length;e++)l[e]=a.shape[s[e]];if(n.shouldExecuteOnCPU([a])){const e=o.tensorMap.get(a.dataId).values,t=Iq(e,a.shape,a.dtype,s,l);return n.makeTensorInfo(l,a.dtype,t)}if(2===a.shape.length&&wa.arraysEqual(s,[1,0])){const e=new class{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[16,16,1];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`\n      const TILE_DIM = ${this.workGroupSize[0]};\n      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn main(@builtin(local_invocation_id) localId : vec3<u32>,\n              @builtin(workgroup_id) workgroupId : vec3<u32>) {\n        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);\n        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = A[y * width + x];\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);\n        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}(a.shape,s);return o.runWebGPUProgram(e,[a],a.dtype)}const u=new class{constructor(e,t){this.variableNames=["A"],this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=oH(this.outputShape.length),t=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]=`resRC.${iH(t)}`;return n.join()}(this.newDim);return`\n      ${lH()}\n\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}(a.shape,s);return o.runWebGPUProgram(u,[a],a.dtype)}var Fq={kernelName:Yr,backendName:"webgpu",kernelFunc:$q};var Oq={kernelName:st,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=wa.parseAxisParam(s,a.shape);const i=ff.getAxesPermutation(o,a.shape.length);let l=a;const u=[];null!=i&&(l=$q({inputs:{x:a},backend:n,attrs:{perm:i}}),u.push(l),o=ff.getInnerMostAxes(o.length,l.shape.length)),ff.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);const c=new Mq(l.shape,o[0],"max"),d=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],h=n.runWebGPUProgram(c,[l],"int32",d);return u.forEach((e=>n.disposeData(e.dataId))),h}};var Dq={kernelName:ot,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let o=wa.parseAxisParam(s,a.shape);const i=ff.getAxesPermutation(o,a.shape.length);let l=a;const u=[];null!=i&&(l=$q({inputs:{x:a},backend:n,attrs:{perm:i}}),u.push(l),o=ff.getInnerMostAxes(o.length,l.shape.length)),ff.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);const c=new Mq(l.shape,o[0],"min"),d=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],h=n.runWebGPUProgram(c,[l],"int32",d);return u.forEach((e=>n.disposeData(e.dataId))),h}},zq=class{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";"avg"===this.poolType&&(t="resultValue / count");return`\n      ${lH()}\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              ${e}\n            }\n          }\n\n          setOutputAtIndex(index, ${t});\n        }\n      }\n    `}},Pq=class{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${lH()}\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}};var Lq={kernelName:ht,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r,u=ff.computePool2DInfo(a.shape,s,o,1,i,l);if(1===u.filterWidth&&1===u.filterHeight&&wa.arraysEqual(u.inShape,u.outShape))return WH({inputs:{x:a},backend:n});let c;const d=[{type:"int32",data:[u.strideHeight,u.strideWidth]}];return 1===u.filterHeight&&1===u.filterWidth?c=new Pq(u):(c=new zq(u,"avg"),d.push({type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]})),n.runWebGPUProgram(c,[a],a.dtype,d)}};var Bq={kernelName:At,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:o,transposeB:i}=r;return zH({a:a,b:s,transposeA:o,transposeB:i,backend:n})}},Wq=["x","y","z","w","u","v"];function Uq(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:o}=r,[i,l]=Qi.parseSliceParams(a,s,o);if(Qi.assertParamsValid(a,i,l),n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.tensorMap.get(a.dataId),t=xq(e.values,i,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}if(0===wa.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);const u=new class{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${oH(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=oH(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return Wq.slice(0,e).map((e=>`sourceLoc.${e}`)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;return n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${Wq[t]} = uniforms.start[${t}] + coords.${Wq[t]};`)),`\n      ${lH()}\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}(i,l),c=[{type:"int32",data:i}];return n.runWebGPUProgram(u,[a],a.dtype,c)}var Vq={kernelName:kr,backendName:"webgpu",kernelFunc:Uq},jq={kernelName:gt,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:o}=r;wa.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),l=ff.getReshaped(a.shape,s,i),u=ff.getPermuted(l.length,s.length),c=ff.getReshapedPermuted(a.shape,s,i),d=ff.getSliceBeginCoords(o,s.length),h=ff.getSliceSize(c,o,s.length),p=[],f=OH({inputs:{x:a},backend:n,attrs:{shape:l}}),m=$q({inputs:{x:f},backend:n,attrs:{perm:u}}),A=OH({inputs:{x:m},backend:n,attrs:{shape:c}}),g=Uq({inputs:{x:A},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(A),p.forEach((e=>n.disposeData(e.dataId))),g}},Gq=qH({opType:GG.NOT_EQUAL,dtype:"bool",cpuKernelImpl:pq}),Hq={kernelName:Xn,backendName:"webgpu",kernelFunc:Gq};function qq(e){const{inputs:t,backend:n}=e,{input:r}=t;return WH({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.real},backend:n})}var Xq={kernelName:ir,backendName:"webgpu",kernelFunc:qq};var Kq={kernelName:vt,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:o}=a;if("complex64"===o){if("complex64"===s.dtype)return WH({inputs:{x:s},backend:r});const t=dd(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=VH({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeData(n.dataId),a}if("complex64"===s.dtype){const t=qq({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:o}});return r.disposeData(t.dataId),n}if(!wa.hasEncodingLoss(s.dtype,o)){const e=WH({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:o}}if("int32"===o)return function(e,t){const n=new GH(e.shape,XG.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===o){const e=r.makeTensorInfo([],"bool",wa.getTypedArrayFromDType("bool",1)),t=Gq({inputs:{a:s,b:e},backend:r});return r.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},Zq=HH({opType:XG.CEIL,cpuKernelImpl:KH}),Yq={kernelName:wt,backendName:"webgpu",kernelFunc:Zq};var Jq={kernelName:kt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:o}=r;let i;const l=[{type:"float32",data:[s]},{type:"float32",data:[o]}];return i=wa.sizeFromShape(a.shape)%4==0?new class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workGroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${lH()}\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue : vec4<f32>;\n          for (var i = 0; i < 4; i = i + 1) {\n            if (isnan(value[i])) {\n              clampedValue[i] = value[i];\n            } else {\n              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);\n            }\n          }\n\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}(a.shape):new class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${lH()}\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}(a.shape),n.runWebGPUProgram(i,[a],a.dtype,l)}};function Qq(e){const{inputs:t,backend:n}=e,{input:r}=t;return WH({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:n})}var eX={kernelName:mn,backendName:"webgpu",kernelFunc:Qq};function tX(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>qq({inputs:{input:e},backend:n}))),a=e.map((e=>Qq({inputs:{input:e},backend:n}))),s=tX(r,t,n),o=tX(a,t,n),i=VH({inputs:{real:s,imag:o},backend:n});return r.forEach((e=>n.disposeData(e.dataId))),a.forEach((e=>n.disposeData(e.dataId))),n.disposeData(s.dataId),n.disposeData(o.dataId),i}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=wa.sizeFromShape(e.shape.slice(t));return OH({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=ff.computeOutShape(a.map((e=>e.shape)),1),i=1===a[0].shape[0],l=ZH(s,o,r,i),u=ff.computeOutShape(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeData(e.dataId))),c}const s=n.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>s){const r=[];for(let a=0;a<e.length;a+=s){const o=e.slice(a,a+s);r.push(tX(o,t,n))}const a=tX(r,t,n);for(const e of r)n.disposeData(e.dataId);return a}const{tensors2D:o,outShape:i}=function(e,t,n){const r=ff.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>OH({inputs:{x:e},backend:n,attrs:{shape:[wa.sizeFromShape(e.shape.slice(0,t)),wa.sizeFromShape(e.shape.slice(t))]}}))),outShape:r}}(e,t,n),l=o.map((e=>e.shape)),u=new class{constructor(e){this.uniforms="",this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=ff.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${lH()}\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}(l),c=[],d=new Array(l.length-1);if(d.length>0){d[0]=l[0][1],c.push({type:"int32",data:[d[0]]});for(let e=1;e<d.length;e++)d[e]=d[e-1]+l[e][1],c.push({type:"int32",data:[d[e]]})}const h=n.runWebGPUProgram(u,o,o[0].dtype,c);o.forEach((e=>n.disposeData(e.dataId)));const p=OH({inputs:{x:h},backend:n,attrs:{shape:i}});return n.disposeData(h.dataId),p}function nX(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=wa.parseAxisParam(a,t[0].shape)[0],o=ff.computeOutShape(t.map((e=>e.shape)),s);if(0===wa.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>wa.sizeFromShape(e.shape)>0));if(1===i.length)return WH({inputs:{x:i[0]},backend:n});const l=i.map((e=>e.shape));return ff.assertParamsConsistent(l,s),tX(i,s,n)}var rX={kernelName:Ct,backendName:"webgpu",kernelFunc:nX};function aX(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function sX({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const l=null!=a,u=null!=s,c="channelsLast"===n.dataFormat;if(c&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type||1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return function({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const l="channelsLast"===n.dataFormat,u=!l,c=[];let d,h;if(l&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const a=n.inHeight*n.inWidth*n.inChannels;d=OH({inputs:{x:e},backend:r,attrs:{shape:[1,n.batchSize,a]}}),h=OH({inputs:{x:t},backend:r,attrs:{shape:[1,a,n.outChannels]}})}else d=OH({inputs:{x:e},backend:r,attrs:{shape:l?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),h=OH({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(c.push(d),c.push(h),null!=s){const e=aX(s.shape,l);null!=e&&(s=OH({inputs:{x:s},backend:r,attrs:{shape:e}}),c.push(s))}if(null!=a){const e=aX(a.shape,l);null!=e&&(a=OH({inputs:{x:a},backend:r,attrs:{shape:e}}),c.push(a))}const p=zH({a:l?d:h,b:l?h:d,transposeA:u,transposeB:!1,backend:r,bias:a,activation:i,preluActivationWeights:s,leakyreluAlpha:o}),f=OH({inputs:{x:p},backend:r,attrs:{shape:n.outShape}});c.push(p);for(const e of c)r.disposeData(e.dataId);return f}({x:e,filter:t,convInfo:n,backend:r,bias:a,activation:i,preluActivationWeights:s,leakyreluAlpha:o});const d=c?n.outHeight*n.outWidth:n.outChannels,h=c?n.outChannels:n.outHeight*n.outWidth,p=n.filterHeight*n.filterWidth*n.inChannels,f=[n.padInfo.top,n.padInfo.left],m=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...f]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]},{type:"int32",data:[d]},{type:"int32",data:[h]},{type:"int32",data:[p]}],A=new class{constructor(e,t,n,r,a=!1,s=null,o=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workGroupSize=wH(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=SH(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),a&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),o&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.addBias=a,this.activation=s,this.hasPreluActivationWeights=o,this.tileAOuter=this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workGroupSize[0]*this.innerElementSize,this.workGroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=r%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}`}getUserCode(){const e=this.isVec4?MH(this.elementsPerThread,this.tileAOuter,this.tileBOuter,this.tileInner,this.innerElementSize,!this.isChannelsLast):_H(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner),t=this.isVec4?[this.isChannelsLast?this.innerElementSize:4,4,4]:[1,1,1];return`\n    ${function(e,t,n,r,a=!1,s=null,o=!1,i=4,l=4,u=4){const c=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",d=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",h=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",A=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${tH(i)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${h} && xCol >= 0 && xCol < ${p}) {\n        ${c}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(i)}\n      }\n      return resData;`,g=e?t&&r?`\n      let col = colIn * ${i};\n      ${A}`:`\n      let col = colIn * ${i};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${A}\n      }\n      return ${tH(i)}(0.0);`:r&&n?`\n      let col = colIn * ${i};\n      ${A}`:`\n      let col = colIn * ${i};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${A}\n      }\n      return ${tH(i)}(0.0);`,y=`${(e=>{switch(e){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(l)}`,x=tH(u),b=tH(e?i:l),v=tH(e?l:i);return`\n      ${nH(s,o,4===u,4)}\n      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${b} {\n        ${e?g:y}\n      }\n\n      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${v} {\n        ${e?y:g}\n      }\n\n      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${x}) {\n        let col = colIn * ${u};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${d}\n        ${rH(a,s)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `}}(n,d,h,p,l,i,u),g=[],y=[e,t];l&&(c||1!==a.shape.length||(a=OH({inputs:{x:a},backend:r,attrs:{shape:[a.shape[0],1,1]}}),g.push(a)),y.push(a)),u&&(c||1!==s.shape.length||(s=OH({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),g.push(s)),y.push(s)),"leakyrelu"===i&&(m.push({type:"float32",data:[o]}),A.uniforms+=" alpha : f32,");const x=r.runWebGPUProgram(A,y,e.dtype,m);for(const e of g)r.disposeData(e.dataId);return x}var oX={kernelName:Et,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=n,d=ff.convertConv2DDataFormat(l);return sX({x:a,filter:s,convInfo:ff.computeConv2DInfo(a.shape,s.shape,o,u,i,c,!1,d),backend:r})}};var iX,lX={kernelName:Tt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:o,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=ff.convertConv2DDataFormat(u),h=ff.computeConv2DInfo(o,s.shape,i,1,l,c,!1,d),p=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.batchSize,h.outHeight,h.outWidth,h.outChannels]}];let f;if(qe().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE"))f=new class{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`\n    ${lH()} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}]), coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = dyR;\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = dyC;\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if (${this.isChannelsLast}) {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}(h);else{f=new class{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,wa.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=wH(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=SH(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4?(this.innerElementSize=4,this.variableTypes=["vec4<f32>","f32"]):this.innerElementSize=this.elementsPerThread[0],this.tileAOuter=this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workGroupSize[0]*this.innerElementSize,this.workGroupSize[1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}_${this.innerElementSize}`}getUserCode(){const e=this.isVec4?MH(this.elementsPerThread,this.tileAOuter,this.tileBOuter,this.tileInner,this.innerElementSize):_H(this.elementsPerThread,this.workGroupSize);return`\n    ${function(e=4){const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${tH(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${tH(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];\n      }\n      return ${tH(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${tH(e)} {\n    let col = colIn * ${e};\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${tH(e)} {\n    let col = colIn * ${e};\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${tH(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${tH(e)}) {\n    let col = colIn * ${e};\n    if (row < uniforms.dimAOuter && (col + ${e-1}) < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}(h);const e=h.inShape[1]*h.inShape[2],t=h.inShape[3],n=h.filterHeight*h.filterWidth*h.outChannels;p.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(f,[a,s],"float32",p)}},uX=HH({opType:XG.COS}),cX={kernelName:$t,backendName:"webgpu",kernelFunc:uX},dX=HH({opType:XG.COSH}),hX={kernelName:Ft,backendName:"webgpu",kernelFunc:dX},pX={kernelName:zt,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:o}=t,{cropSize:i,method:l,extrapolationValue:u}=r,c=new class{constructor(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workGroupSize=[64,1,1],this.size=!0;const[a]=t;this.outputShape=[a,n[0],n[1],e],this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,a]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[s,o,i]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`\n      ${lH()}\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${s});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${r};\n        let width_scale = ${o};\n        let in_y = ${a};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${i};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}(a.shape[3],s.shape,i,l),d=[{type:"float32",data:[u]}];return n.runWebGPUProgram(c,[a,s,o],"float32",d)}};!function(e){e.Prod="*",e.Sum="+"}(iX||(iX={}));var fX=class{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===iX.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${mX(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let a="",s="";return this.exclusive?(a=this.reverse?"end != "+(r-1):"end != 0",s=this.reverse?"end + 1":"end - 1"):(a=this.reverse?`end + pow2 < ${r}`:"end >= pow2",s=this.reverse?"end + pow2":"end - pow2"),`\n      ${lH()}\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${AX(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${a}) {\n           let idx = ${s};\n           ${AX(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${mX(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}};function mX(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function AX(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function gX(e,t,n,r,a,s){const o=t.shape.length,i=ff.getAxesPermutation([r],o);let l=t;null!=i&&(l=$q({inputs:{x:t},backend:n,attrs:{perm:i}}));const u=ff.getInnerMostAxes(1,o)[0];if(u!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=WH({inputs:{x:l},backend:n});for(let t=0;t<=Math.ceil(Math.log2(c))-1;t++){const r=new fX(e,l.shape,!1,s),a=d,o=[{type:"float32",data:[t]}];d=n.runWebGPUProgram(r,[d],d.dtype,o),n.disposeData(a.dataId)}if(a){const t=new fX(e,l.shape,a,s),r=d,o=[{type:"float32",data:[0]}];d=n.runWebGPUProgram(t,[d],d.dtype,o),n.disposeData(r.dataId)}if(null!=i){const e=$q({inputs:{x:d},backend:n,attrs:{perm:ff.getUndoAxesPermutation(i)}});return n.disposeData(d.dataId),n.disposeData(l.dataId),e}return d}var yX={kernelName:Ot,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;return gX(iX.Prod,a,n,s,o,i)}};var xX={kernelName:Dt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;return gX(iX.Sum,a,n,s,o,i)}};var bX={kernelName:Lt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:o}=r,i=a.shape[0],l=("NHWC"===o?a.shape[1]:a.shape[2])*s,u=("NHWC"===o?a.shape[2]:a.shape[3])*s,c=("NHWC"===o?a.shape[3]:a.shape[1])/(s*s),d="NHWC"===o?[i,l,u,c]:[i,c,l,u],h=[{type:"int32",data:[s]}],p=new class{constructor(e,t){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`\n      ${lH()}\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}(d,o);return n.runWebGPUProgram(p,[a],a.dtype,h)}},vX=class{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[4,4,4],this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[4,4,1]),wa.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}`}getUserCode(){const e=4+this.convInfo.filterWidth-1;return`\n      ${nH(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn main(@builtin(global_invocation_id) globalId: vec3<u32>) {\n        let batch = i32(globalId.z) / uniforms.outShape[1];\n        let r = i32(globalId.z) % uniforms.outShape[1];\n        let c = i32(globalId.y) * 4;\n        let d1 = i32(globalId.x) * 4;\n        let xRCCorner = vec2<i32>(r, c) - uniforms.pad;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, 4>;\n        dotProd[0] = vec4<f32>(0.0);\n        dotProd[1] = vec4<f32>(0.0);\n        dotProd[2] = vec4<f32>(0.0);\n        dotProd[3] = vec4<f32>(0.0);\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          for (var i = 0; i < ${e}; i++)\n          {\n            xVals[i] = readX(batch, xR, xCCorner + i, d1);\n          }\n          for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n            let wValue = getW(wR, wC, d1, 0);\n            dotProd[0] = dotProd[0] + xVals[0 + wC] * wValue;\n            dotProd[1] = dotProd[1] + xVals[1 + wC] * wValue;\n            dotProd[2] = dotProd[2] + xVals[2 + wC] * wValue;\n            dotProd[3] = dotProd[3] + xVals[3 + wC] * wValue;\n          }\n        }\n\n        for (var i = 0; i < 4; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${rH(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}},wX=class{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,",this.workGroupSize=[256,1,1],this.outputShape=e.outShape,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${nH(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${uH()}\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;\n        let d2 = coords[${this.isChannelsLast?3:1}];\n        let channelMul = uniforms.wShape[3];\n        let d1 = d2 / channelMul;\n        let q = d2 % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n        let inputRowEnd = inputRowStart + uniforms.filterHeight *\n            uniforms.dilation[0];\n        let inputColEnd = inputColStart + uniforms.filterWidth *\n            uniforms.dilation[1];\n\n        // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n        // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n        // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n        // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n        var value = 0.0;\n\n        // Extract if checking out of for loop for performance.\n        if (inputRowStart >= 0 && inputColStart >= 0 &&\n          inputRowEnd < uniforms.inDims[0] &&\n              inputColEnd < uniforms.inDims[1]) {\n            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                let xVal = ${e};\n                let wVal = getW(wR, wC, d1, q);\n                value = value + xVal * wVal;\n              }\n            }\n          } else {\n            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              if (xR < 0 || xR >= uniforms.inDims[0]) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                if (xC < 0 || xC >= uniforms.inDims[1]) {\n                  continue;\n                }\n\n                let xVal = ${e};\n                let wVal = getW(wR, wC, d1, q);\n                value = value + xVal * wVal;\n              }\n            }\n          }\n          ${rH(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}};var kX={kernelName:Bt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:o,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=ff.convertConv2DDataFormat(l);let h=u;null==h&&(h=[1,1]);const p=ff.computeConv2DInfo(a.shape,s.shape,o,h,i,c,!0,d),f=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],m="channelsLast"===p.dataFormat;let A;return!m&&p.inHeight>16&&p.inWidth>16&&1===p.strideHeight&&1===p.strideWidth&&1===p.dilationWidth&&1===p.dilationHeight&&p.inChannels===p.outChannels?A=new class{constructor(e,t,n,r=!1,a=null,s=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),r&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=a,this.hasPreluActivation=s,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workGroupSize[0]*this.workGroupSize[1]*this.workGroupSize[2],n=this.workGroupSize[1]+this.filterHeight-1,r=this.workGroupSize[0]+this.filterWidth-1;return`\n      ${nH(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n              @builtin(global_invocation_id) GlobalId : vec3<u32>,\n              @builtin(local_invocation_index) LocalIndex: u32,\n              @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n        localId = LocalId;\n        globalId = GlobalId;\n        let localIndex = i32(LocalIndex);\n        numWorkgroups = NumWorkgroups;\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workGroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workGroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = localIndex;\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${rH(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}(p.outShape,p.filterHeight,p.filterWidth):m&&p.inHeight>4&&p.inWidth>4&&1===p.strideHeight&&1===p.strideWidth&&p.inChannels===p.outChannels&&1===p.dilationHeight&&1===p.dilationWidth&&p.inChannels%4==0?A=new vX(p):(A=new wX(p),f.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),n.runWebGPUProgram(A,[a,s],a.dtype,f)}},SX=qH({opType:GG.MUL,cpuKernelImpl:dq,supportsComplex:!0}),IX={kernelName:Hn,backendName:"webgpu",kernelFunc:SX};function CX(e,t,n,r,a){const s=e.shape.length,o=[],i=wa.parseAxisParam(t,e.shape);let l=i;const u=ff.getAxesPermutation(l,s);let c=e;null!=u&&(c=$q({inputs:{x:e},attrs:{perm:u},backend:a}),l=ff.getInnerMostAxes(l.length,s),o.push(c)),ff.assertAxesAreInnerMostDims(r,l,s);const[d,h]=ff.computeOutAndReduceShapes(c.shape,l);let p,f=d;if(n&&(f=ff.expandShapeToKeepDim(d,i)),"max"!==r&&"prod"!==r||!a.shouldExecuteOnCPU([c])){const t=wa.sizeFromShape(h),n={windowSize:t,inSize:t,batchSize:wa.sizeFromShape(c.shape)/t,outSize:1},s="mean"===r?"float32":ms(e.dtype),i=[{type:"int32",data:[t]}],l=new class{constructor(e,t){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[n]=ff.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===n.length?[1]:n,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType&&(e=" bestValue = bestValue * candidate; ",t="1.0");const n="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       \n         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;\n       \n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${lH()}\n         let outputIndex = index / i32(workGroupSizeX);\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + i32(workGroupSizeX)) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), workGroupSizeX);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${n}\n        }\n       }\n     `}}(n,r),u=a.runWebGPUProgram(l,[c],s,i);o.push(u),p=OH({inputs:{x:u},attrs:{shape:f},backend:a})}else{const t=a.tensorMap.get(c.dataId).values;switch(r){case"max":const n=lq(t,wa.sizeFromShape(h),f,e.dtype);p=a.makeTensorInfo(f,e.dtype,n);break;case"prod":const{outVals:s,outShape:o,outDtype:i}=fq(c.shape,c.dtype,t,l);p=a.makeTensorInfo(o,i,s);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}return o.forEach((e=>a.disposeData(e.dataId))),p}function EX(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;return CX(a,s,o,"sum",n)}var NX={kernelName:Rr,backendName:"webgpu",kernelFunc:EX};var TX={kernelName:Xt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:o,summedDims:i,idDims:l}=ff.decodeEinsumEquation(a,s.length);ff.checkEinsumDimSizes(o.length,l,s);const{path:u,steps:c}=ff.getEinsumComputePath(i,l),d=c.length;let h=null,p=o.length;const f=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:r}=ff.getEinsumPermutation(p,l[t]);let a;ff.isIdentityPermutation(e)?a=s[t]:(a=$q({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(a));const o=a.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);wa.arraysEqual(a.shape,o)||(a=OH({inputs:{x:a},backend:n,attrs:{shape:o}}),f.push(a)),null===h?h=a:(h=SX({inputs:{a:a,b:h},backend:n}),f.push(h))}e<d-1&&(u[e]>=0&&(h=EX({inputs:{x:h},backend:n,attrs:{axis:u[e]-(o.length-p),keepDims:!1}}),f.push(h)),p--)}for(const e of f)e!==h&&n.disposeData(e.dataId);return h}},RX=HH({opType:XG.ELU}),_X={kernelName:Kt,backendName:"webgpu",kernelFunc:RX},MX=qH({opType:GG.EQUAL,dtype:"bool",cpuKernelImpl:YH}),$X={kernelName:Jt,backendName:"webgpu",kernelFunc:MX},FX=HH({opType:XG.EXP,cpuKernelImpl:JH,dtype:"float32"}),OX={kernelName:Qt,backendName:"webgpu",kernelFunc:FX};function DX(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,o=s.shape.length,i=s.shape.slice();let l=a;return a<0&&(wa.assert(-(o+1)<=a,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+a+1),i.splice(l,0,1),OH({inputs:{x:s},backend:r,attrs:{shape:i}})}var zX,PX={kernelName:en,backendName:"webgpu",kernelFunc:DX},LX=HH({opType:XG.EXPM1,cpuKernelImpl:QH}),BX={kernelName:tn,backendName:"webgpu",kernelFunc:LX},WX={kernelName:an,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,a=new class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${lH()}\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}(n.shape);return r.runWebGPUProgram(a,[n],n.dtype)}},UX=HH({opType:XG.FLOOR,cpuKernelImpl:eq}),VX={kernelName:sn,backendName:"webgpu",kernelFunc:UX},jX=qH({opType:GG.INT_DIV,dtype:"int32"}),GX={kernelName:on,backendName:"webgpu",kernelFunc:jX},HX={kernelName:aa,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:s}=r;if(null==a)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,i="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&a instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&a instanceof OffscreenCanvas,u="undefined"!=typeof ImageBitmap&&a instanceof ImageBitmap,[c,d]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],h=[d,c,s],p=qe().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&o,f=o||i;if(u||l||f){let e;if(p){const t=a;if(!qX.has(t)||qX.get(t).expired){const e={source:t};qX.set(t,n.device.importExternalTexture(e))}e={width:c,height:d,format:null,usage:null,texture:qX.get(t)}}else{f&&(null==zX&&(zX=document.createElement("canvas").getContext("2d")),zX.canvas.width=c,zX.canvas.height=d,zX.drawImage(a,0,0,c,d),a=zX.canvas);const t=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,r="rgba8unorm",s=n.textureManager.acquireTexture(h[1],h[0],r,t);n.queue.copyExternalImageToTexture({source:a},{texture:s},[h[1],h[0]]),e={width:c,height:d,format:r,usage:t,texture:s}}const t=wa.sizeFromShape(h),r=wa.computeStrides(h),o=new class{constructor(e,t,n=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[t,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${lH()}\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}(h,s,p),i=[{type:"uint32",data:[t]},{type:"uint32",data:[s]},{type:"uint32",data:[...r]}],l=n.makeTensorInfo([d,c],"int32");n.tensorMap.get(l.dataId).resourceInfo=e;const u=n.runWebGPUProgram(o,[l],"int32",i);return n.disposeData(l.dataId),u}const m=a.data;let A=m;if(null!=s&&4!==s){A=new Uint8Array(a.width*a.height*s);const e=m.length;let t=0;for(let n=0;n<e;n++)n%4<s&&(A[t++]=m[n])}const g=n.makeTensorInfo(h,"int32",new Int32Array(A));return n.uploadToGPU(g.dataId),g}},qX=new Map;var XX={kernelName:ln,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r,scale:a,offset:s,mean:o,variance:i}=e,{varianceEpsilon:l}=t,u=n,c=[r,o,i];let d=null;null!=s&&(d=s.shape,c.push(s));let h=null;null!=a&&(h=a.shape,c.push(a));const p=new class{constructor(e,t,n,r,a){this.uniforms="varianceEpsilon : f32,",this.workGroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],ff.assertAndGetBroadcastShape(e,t),ff.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),null!=r&&(ff.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset")),null!=a&&(ff.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=a,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";return null!=this.scaleShape&&(t="getScaleByOutputIndex(index)"),`\n      ${lH()}\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}(r.shape,o.shape,i.shape,d,h),f=[{type:"float32",data:[l]}];return u.runWebGPUProgram(p,c,r.dtype,f)}};var KX={kernelName:ia,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=ff.convertConv2DDataFormat(c);return sX({x:a,filter:s,convInfo:ff.computeConv2DInfo(a.shape,s.shape,l,d,u,h,!1,m),backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:f,activation:p})}};var ZX={kernelName:la,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r;let f=c;null==f&&(f=[1,1]),wa.assert(ff.eitherStridesOrDilationsAreOne(l,f),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${f}'`));const m=ff.computeConv2DInfo(a.shape,s.shape,l,f,u,d,!0),A=[a,s],g=null!=o,y=null!=i;g&&A.push(o),y&&A.push(i);const x=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}];let b;return m.inHeight>4&&m.inWidth>4&&1===m.strideHeight&&1===m.strideWidth&&m.inChannels===m.outChannels&&1===m.dilationHeight&&1===m.dilationWidth&&m.inChannels%4==0?b=new vX(m,g,h,y):(b=new wX(m,g,h,y),x.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),"leakyrelu"===h&&(x.push({type:"float32",data:[p]}),b.uniforms+=" alpha : f32,"),n.runWebGPUProgram(b,A,"float32",x)}};var YX={kernelName:cn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,o=s[s.length-1],i=wa.sizeFromShape(r.shape),[l,u,c,d]=ff.prepareAndValidate(r,a),h=OH({inputs:{x:a},backend:n,attrs:{shape:[u,o]}}),p=OH({inputs:{x:r},backend:n,attrs:{shape:[wa.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),s=tq(e,t,r.dtype,u,o,c,d,r.shape,i);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new class{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${oH(e)},`}getUserCode(){let e;return e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides",`\n        ${lH()}\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}(o,[u,c]),m=[{type:"int32",data:[o]},{type:"int32",data:d}],A=n.runWebGPUProgram(f,[p,h],p.dtype,m),g=OH({inputs:{x:A},backend:n,attrs:{shape:l}});return n.disposeData(h.dataId),n.disposeData(p.dataId),n.disposeData(A.dataId),g}};function JX(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:o,batchDims:i}=r,l=wa.parseAxisParam(o,a.shape)[0],u=ff.segment_util.collectGatherOpShapeInfo(a,s,l,i),c=wa.sizeFromShape(s.shape),d=[],h=OH({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=OH({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])){const e=n.tensorMap.get(p.dataId).values,t=Do(p.shape,p.dtype,e),r=n.tensorMap.get(h.dataId).values,a=Do(h.shape,h.dtype,r),s=nq(a,t,f);return d.forEach((e=>n.disposeData(e.dataId))),n.makeTensorInfo(u.outputShape,s.dtype,s.values)}const m=new class{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("indexZ"):n.push(`${t[r]}`);return n.join()}(this.aShape);return`\n      ${lH()}\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}(h.shape,f),A=n.runWebGPUProgram(m,[h,p],h.dtype);d.push(A);const g=OH({inputs:{x:A},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeData(e.dataId))),g}var QX={kernelName:un,backendName:"webgpu",kernelFunc:JX},eK=qH({opType:GG.GREATER,cpuKernelImpl:aq,dtype:"bool"}),tK={kernelName:dn,backendName:"webgpu",kernelFunc:eK},nK=qH({opType:GG.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:rq}),rK={kernelName:hn,backendName:"webgpu",kernelFunc:nK};var aK={kernelName:xn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,o=[{type:"float32",data:[s]}],i=new GH(a.shape,XG.LEAKYRELU);return i.uniforms="alpha : f32,",n.runWebGPUProgram(i,[a],"float32",o)}},sK=qH({opType:GG.LESS,dtype:"bool",cpuKernelImpl:oq}),oK={kernelName:bn,backendName:"webgpu",kernelFunc:sK},iK=qH({opType:GG.LESS_EQUAL,dtype:"bool",cpuKernelImpl:sq}),lK={kernelName:vn,backendName:"webgpu",kernelFunc:iK},uK=HH({opType:XG.LOG,cpuKernelImpl:iq}),cK={kernelName:kn,backendName:"webgpu",kernelFunc:uK},dK=qH({opType:GG.LOGICAL_AND,dtype:"bool"}),hK={kernelName:In,backendName:"webgpu",kernelFunc:dK},pK=HH({opType:XG.LOGICAL_NOT}),fK={kernelName:Cn,backendName:"webgpu",kernelFunc:pK};function mK(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:o}=r;return CX(a,s,o,"max",n)}var AK={kernelName:$n,backendName:"webgpu",kernelFunc:mK},gK=qH({opType:GG.MAX,cpuKernelImpl:uq}),yK={kernelName:Fn,backendName:"webgpu",kernelFunc:gK};var xK={kernelName:On,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:l}=r,u=ff.computePool2DInfo(a.shape,s,o,1,i,l);let c;const d=[];if(1===u.filterHeight&&1===u.filterWidth){if(wa.arraysEqual(u.inShape,u.outShape))return WH({inputs:{x:a},backend:n});c=new Pq(u),d.push({type:"int32",data:[u.strideHeight,u.strideWidth]})}else c=new zq(u,"max"),d.push({type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]});return n.runWebGPUProgram(c,[a],a.dtype,d)}};var bK={kernelName:Bn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{keepDims:s,axis:o}=r;return CX(a,o,s,"mean",n)}};var vK={kernelName:Wn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;return CX(a,s,o,"min",n)}},wK=qH({opType:GG.MIN,cpuKernelImpl:cq}),kK={kernelName:Un,backendName:"webgpu",kernelFunc:wK},SK={kernelName:Vn,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{paddings:a,mode:s}=t,o=n,i=a.map((e=>({type:"int32",data:[e[0],e[1]]}))),l=new class{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),r=1===e?"start":"start[i]",a=1===e?"end":"end[i]",s=1===e?"outC":"outC[i]",o=oH(e),i=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${lH()}\n        if (index < uniforms.size) {\n          let start = ${o}(${t});\n          let end = ${o}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${s} < ${r}) {\n              ${s} = ${r} * 2 - ${s} - ${this.offset};\n            } else if(${s} >= ${a}) {\n              ${s} = (${a} - 1) * 2 - ${s} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${i}));\n        }\n      }\n    `}}(r.shape,a,s);return o.runWebGPUProgram(l,[r],r.dtype,i)}};var IK={kernelName:qn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.tensorMap.get(r.dataId),[t,a]=hq(e.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,t)}const a=new GH(r.shape,XG.NEG);return n.runWebGPUProgram(a,[r],r.dtype)}};var CK={kernelName:Kn,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=fm.nonMaxSuppressionV3Impl(u,c,o,i,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}};var EK={kernelName:Yn,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),h=o,p=i,f=l,m=u,{selectedIndices:A,selectedScores:g}=fm.nonMaxSuppressionV5Impl(c,d,h,p,f,m);return[n.makeTensorInfo([A.length],"int32",new Int32Array(A)),n.makeTensorInfo([g.length],"float32",new Float32Array(g))]}};function NK(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=qq({inputs:{input:r},backend:n}),t=NK({inputs:{x:e},backend:n}),a=Qq({inputs:{input:r},backend:n}),s=NK({inputs:{x:a},backend:n}),o=VH({inputs:{real:t,imag:s},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(a.dataId),n.disposeData(s.dataId),o}return $H({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var TK={kernelName:na,backendName:"webgpu",kernelFunc:NK};var RK={kernelName:Jn,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const t=qq({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=Qq({inputs:{input:a},backend:r}),o=NK({inputs:{x:s},backend:r}),i=VH({inputs:{real:n,imag:o},backend:r});return r.disposeData(t.dataId),r.disposeData(n.dataId),r.disposeData(s.dataId),r.disposeData(o.dataId),i}return $H({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};var _K={kernelName:er,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return DX({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{wa.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),wa.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],l=nX({inputs:t.map((e=>{const t=DX({inputs:{input:e},backend:n,attrs:{dim:a}});return i.push(t),t})),backend:n,attrs:{axis:a}});return i.forEach((e=>n.disposeData(e.dataId))),l}},MK=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:o}=r;if(s.every((e=>wa.arraysEqual(e,[0,0]))))return WH({inputs:{x:a},backend:n});if(0===wa.sizeFromShape(a.shape)){return $H({backend:n,attrs:{shape:s.map(((e,t)=>e[0]+a.shape[t]+e[1])),value:o,dtype:a.dtype}})}const i=[{type:"float32",data:[o]}];s.map((e=>i.push({type:"int32",data:[e[0],e[1]]})));const l=new class{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){const e=this.xShape.length,t=oH(e),n=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),r=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),a=e>1?`${t}(${n})`:`${n}`,s=e>1?`${t}(${r})`:`${r}`,o=e>1?"any(outC < start)":"outC < start",i=e>1?"any(outC >= end)":"outC >= end",l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${lH()}\n        if (index < uniforms.size) {\n          let start = ${a};\n          let end = ${s};\n          let outC = getCoordsFromIndex(index);\n\n          if (${o} || ${i}) {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX(${l}));\n          }\n        }\n      }\n    `}}(a.shape,s);return n.runWebGPUProgram(l,[a],a.dtype,i)},$K={kernelName:tr,backendName:"webgpu",kernelFunc:MK},FK=qH({opType:GG.POW}),OK={kernelName:rr,backendName:"webgpu",kernelFunc:FK};var DK={kernelName:ar,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=new BH(GG.PRELU,r.shape,a.shape);return n.runWebGPUProgram(s,[r,a],"float32")}};var zK={kernelName:sr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:o}=r;return CX(a,s,o,"prod",n)}},PK={kernelName:or,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:o}=n,i=mq(r,a,s,o);return t.makeTensorInfo([i.length],o,i)}},LK=qH({opType:GG.DIV}),BK={kernelName:qt,backendName:"webgpu",kernelFunc:LK},WK=HH({opType:XG.RELU}),UK={kernelName:ur,backendName:"webgpu",kernelFunc:WK},VK=HH({opType:XG.RELU6}),jK={kernelName:mr,backendName:"webgpu",kernelFunc:VK};var GK={kernelName:pr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,size:o,halfPixelCenters:i}=r,[l,u]=o,c=[{type:"float32",data:[s&&l>1?1:0,s&&u>1?1:0]},{type:"float32",data:[i?.5:0]}],d=new class{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${lH()}\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}(a.shape,l,u);return n.runWebGPUProgram(d,[a],"float32",c)}};var HK={kernelName:dr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r,[l,u]=i,c=[{type:"float32",data:[s&&l>1?1:0,s&&u>1?1:0]},{type:"float32",data:[s?.5:0]}],d=new class{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;return e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`\n      ${lH()}\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}(a.shape,l,u,o);return n.runWebGPUProgram(d,[a],a.dtype,c)}},qK={kernelName:sa,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:a,fillValue:s,center:o}=t,i=n,l=new class{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${lH()}\n\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}(r.shape,s),[u,c]=ff.getImageCenter(o,r.shape[1],r.shape[2]),d=[{type:"float32",data:[u]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(a)]},{type:"float32",data:[Math.cos(a)]}];"number"==typeof s?d.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):d.push({type:"float32",data:s});return i.runWebGPUProgram(l,[r],r.dtype,d)}},XK=HH({opType:XG.RSQRT,cpuKernelImpl:Aq}),KK={kernelName:yr,backendName:"webgpu",kernelFunc:XK},ZK=class{constructor(e,t,n,r,a,s,o,i=!0){this.variableNames=["updates","indices"],this.workGroupSize=[64,1,1],this.atomic=!0,this.outputShape=s,this.type=o,this.sumDupeIndices=i,this.dispatchLayout=IH(e),this.dispatch=vH(this.dispatchLayout,e,this.workGroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${o}_${i}`;const l=oH(a.length);this.uniforms=`sliceDim : i32, strides: ${l}, size: i32,`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",a="";1===this.dispatchLayout.x.length?(r="flattenedIndex",a="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(r="vec2<i32>(flattenedIndex, coords[1])",a="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const s=`getUpdates(${Array.from({length:this.updatesRank},((e,t)=>`coords[${t}]`)).join(", ")})`;return`\n    ${a}\n\n      ${lH()}\n\n        if (index < uniforms.size) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${mH(this.type,!1)}(${s});\n          let flatIndex = getOutputIndexFromCoords(${r});\n\n          ${((e,t)=>{let n=`atomicAdd(${e}, bitcast<i32>(${t}))`;"float32"===this.type&&(n=`\n          {\n            var oldBits = 0;\n            var newBits = bitcast<i32>(${t});\n            loop {\n              let info = atomicCompareExchangeWeak(${e}, oldBits, newBits);\n              if (info.exchanged) {\n                break;\n              }\n              oldBits = info.old_value;\n              let oldValue = bitcast<f32>(oldBits);\n              let newValue = oldValue + (${t});\n              newBits = bitcast<i32>(newValue);\n            }\n          }\n        `);const r=`atomicStore(${e}, bitcast<i32>(${t}));`;return this.sumDupeIndices?n:r})("&result[flatIndex]","updateValue")};\n        }\n      }`}};var YK={kernelName:xr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:o}=r,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ff.calculateShapes(s,a,o),h=[d/u,u];if(0===d)return n.makeTensorInfo(o,a.dtype);const p=OH({inputs:{x:a},backend:n,attrs:{shape:[l,i]}}),f=OH({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=f.dtype,A=$H({backend:n,attrs:{shape:h,value:0,dtype:m}}),g=[{type:"int32",data:[i]},{type:"int32",data:c},{type:"int32",data:[wa.sizeFromShape(f.shape)]}],y=new ZK(f.shape,i,p.shape.length,f.shape.length,c,h,m),x=n.runWebGPUProgram(y,[f,p],m,g,A),b=OH({inputs:{x:x},backend:n,attrs:{shape:o}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(x.dataId),b}};var JK={kernelName:vr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,o=new class{constructor(e,t,n){this.variableNames=["c","a","b"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],a=[];for(let e=0;e<this.outputShape.length;e++)a.push(`${n[e]}`),e<this.cRank&&r.push(`${n[e]}`);e=r.join(),t=a.join()}return`\n      ${lH()}\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}(r.shape.length,a.shape,a.shape.length);return n.runWebGPUProgram(o,[r,a,s],fs(a.dtype,s.dtype))}},QK=HH({opType:XG.SIGMOID}),eZ={kernelName:Er,backendName:"webgpu",kernelFunc:QK},tZ=HH({opType:XG.SIN}),nZ={kernelName:Sr,backendName:"webgpu",kernelFunc:tZ},rZ=HH({opType:XG.SINH}),aZ={kernelName:Ir,backendName:"webgpu",kernelFunc:rZ},sZ=qH({opType:GG.SUB,cpuKernelImpl:wq,supportsComplex:!0}),oZ={kernelName:Gr,backendName:"webgpu",kernelFunc:sZ};var iZ={kernelName:$r,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,o=wa.parseAxisParam([s],a.shape),i=mK({inputs:{x:a},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=ff.expandShapeToKeepDim(i.shape,o),u=OH({inputs:{x:i},backend:n,attrs:{shape:l}}),c=sZ({inputs:{a:a,b:u},backend:n}),d=FX({inputs:{x:c},backend:n}),h=EX({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),p=OH({inputs:{x:h},backend:n,attrs:{shape:l}}),f=LK({inputs:{a:d,b:p},backend:n});return n.disposeData(i.dataId),n.disposeData(u.dataId),n.disposeData(c.dataId),n.disposeData(d.dataId),n.disposeData(h.dataId),n.disposeData(p.dataId),f}},lZ={kernelName:_r,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:o}=r;wa.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...o);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);const u=[],c=MK({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=ff.getReshaped(c.shape,s,i,!1),h=ff.getPermuted(d.length,s.length,!1),p=ff.getReshapedPermuted(c.shape,s,i,!1),f=OH({inputs:{x:c},backend:n,attrs:{shape:d}}),m=$q({inputs:{x:f},backend:n,attrs:{perm:h}}),A=OH({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeData(e.dataId))),A}};function uZ(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if(n.shouldExecuteOnCPU([a])||"string"===a.dtype||a.shape.length>=5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>wa.decodeString(e))):e,r=Do(a.shape,a.dtype,t),o=kq(r,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new class{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e;a++)r.push(`(${n[a]} % ${t}aShape[${a}])`);return r.join()}(this.rank,"uniforms.");return`\n      ${lH()}\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}(a.shape,s);return n.runWebGPUProgram(o,[a],a.dtype)}var cZ={kernelName:Xr,backendName:"webgpu",kernelFunc:uZ};var dZ={kernelName:Pr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ff.calculateShapes(s,a,i),p=!1;if("string"===s.dtype){const e=n.bufferSync(a),t=n.bufferSync(s),r=wa.decodeString(n.readSync(o.dataId)[0]),f=gq(e,t,i,h,c,u,l,d,r,p);return n.makeTensorInfo(i,f.dtype,f.values)}const f=[h/c,c],m=OH({inputs:{x:a},backend:n,attrs:{shape:[u,l]}}),A=s.shape.length?OH({inputs:{x:s},backend:n,attrs:{shape:[u,c]}}):WH({inputs:{x:s},backend:n}),g=A.dtype,y=n.makeTensorInfo([],g,wa.makeZerosTypedArray(1,g)),x=OH({inputs:{x:o},backend:n,attrs:{shape:Array(f.length).fill(1)}}),b=uZ({inputs:{x:x},backend:n,attrs:{reps:f}}),v=[{type:"int32",data:[l]},{type:"int32",data:d},{type:"int32",data:[wa.sizeFromShape([u,c])]}];switch(u){case 0:break;case 1:{const e=new ZK([u,c],l,m.shape.length,A.shape.length,d,f,g,p);n.runWebGPUProgram(e,[A,m],g,v,b)}break;default:{const e=new ZK([u,c],l,m.shape.length,y.shape.length,d,f,g,p);n.runWebGPUProgram(e,[y,m],g,v,b)}{const e=new ZK([u,c],l,m.shape.length,A.shape.length,d,f,g);n.runWebGPUProgram(e,[A,m],g,v,b)}}const w=OH({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeData(m.dataId),n.disposeData(A.dataId),n.disposeData(x.dataId),n.disposeData(y.dataId),n.disposeData(b.dataId),w}};var hZ={kernelName:Mr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:o}=r,i=wa.parseAxisParam(o,a.shape)[0],l=ff.prepareSplitSize(a,s,i),u=a.shape.length,c=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{const t=[...d];t[i]=e;const r=Uq({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[i]+=e,r}))}},pZ=HH({opType:XG.SQRT}),fZ={kernelName:Tr,backendName:"webgpu",kernelFunc:pZ},mZ={kernelName:Br,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t,a=new GH(n.shape,XG.SQUARE);return r.runWebGPUProgram(a,[n],n.dtype)}},AZ=qH({opType:GG.SQUARED_DIFFERENCE}),gZ={kernelName:Lr,backendName:"webgpu",kernelFunc:AZ};var yZ={kernelName:Wr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:o,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:A,isSimpleSlice:g,begin:y,end:x,strides:b}=Qi.sliceInfo(a.shape,s,o,i,l,u,c,d,h);let v;if(m)v=OH({inputs:{x:a},backend:n,attrs:{shape:f}});else if(A||g){wa.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=Qi.computeOutShape(y,x,b),t=Uq({inputs:{x:a},backend:n,attrs:{begin:y,size:e}});v=OH({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeData(t.dataId)}else{if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=Do(a.shape,a.dtype,e),r=bq(p,t,b,y);v=n.makeTensorInfo(f,a.dtype,r.values)}else{const e=new class{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);const t=oH(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${lH()}\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}(p),t=[{type:"int32",data:y},{type:"int32",data:b}],r=n.runWebGPUProgram(e,[a],a.dtype,t);v=OH({inputs:{x:r},backend:n,attrs:{shape:f}}),n.disposeData(r.dataId)}}return v}};var xZ={kernelName:Ur,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=vq(h,p,a,s,o,i,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}},bZ=HH({opType:XG.TANH}),vZ={kernelName:qr,backendName:"webgpu",kernelFunc:bZ},wZ=class{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${lH()}\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}};function kZ(e,t){null!==t&&e.disposeData(t.dataId)}function SZ(e){let t=1;for(;t<e;)t*=2;return t}var IZ={kernelName:Kr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:o}=r,i=a.shape,l=i[i.length-1];if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),[t,r]=Sq(e,i,a.dtype,s,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return i[i.length-1]=0,[n.makeTensorInfo(i,a.dtype,[]),n.makeTensorInfo(i,"int32",[])];if(1===l)return[a,$H({attrs:{shape:i,dtype:"int32",value:0},backend:n})];const u=wa.sizeFromShape(i)/l,c=OH({inputs:{x:a},attrs:{shape:[u,l]},backend:n}),d=SZ(s),h=SZ(l);let p=null;const f=()=>null===p?[c,c]:[c,p],m=(e,t,r)=>{const a=f(),s=new class{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${lH()}\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}(r),o=[{type:"int32",data:[l]},{type:"int32",data:[null===p?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],i=p;p=n.runWebGPUProgram(s,a,"int32",o),kZ(n,i)};for(let e=1;e<d;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)m(t,n,[u,h])}for(let e=h;e>d;e/=2){const t=f(),r=new wZ([u,e/2]),a=[{type:"int32",data:[l]},{type:"int32",data:[null===p?1:0]},{type:"int32",data:[d]}],s=p;p=n.runWebGPUProgram(r,t,"int32",a),kZ(n,s);const o=d/2,i=2*o;for(let e=o;e>=1;e/=2)m(i,e,p.shape)}let A=p;p=Uq({inputs:{x:p},backend:n,attrs:{begin:0,size:[u,s]}}),kZ(n,A);let g=JX({inputs:{x:c,indices:p},backend:n,attrs:{axis:1,batchDims:1}});kZ(n,c);const y=i.slice(0,-1);y.push(s),A=p,p=OH({inputs:{x:p},attrs:{shape:y},backend:n}),kZ(n,A);const x=g;return g=OH({inputs:{x:g},attrs:{shape:y},backend:n}),kZ(n,x),[g,p]}};var CZ=[PH,Nq,Rq,_q,Oq,Dq,Lq,Bq,jq,Kq,Yq,Jq,jH,rX,oX,lX,cX,hX,pX,yX,xX,bX,kX,TX,_X,$X,OX,PX,BX,FH,WX,HX,VX,GX,XX,KX,ZX,YX,QX,tK,rK,UH,eX,aK,oK,lK,cK,hK,fK,AK,yK,xK,bK,vK,kK,SK,IX,IK,CK,EK,Hq,RK,_K,$K,OK,DK,zK,PK,Xq,BK,UK,jK,DH,GK,HK,qK,KK,YK,JK,eZ,nZ,aZ,Vq,yZ,xZ,iZ,lZ,dZ,hZ,fZ,mZ,gZ,oZ,NX,vZ,cZ,IZ,{kernelName:Zr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:l,outputShape:u}=r,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],A=[c,f,m,p],g=new class{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=IH(this.outputShape),this.dispatch=vH(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${lH()}\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}(A),y="nearest"===o?1:2;let x;switch(i){case"constant":default:x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4}const b=[{type:"int32",data:[y]},{type:"int32",data:[x]},{type:"float32",data:[l]}];return n.runWebGPUProgram(g,[a,s],"float32",b)}},Fq,{kernelName:Qr,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a,i=o.shape.length,l=a.shape[s],u=new Array(i-1);let c=0;for(let e=0;e<i;e++)e!==s&&(u[c++]=o.shape[e]);const d=[],h=new Array(i).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(l);for(let e=0;e<f.length;e++){h[s]=e;const t=Uq({inputs:{x:o},backend:n,attrs:{begin:h,size:p}}),r=OH({inputs:{x:t},backend:n,attrs:{shape:u}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeData(e.dataId))),f}},TK];for(const e of CZ)Aa(e);function EZ(e,t){return`${e}_${t}`}function NZ(e,t,n,r){return`${e}_${t}_${n}_${r}`}function TZ(e){if("rgba8unorm"===e)return 16;throw new Error(`${e} is not supported!`)}var RZ=qe().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),_Z=class extends X{constructor(e,t=!1){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!NH())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=t,this.bufferManager=new class{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,n=!1){const r=EZ(e,t);if(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(r).length>0){this.numFreeBuffers--;const e=this.freeBuffers.get(r).shift();return this.usedBuffers.get(r).push(e),e}this.numBytesAllocated+=e;const a=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(r).push(a),a}releaseBuffer(e,t,n){if(0===this.freeBuffers.size)return;const r=EZ(t,n);this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).push(e),this.numFreeBuffers++,this.numUsedBuffers--;const a=this.usedBuffers.get(r),s=a.indexOf(e);if(s<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");a.splice(s,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,n){e.mapAsync(GPUMapMode.WRITE).then((()=>{this.releaseBuffer(e,t,n)}),(e=>{}))}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}(this.device),this.textureManager=new class{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,r){const a=e*t*TZ(n),s=NZ(e,t,n,r);if(this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.usedTextures.has(s)||this.usedTextures.set(s,[]),this.numBytesUsed+=a,this.numUsedTextures++,this.freeTextures.get(s).length>0){this.numFreeTextures--;const e=this.freeTextures.get(s).shift();return this.usedTextures.get(s).push(e),e}this.numBytesAllocated+=a;const o=this.device.createTexture({size:[e,t],format:n,usage:r});return this.usedTextures.get(s).push(o),o}releaseTexture(e,t,n,r,a){if(0===this.freeTextures.size)return;const s=NZ(t,n,r,a);this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.freeTextures.get(s).push(e),this.numFreeTextures++,this.numUsedTextures--;const o=this.usedTextures.get(s),i=o.indexOf(e);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(i,1);const l=t*n*TZ(r);this.numBytesUsed-=l}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}(this.device),this.tensorMap=new q(this,fi()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),qe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return _Z.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;const{complexTensorInfos:r}=this.tensorMap.get(e);return null!=r&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(t&&t.resourceInfo){if("texture"in t.resourceInfo){const e=t.resourceInfo;e.texture instanceof GPUTexture&&this.textureManager.releaseTexture(e.texture,e.width,e.height,e.format,e.usage),e.texture=null}else{const e=t.resourceInfo;this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage),e.buffer=null}t.resourceInfo=null}}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:n,shape:t,values:e,refCount:1}),r}move(e,t,n,r,a){if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:n,values:t,refCount:a})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((e=>{this.releaseResource(e),this.tensorMap.delete(e)})),this.uniformPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage))),this.stagingPendingDisposal.forEach((e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,t){const n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=n.getMappedRange().slice(0);return n.unmap(),null!=n&&this.bufferManager.releaseBuffer(n,t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),qe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(wa.assert(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n}=t;if(null==n)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:n}=t;if(null!=n)return this.convertAndCacheOnCPU(e,n);let r;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),n=e[0],a=e[1];r=ff.mergeRealAndImagArrays(n,a)}else{const e=t.resourceInfo;r=EH(await this.getBufferData(e.buffer,e.size),t.dtype)}return this.convertAndCacheOnCPU(e,r),r}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:r,shape:a,resourceInfo:s}=t;if("complex64"===r)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==s)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=s.size,i=this.bufferManager.acquireBuffer(o,s.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(s.buffer,0,i,0,o),this.submitQueue();const l=this.makeTensorInfo(a,r),u=fi().makeTensorFromTensorInfo(l);return this.tensorMap.get(l.dataId).resourceInfo={size:o,usage:this.defaultGpuBufferUsage(),buffer:i},{tensorRef:u,buffer:i,bufSize:o}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>wa.decodeString(e)));return Do(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Do(e.shape,e.dtype,t)}async time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=wa.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=wa.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},i=await Promise.all(a);return o.kernelMs=wa.sum(i),o.getExtraProfileInfo=()=>i.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,t,n){"string"===t&&null!=n&&n.length>0&&wa.isString(n[0])&&(n=n.map((e=>wa.encodeString(e))));return{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){const e=t.resourceInfo;return e.texture instanceof GPUExternalTexture?e.texture:e.texture.createView()}const n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resourceInfo)return;const n=CH(t.dtype)*wa.sizeFromShape(t.shape),r=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage());if(t.resourceInfo={size:n,usage:this.defaultGpuBufferUsage(),buffer:r},t.values){const e=this.bufferManager.acquireUploadBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),a=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,n);const s={size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:e};this.stagingPendingDisposal.push(s)}}makeUniforms(e){let t=0,n=0;const r=[];e.forEach((e=>{let a;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:a=4;break;case 2:a=8;break;case 3:case 4:case 5:case 6:a=16;break;default:wa.assert(!1,(()=>`Unsupported ${e.data.length}D shape`))}5!==n&&6!==n||(a=16),t=Math.ceil(t/a)*a,n=e.data.length,r.push(t),t+=4*e.data.length}));const a=new ArrayBuffer(t);e.forEach(((e,t)=>{const n=r[t];"int32"===e.type?new Int32Array(a,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(a,n,e.data.length).set(e.data):new Float32Array(a,n,e.data.length).set(e.data)}));const s=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(s,0,a,0,t);const o={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:s};return this.uniformPendingDisposal.push(o),{offset:0,size:t,buffer:s}}runWebGPUProgram(e,t,n,r,a){if(a||(a=this.makeTensorInfo(e.outputShape,n)),0===wa.sizeFromShape(a.shape))return this.tensorMap.get(a.dataId).values=wa.getTypedArrayFromDType(a.dtype,0),a;this.uploadToGPU(a.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,r=t.dispatchLayout,a=t.dispatch;if(a.every((e=>e<=n)))return a;wa.assert(a[0]>n&&void 0===r.y&&void 0===r.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let s=Math.ceil(Math.sqrt(a[0]));return s>n?(s=Math.ceil(Math.cbrt(a[0])),wa.assert(s<=n,(()=>"Total dispatch size exceeds WebGPU maximum.")),[s,s,s]):[s,s,1]})(this.device,e);let s=[],o=[];if(!e.isFromPixels){s.push({type:"float32",data:[NaN]}),o=t.concat(a).map((e=>e.shape));const n="int32";o.map((e=>{s.push({type:n,data:e})}));const r=wa.computeStrides(a.shape);if(s.push({type:n,data:r}),e.size){const t=wa.sizeFromShape(e.outputShape);s.push({type:n,data:[e.isVec4?t/4:t]})}}const i=t.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}})),l=function(e,t,n,r){let a=e.shaderKey;if(e.isFromPixels)return a;const s=n.map((e=>e.dtype)).concat(r.dtype),o=n.map((e=>ff.getBroadcastDims(e.shape,r.shape))),i=n.map((e=>wa.arraysEqual(e.shape,r.shape))).join("_"),l=o.map((e=>e.join("_"))).join(";"),u=fH(e)?"flatDispatch":"";return a+="_"+(e.workGroupSize?e.workGroupSize.join(","):"")+t.map((e=>e.length)).join(",")+s.join(",")+e.variableNames.join(",")+l+i+u,a}(e,o,i,a);let u;l in this.pipelineCache?u=this.pipelineCache[l]:(u=sH(this.device,e,i,a),this.pipelineCache[l]=u),r&&(s=[...s,...r]);const c=[this.tensorToBinding(a),...t.map((e=>this.tensorToBinding(e))),this.makeUniforms(s)],d=this.device.createBindGroup({layout:u.getBindGroupLayout(0),entries:c.map(((e,t)=>({binding:t,resource:e})))});this.ensureCommandEncoderReady();const h=this.getComputePass(),p=null!=this.activeTimers;return p&&this.supportTimeQuery&&h.writeTimestamp(this.querySet,0),h.setPipeline(u),h.setBindGroup(0,d),h.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),p&&this.supportTimeQuery&&h.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(a.dataId),qe().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),p&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),a}async getTimeFromQuerySet(e){const t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=new BigUint64Array(n.getMappedRange()),a=Number(r[1]-r[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),a/1e6}shouldExecuteOnCPU(e,t=RZ){return qe().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).resourceInfo&&wa.sizeFromShape(e.shape)<t))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}};_Z.nextDataId=0;var MZ={};S(MZ,{WebGPUBackend:()=>_Z,webgpu_util:()=>AH}),NH()&&Ei("webgpu",(async()=>{qe().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const e={powerPreference:qe().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e),n=t.limits,r={},a=t.features.has("timestamp-query");r.requiredLimits={maxComputeWorkgroupStorageSize:n.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:n.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:n.maxStorageBufferBindingSize},a?r.requiredFeatures=["timestamp-query"]:console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Or zero will shown for the kernel time when profiling mode isenabled. Using performance.now is not workable for webgpu sinceit doesn't support synchronously to read data from GPU.");const s=await t.requestDevice(r);return new _Z(s,a)}),3);var $Z={tfjs:"3.19.0","tfjs-core":"3.19.0","tfjs-data":"3.19.0","tfjs-layers":"3.19.0","tfjs-converter":"3.19.0","tfjs-backend-webgl":"3.19.0","tfjs-backend-wasm":"3.19.0"},FZ=(e,t,n)=>{const r=new RegExp("\\b"+t+" \\w+ (\\w+)","ig");e.replace(r,((e,t)=>(n[t]=0,e)))};function OZ(){let e=0,t=null,n=!1,r=-1,a=[null,null],s=[],i=null,l=null;const u=VZ(100,100),c={},h=1,p=u.getContext("webgl");if(!p)return void d("filter: cannot get webgl context");function f(e){return a[e]=a[e]||function(e,t){const n=p.createFramebuffer();p.bindFramebuffer(p.FRAMEBUFFER,n);const r=p.createRenderbuffer();p.bindRenderbuffer(p.RENDERBUFFER,r);const a=p.createTexture();return p.bindTexture(p.TEXTURE_2D,a),p.texImage2D(p.TEXTURE_2D,0,p.RGBA,e,t,0,p.RGBA,p.UNSIGNED_BYTE,null),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MAG_FILTER,p.LINEAR),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MIN_FILTER,p.LINEAR),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_S,p.CLAMP_TO_EDGE),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_T,p.CLAMP_TO_EDGE),p.framebufferTexture2D(p.FRAMEBUFFER,p.COLOR_ATTACHMENT0,p.TEXTURE_2D,a,0),p.bindTexture(p.TEXTURE_2D,null),p.bindFramebuffer(p.FRAMEBUFFER,null),{fbo:n,texture:a}}(u.width,u.height),a[e]}function m(a=0){if(!l)return;let s=null,o=null,i=!1;s=0===e?t:f(r).texture||null,e++,!n||a&h?(r=(r+1)%2,o=f(r).fbo||null):(o=null,i=e%2==0),p.bindTexture(p.TEXTURE_2D,s),p.bindFramebuffer(p.FRAMEBUFFER,o),p.uniform1f(l.uniform.flipY,i?-1:1),p.drawArrays(p.TRIANGLES,0,6)}function A(e){if(c[e])return l=c[e],p.useProgram((l?l.id:null)||null),l;if(l=new class{constructor(e,t,n){o(this,"uniform",{}),o(this,"attribute",{}),o(this,"gl"),o(this,"id"),o(this,"compile",((e,t)=>{const n=this.gl.createShader(t);return n?(this.gl.shaderSource(n,e),this.gl.compileShader(n),this.gl.getShaderParameter(n,this.gl.COMPILE_STATUS)?n:(d(`filter: gl compile failed: ${this.gl.getShaderInfoLog(n)}`),null)):(d("filter: could not create shader"),null)})),this.gl=e;const r=this.compile(t,this.gl.VERTEX_SHADER),a=this.compile(n,this.gl.FRAGMENT_SHADER);if(this.id=this.gl.createProgram(),r&&a)if(this.id)if(this.gl.attachShader(this.id,r),this.gl.attachShader(this.id,a),this.gl.linkProgram(this.id),this.gl.getProgramParameter(this.id,this.gl.LINK_STATUS)){this.gl.useProgram(this.id),FZ(t,"attribute",this.attribute);for(const e in this.attribute)this.attribute[e]=this.gl.getAttribLocation(this.id,e);FZ(t,"uniform",this.uniform),FZ(n,"uniform",this.uniform);for(const e in this.uniform)this.uniform[e]=this.gl.getUniformLocation(this.id,e)}else d(`filter: gl link failed: ${this.gl.getProgramInfoLog(this.id)}`);else d("filter: could not create webgl program")}}(p,"\n  precision highp float;\n  attribute vec2 pos;\n  attribute vec2 uv;\n  varying vec2 vUv;\n  uniform float flipY;\n  void main(void) {\n    vUv = uv;\n    gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);\n  }\n",e),!l)return d("filter: could not get webgl program"),null;const t=Float32Array.BYTES_PER_ELEMENT,n=4*t;return p.enableVertexAttribArray(l.attribute.pos),p.vertexAttribPointer(l.attribute.pos,2,p.FLOAT,!1,n,0*t),p.enableVertexAttribArray(l.attribute.uv),p.vertexAttribPointer(l.attribute.uv,2,p.FLOAT,!1,n,2*t),c[e]=l,l}this.gl=p;const g={colorMatrix:e=>{const t=new Float32Array(e);t[4]/=255,t[9]/=255,t[14]/=255,t[19]/=255;const n=A(1===t[18]&&0===t[3]&&0===t[8]&&0===t[13]&&0===t[15]&&0===t[16]&&0===t[17]&&0===t[19]?"\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform float m[20];\n  void main(void) {\n    vec4 c = texture2D(texture, vUv);\n    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];\n    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];\n    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];\n    gl_FragColor.a = c.a;\n  }\n":"\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform float m[20];\n  void main(void) {\n    vec4 c = texture2D(texture, vUv);\n    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];\n    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];\n    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];\n    gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];\n  }\n");n&&(p.uniform1fv(n.uniform.m,t),m())},brightness:e=>{const t=(e||0)+1;g.colorMatrix([t,0,0,0,0,0,t,0,0,0,0,0,t,0,0,0,0,0,1,0])},saturation:e=>{const t=2*(e||0)/3+1,n=-.5*(t-1);g.colorMatrix([t,n,n,0,0,n,t,n,0,0,n,n,t,0,0,0,0,0,1,0])},desaturate:()=>{g.saturation(-1)},contrast:e=>{const t=(e||0)+1,n=-128*(t-1);g.colorMatrix([t,0,0,0,n,0,t,0,0,n,0,0,t,0,n,0,0,0,1,0])},negative:()=>{g.contrast(-2)},hue:e=>{e=(e||0)/180*Math.PI;const t=Math.cos(e),n=Math.sin(e),r=.213,a=.715,s=.072;g.colorMatrix([r+.787*t+n*-r,a+t*-a+n*-a,s+t*-s+.928*n,0,0,r+t*-r+.143*n,a+t*(1-a)+.14*n,s+t*-s+-.283*n,0,0,r+t*-r+-.787*n,a+t*-a+n*a,s+.928*t+n*s,0,0,0,0,0,1,0])},desaturateLuminance:()=>{g.colorMatrix([.2764723,.929708,.0938197,0,-37.1,.2764723,.929708,.0938197,0,-37.1,.2764723,.929708,.0938197,0,-37.1,0,0,0,1,0])},sepia:()=>{g.colorMatrix([.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0])},brownie:()=>{g.colorMatrix([.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0])},vintagePinhole:()=>{g.colorMatrix([.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0])},kodachrome:()=>{g.colorMatrix([1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0])},technicolor:()=>{g.colorMatrix([1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0])},polaroid:()=>{g.colorMatrix([1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0])},shiftToBGR:()=>{g.colorMatrix([0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0])},convolution:e=>{const t=new Float32Array(e),n=1/u.width,r=1/u.height,a=A("\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform vec2 px;\n  uniform float m[9];\n  void main(void) {\n    vec4 c11 = texture2D(texture, vUv - px); // top left\n    vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y)); // top center\n    vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y)); // top right\n    vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) ); // mid left\n    vec4 c22 = texture2D(texture, vUv); // mid center\n    vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) ); // mid right\n    vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) ); // bottom left\n    vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) ); // bottom center\n    vec4 c33 = texture2D(texture, vUv + px ); // bottom right\n    gl_FragColor = \n    c11 * m[0] + c12 * m[1] + c22 * m[2] +\n    c21 * m[3] + c22 * m[4] + c23 * m[5] +\n    c31 * m[6] + c32 * m[7] + c33 * m[8];\n    gl_FragColor.a = c22.a;\n  }\n");a&&(p.uniform1fv(a.uniform.m,t),p.uniform2f(a.uniform.px,n,r),m())},detectEdges:()=>{g.convolution.call(this,[0,1,0,1,-4,1,0,1,0])},sobelX:()=>{g.convolution.call(this,[-1,0,1,-2,0,2,-1,0,1])},sobelY:()=>{g.convolution.call(this,[-1,-2,-1,0,0,0,1,2,1])},sharpen:e=>{const t=e||1;g.convolution.call(this,[0,-1*t,0,-1*t,1+4*t,-1*t,0,-1*t,0])},emboss:e=>{const t=e||1;g.convolution.call(this,[-2*t,-1*t,0,-1*t,1,1*t,0,1*t,2*t])},blur:e=>{const t=e/7/u.width,n=e/7/u.height,r=A("\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform vec2 px;\n  void main(void) {\n    gl_FragColor = vec4(0.0);\n    gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;\n    gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;\n    gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;\n    gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;\n    gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;\n    gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;\n    gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;\n    gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;\n    gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;\n    gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;\n    gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;\n    gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;\n    gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;\n    gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;\n    gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;\n  }\n");r&&(p.uniform2f(r.uniform.px,0,n),m(h),p.uniform2f(r.uniform.px,t,0),m())},pixelate:e=>{const t=e/u.width,n=e/u.height,r=A("\n  precision highp float;\n  varying vec2 vUv;\n  uniform vec2 size;\n  uniform sampler2D texture;\n  vec2 pixelate(vec2 coord, vec2 size) {\n    return floor( coord / size ) * size;\n  }\n  void main(void) {\n    gl_FragColor = vec4(0.0);\n    vec2 coord = pixelate(vUv, size);\n    gl_FragColor += texture2D(texture, coord);\n  }\n");r&&(p.uniform2f(r.uniform.size,t,n),m())}};this.add=function(e){const t=Array.prototype.slice.call(arguments,1),n=g[e];s.push({func:n,args:t})},this.reset=function(){s=[]},this.get=function(){return s},this.apply=function(r){!function(e,t){if(e!==u.width||t!==u.height){if(u.width=e,u.height=t,!i){const e=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,-1,1,0,0,1,-1,1,1,1,1,1,0]);i=p.createBuffer(),p.bindBuffer(p.ARRAY_BUFFER,i),p.bufferData(p.ARRAY_BUFFER,e,p.STATIC_DRAW),p.pixelStorei(p.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0)}p.viewport(0,0,u.width,u.height),a=[null,null]}}(r.width,r.height),e=0,t||(t=p.createTexture()),p.bindTexture(p.TEXTURE_2D,t),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_S,p.CLAMP_TO_EDGE),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_T,p.CLAMP_TO_EDGE),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MIN_FILTER,p.NEAREST),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MAG_FILTER,p.NEAREST),p.texImage2D(p.TEXTURE_2D,0,p.RGBA,p.RGBA,p.UNSIGNED_BYTE,r);for(let e=0;e<s.length;e++){n=e===s.length-1;const t=s[e];t.func.apply(this,t.args||[])}return u},this.draw=function(e){return this.add("brightness",0),this.apply(e)}}async function DZ(e){const t=4===e.shape.length?ph(e):e,n=ch(t,3,2),r=[hc(n[0]),hc(n[1]),hc(n[2])],a=[dc(n[0]),dc(n[1]),dc(n[2])],s=await Promise.all(a.map((e=>e.data()))),o=.99*Math.max(s[0][0],s[1][0],s[2][0]),i=[Zc(n[0],r[0]),Zc(n[1],r[1]),Zc(n[2],r[2])],l=[Zc(a[0],r[0]),Zc(a[1],r[1]),Zc(a[2],r[2])],u=[Dl(o,l[0]),Dl(o,l[1]),Dl(o,l[2])],c=[zl(i[0],u[0]),zl(i[1],u[1]),zl(i[2],u[2])],d=fh([c[0],c[1],c[2]],2),h=du(d,[1,t.shape[0],t.shape[1],3]);return yi([...n,...r,...a,...i,...l,...u,...c,d,t]),h}var zZ,PZ=3840,LZ=null,BZ=null,WZ=null,UZ={inputSum:0,cacheDiff:1,sumMethod:0,inputTensor:void 0};function VZ(e,t){let n;if(HZ.browser)if(HZ.worker){if("undefined"==typeof OffscreenCanvas)throw new Error("canvas error: attempted to run in web worker but OffscreenCanvas is not supported");n=new OffscreenCanvas(e,t)}else{if("undefined"==typeof document)throw new Error("canvas error: attempted to run in browser but DOM is not defined");n=document.createElement("canvas"),n.width=e,n.height=t}else void 0!==HZ.Canvas?n=new HZ.Canvas(e,t):void 0!==globalThis.Canvas&&(n=new globalThis.Canvas(e,t));return n}function jZ(e,t){const n=t||VZ(e.width,e.height);return n.getContext("2d").drawImage(e,0,0),n}async function GZ(e,t,n=!0){if(!e)return t.debug&&d("input error: input is missing"),{tensor:null,canvas:null};if(!(e instanceof Qa||"undefined"!=typeof Image&&e instanceof Image||void 0!==HZ.Canvas&&e instanceof HZ.Canvas||void 0!==globalThis.Canvas&&e instanceof globalThis.Canvas||"undefined"!=typeof ImageData&&e instanceof ImageData||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLMediaElement&&e instanceof HTMLMediaElement||"undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas))throw new Error("input error: type is not recognized");if(e instanceof Qa){let n=null;if(e.isDisposedInternal)throw new Error("input error: attempted to use tensor but it is disposed");if(!e.shape)throw new Error("input error: attempted to use tensor without a shape");if(3===e.shape.length){if(3===e.shape[2])n=wc(e,0);else if(4===e.shape[2]){const t=ah(e,[0,0,0],[-1,-1,3]);n=wc(t,0),yi(t)}}else 4===e.shape.length&&(3===e.shape[3]?n=Po(e):4===e.shape[3]&&(n=sh(e,[0,0,0,0],[-1,-1,-1,3])));if(null==n||4!==n.shape.length||1!==n.shape[0]||3!==n.shape[3])throw new Error(`input error: attempted to use tensor with unrecognized shape: ${e.shape}`);if("int32"===n.dtype){const e=zo(n,"float32");yi(n),n=e}return{tensor:n,canvas:t.filter.return?BZ:null}}{if(void 0!==e.readyState&&e.readyState<=2)return t.debug&&d("input stream is not ready"),{tensor:null,canvas:LZ};const r=e.naturalWidth||e.videoWidth||e.width||e.shape&&e.shape[1]>0,a=e.naturalHeight||e.videoHeight||e.height||e.shape&&e.shape[2]>0;if(!r||!a)return t.debug&&d("cannot determine input dimensions"),{tensor:null,canvas:LZ};let s=r,o=a;if(s>PZ&&(s=PZ,o=Math.trunc(s*a/r)),o>PZ&&(o=PZ,s=Math.trunc(o*r/a)),(t.filter.width||0)>0?s=t.filter.width:(t.filter.height||0)>0&&(s=r*((t.filter.height||0)/a)),(t.filter.height||0)>0?o=t.filter.height:(t.filter.width||0)>0&&(o=a*((t.filter.width||0)/r)),!s||!o)throw new Error("input error: cannot determine dimension");LZ&&(null==LZ?void 0:LZ.width)===s&&(null==LZ?void 0:LZ.height)===o||(LZ=VZ(s,o));const i=LZ.getContext("2d");if("undefined"!=typeof ImageData&&e instanceof ImageData?i.putImageData(e,0,0):t.filter.flip&&void 0!==i.translate?(i.translate(r,0),i.scale(-1,1),i.drawImage(e,0,0,r,a,0,0,null==LZ?void 0:LZ.width,null==LZ?void 0:LZ.height),i.setTransform(1,0,0,1,0,0)):i.drawImage(e,0,0,r,a,0,0,null==LZ?void 0:LZ.width,null==LZ?void 0:LZ.height),BZ&&LZ.width===BZ.width&&(null==LZ?void 0:LZ.height)===(null==BZ?void 0:BZ.height)||(BZ=VZ(LZ.width,LZ.height)),t.filter.enabled&&HZ.webgl.supported?(zZ||(zZ=HZ.browser?new OZ:null),HZ.filter=!!zZ,zZ&&zZ.add?(zZ.reset(),0!==t.filter.brightness&&zZ.add("brightness",t.filter.brightness),0!==t.filter.contrast&&zZ.add("contrast",t.filter.contrast),0!==t.filter.sharpness&&zZ.add("sharpen",t.filter.sharpness),0!==t.filter.blur&&zZ.add("blur",t.filter.blur),0!==t.filter.saturation&&zZ.add("saturation",t.filter.saturation),0!==t.filter.hue&&zZ.add("hue",t.filter.hue),t.filter.negative&&zZ.add("negative"),t.filter.sepia&&zZ.add("sepia"),t.filter.vintage&&zZ.add("brownie"),t.filter.sepia&&zZ.add("sepia"),t.filter.kodachrome&&zZ.add("kodachrome"),t.filter.technicolor&&zZ.add("technicolor"),t.filter.polaroid&&zZ.add("polaroid"),0!==t.filter.pixelate&&zZ.add("pixelate",t.filter.pixelate),BZ=zZ.get()>0?zZ.apply(LZ):zZ.draw(LZ)):(t.debug&&d("input process error: cannot initialize filters"),HZ.webgl.supported=!1,t.filter.enabled=!1,jZ(LZ,BZ))):(jZ(LZ,BZ),zZ&&(zZ=null),HZ.filter=!!zZ),!n)return{tensor:null,canvas:BZ};if(!BZ)throw new Error("canvas error: cannot create output");let l,u=3;if("undefined"!=typeof ImageData&&e instanceof ImageData||e.data&&e.width&&e.height)if(HZ.browser&&Bi)l=Bi?Bi.fromPixels(e):null;else{u=e.data.length/e.height/e.width;l=Us(new Uint8Array(e.data.buffer),[e.height,e.width,u],"int32")}else if(WZ&&BZ.width===WZ.width&&BZ.height===WZ.height||(WZ=VZ(BZ.width,BZ.height)),Bi&&HZ.browser)"webgl"===t.backend||"humangl"===t.backend||"webgpu"===t.backend?l=Bi.fromPixels(BZ):(WZ=jZ(BZ),l=Bi.fromPixels(WZ));else{const e=jZ(BZ).getContext("2d").getImageData(0,0,s,o);u=e.data.length/s/o;l=Us(new Uint8Array(e.data.buffer),[s,o,u])}if(4===u){const e=ah(l,[0,0,0],[-1,-1,3]);yi(l),l=e}if(!l)throw new Error("input error: cannot create tensor");const c=zo(l,"float32"),h=t.filter.equalization?await DZ(c):wc(c,0);return yi([l,c]),{tensor:h,canvas:t.filter.return?BZ:null}}}var HZ=new class{constructor(){if(o(this,"browser"),o(this,"node"),o(this,"worker"),o(this,"platform",""),o(this,"agent",""),o(this,"backends",[]),o(this,"initial"),o(this,"filter"),o(this,"tfjs"),o(this,"offscreen"),o(this,"perfadd",!1),o(this,"wasm",{supported:void 0,backend:void 0,simd:void 0,multithread:void 0}),o(this,"webgl",{supported:void 0,backend:void 0,version:void 0,renderer:void 0}),o(this,"webgpu",{supported:void 0,backend:void 0,adapter:void 0}),o(this,"cpu",{model:void 0,flags:[]}),o(this,"kernels",[]),o(this,"Canvas"),o(this,"Image"),o(this,"ImageData"),this.browser="undefined"!=typeof navigator,this.node="undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node,this.tfjs={version:$Z["tfjs-core"]},this.offscreen="undefined"!=typeof OffscreenCanvas,this.initial=!0,this.worker=this.browser&&this.offscreen?"undefined"!=typeof WorkerGlobalScope:void 0,"undefined"!=typeof navigator){const e=navigator.userAgent.match(/\(([^()]+)\)/g);if(e&&e[0]){const t=e[0].match(/\(([^()]+)\)/g);this.platform=t&&t[0]?t[0].replace(/\(|\)/g,""):"",this.agent=navigator.userAgent.replace(e[0],""),this.platform[1]&&(this.agent=this.agent.replace(e[1],"")),this.agent=this.agent.replace(/  /g," ")}}else"undefined"!=typeof process&&(this.platform=`${process.platform} ${process.arch}`,this.agent=`NodeJS ${process.version}`)}async updateBackend(){this.backends=Object.keys(fi().registryFactory),this.wasm.supported="undefined"!=typeof WebAssembly,this.wasm.backend=this.backends.includes("wasm"),this.wasm.supported&&this.wasm.backend&&"wasm"===ki()&&(this.wasm.simd=await qe().getAsync("WASM_HAS_SIMD_SUPPORT"),this.wasm.multithread=await qe().getAsync("WASM_HAS_MULTITHREAD_SUPPORT"));const e=VZ(100,100),t=e?e.getContext("webgl2"):void 0;if(this.webgl.supported=void 0!==t,this.webgl.backend=this.backends.includes("webgl"),this.webgl.supported&&this.webgl.backend&&("webgl"===ki()||"humangl"===ki())){const e="undefined"!==Ni().gpgpu?await Ni().getGPGPUContext().gl:null;e&&(this.webgl.version=e.getParameter(e.VERSION),this.webgl.renderer=e.getParameter(e.RENDERER))}this.webgpu.supported=this.browser&&void 0!==navigator.gpu,this.webgpu.backend=this.backends.includes("webgpu");try{this.webgpu.supported&&(this.webgpu.adapter=(await navigator.gpu.requestAdapter()).name)}catch(e){this.webgpu.supported=!1}try{this.kernels=ma(ki()).map((e=>e.kernelName.toLowerCase()))}catch(e){}}async updateCPU(){const e={model:"",flags:[]};this.node&&this.platform.startsWith("linux"),this.cpu?this.cpu=e:Object.defineProperty(this,"cpu",{value:e})}},qZ={};s(qZ,{age:()=>XZ,antispoof:()=>KZ,blazeface:()=>JZ,"blazeface-back":()=>ZZ,"blazeface-front":()=>YZ,"blazepose-detector2d":()=>QZ,"blazepose-detector3d":()=>eY,"blazepose-full":()=>tY,"blazepose-heavy":()=>nY,"blazepose-lite":()=>rY,default:()=>DY,efficientpose:()=>aY,emotion:()=>sY,faceboxes:()=>oY,facemesh:()=>hY,"facemesh-attention":()=>lY,"facemesh-attention-alt":()=>iY,"facemesh-detection-full":()=>uY,"facemesh-detection-short":()=>cY,"facemesh-orig":()=>dY,faceres:()=>fY,"faceres-deep":()=>pY,gear:()=>mY,gender:()=>gY,"gender-ssrnet-imdb":()=>AY,handdetect:()=>yY,"handlandmark-full":()=>xY,"handlandmark-lite":()=>bY,"handlandmark-sparse":()=>vY,handskeleton:()=>wY,handtrack:()=>kY,iris:()=>SY,liveness:()=>IY,"mb3-centernet":()=>CY,meet:()=>EY,mobileface:()=>NY,mobilefacenet:()=>TY,"movenet-lightning":()=>RY,"movenet-multipose":()=>_Y,"movenet-thunder":()=>MY,nanodet:()=>$Y,posenet:()=>FY,selfie:()=>OY});var XZ=161240,KZ=853098,ZZ=538928,YZ=402048,JZ=538928,QZ=7499400,eY=5928856,tY=6338290,nY=27501554,rY=2725490,aY=5651240,sY=820516,oY=2013002,iY=2387598,lY=2382414,uY=1026192,cY=201268,dY=2955780,hY=1477958,pY=13957620,fY=6978814,mY=1498916,AY=161236,gY=201808,yY=3515612,xY=5431368,bY=2023432,vY=5286322,wY=5502280,kY=2964837,SY=2599092,IY=592976,CY=4030290,EY=372228,NY=2183192,TY=5171976,RY=4650216,_Y=9448838,MY=12477112,$Y=7574558,FY=5032780,OY=212886,DY={age:XZ,antispoof:KZ,"blazeface-back":ZZ,"blazeface-front":YZ,blazeface:JZ,"blazepose-detector2d":QZ,"blazepose-detector3d":eY,"blazepose-full":tY,"blazepose-heavy":nY,"blazepose-lite":rY,efficientpose:aY,emotion:sY,faceboxes:oY,"facemesh-attention-alt":iY,"facemesh-attention":lY,"facemesh-detection-full":uY,"facemesh-detection-short":cY,"facemesh-orig":dY,facemesh:hY,"faceres-deep":pY,faceres:fY,gear:mY,"gender-ssrnet-imdb":AY,gender:gY,handdetect:yY,"handlandmark-full":xY,"handlandmark-lite":bY,"handlandmark-sparse":vY,handskeleton:wY,handtrack:kY,iris:SY,liveness:IY,"mb3-centernet":CY,meet:EY,mobileface:NY,mobilefacenet:TY,"movenet-lightning":RY,"movenet-multipose":_Y,"movenet-thunder":MY,nanodet:$Y,posenet:FY,selfie:OY},zY={cacheModels:!0,cacheSupported:!0,verbose:!0,debug:!1,modelBasePath:""},PY={};async function LY(e){var t,n,r;let a=function(e,t){const n=e.endsWith("/")?"":"/",r=t.startsWith(".")||t.startsWith("/")||t.startsWith("http:")||t.startsWith("https:")||t.startsWith("file:")?`${t}`:`${e}${n}${t}`;if(!r.toLocaleLowerCase().includes(".json"))throw new Error(`modelpath error: expecting json file: ${r}`);return r}(zY.modelBasePath,e||"");a.toLowerCase().endsWith(".json")||(a+=".json");const s=a.includes("/")?a.split("/"):a.split("\\"),o=s[s.length-1].replace(".json",""),i="indexeddb://"+o;PY[o]={name:o,sizeFromManifest:0,sizeLoadedWeights:0,sizeDesired:qZ[o],inCache:!1},zY.cacheSupported="undefined"!=typeof window&&void 0!==window.localStorage&&void 0!==window.indexedDB;let l={};try{l=zY.cacheSupported&&zY.cacheModels?await Bo.listModels():{}}catch(e){zY.cacheSupported=!1}PY[o].inCache=zY.cacheSupported&&zY.cacheModels&&Object.keys(l).includes(i);const u="undefined"==typeof fetch?{}:{fetchFunc:(e,t)=>async function(e,t){return zY.debug&&d("load model fetch:",e,t),fetch(e,t)}(e,t)},c=new nC(PY[o].inCache?i:a,u);let h=!1;try{c.findIOHandler(),zY.debug&&d("model load handler:",c.handler);const e=await c.handler.load();PY[o].sizeFromManifest=(null==(t=null==e?void 0:e.weightData)?void 0:t.byteLength)||0,c.loadSync(e),PY[o].sizeLoadedWeights=(null==(r=null==(n=null==c?void 0:c.artifacts)?void 0:n.weightData)?void 0:r.byteLength)||0,zY.verbose&&d("load model:",c.modelUrl,{bytes:PY[o].sizeLoadedWeights},zY),h=!0}catch(e){d("error loading model:",a,e)}if(h&&zY.cacheModels&&zY.cacheSupported&&!PY[o].inCache)try{d("model saved:",i,await c.save(i))}catch(e){d("error saving model:",a,e)}return c}var BY,WY="2.9.1",UY={};s(UY,{Models:()=>P2,getModelStats:()=>L2,load:()=>W2,reset:()=>B2,validate:()=>U2});var VY=[],jY=["white","black","asian","indian","other"],GY=[15,23,28,35.5,45.5,55.5,65],HY=0,qY=0,XY=Number.MAX_SAFE_INTEGER;async function KY(e,t,n,r){var a,s;if(!BY)return{age:0,gender:"unknown",genderScore:0,race:[]};const o=XY<((null==(a=t.face.gear)?void 0:a.skipFrames)||0),i=((null==(s=t.face.gear)?void 0:s.skipTime)||0)>h()-qY;return t.skipAllowed&&i&&o&&HY===r&&VY[n]?(XY++,VY[n]):(XY=0,new Promise((async a=>{var s,o;if(!(null==BY?void 0:BY.inputs[0].shape))return;const i={};i.resize=Zp.cropAndResize(e,[[0,.1,.9,.9]],[0],[BY.inputs[0].shape[2],BY.inputs[0].shape[1]]);const l={age:0,gender:"unknown",genderScore:0,race:[]};(null==(s=t.face.gear)?void 0:s.enabled)&&([i.age,i.gender,i.race]=BY.execute(i.resize,["age_output","gender_output","race_output"]));const u=await i.gender.data();l.gender=u[0]>u[1]?"male":"female",l.genderScore=Math.round(100*(u[0]>u[1]?u[0]:u[1]))/100;const c=await i.race.data();for(let e=0;e<c.length;e++)c[e]>((null==(o=t.face.gear)?void 0:o.minConfidence)||.2)&&l.race.push({score:Math.round(100*c[e])/100,race:jY[e]});l.race.sort(((e,t)=>t.score-e.score));const d=Array.from(await i.age.data()).map(((e,t)=>[GY[t],e])).sort(((e,t)=>t[1]-e[1]));let p=d[0][0];for(let e=1;e<d.length;e++)p+=d[e][1]*(d[e][0]-p);l.age=Math.round(10*p)/10,Object.keys(i).forEach((e=>yi(i[e]))),VY[n]=l,HY=r,qY=h(),a(l)})))}var ZY,YY={tf255:255,tf1:1,tf2:2,tf05:.5,tf127:127.5,rgb:[.2989,.587,.114]};var JY,QY=[],eJ=0,tJ=0,nJ=Number.MAX_SAFE_INTEGER;async function rJ(e,t,n,r){var a,s,o,i;if(!ZY)return{age:0};const l=nJ<((null==(a=t.face.ssrnet)?void 0:a.skipFrames)||0),u=((null==(s=t.face.ssrnet)?void 0:s.skipTime)||0)>h()-tJ;return t.skipAllowed&&l&&u&&eJ===r&&(null==(o=QY[n])?void 0:o.age)&&(null==(i=QY[n])?void 0:i.age)>0?(nJ++,QY[n]):(nJ=0,new Promise((async a=>{if(!(null==ZY?void 0:ZY.inputs)||!ZY.inputs[0]||!ZY.inputs[0].shape)return;const s={};s.resize=Zp.resizeBilinear(e,[ZY.inputs[0].shape[2],ZY.inputs[0].shape[1]],!1),s.enhance=zl(s.resize,YY.tf255);const o={age:0};if(t.face.ssrnet.enabled&&(s.age=ZY.execute(s.enhance)),s.age){const e=await s.age.data();o.age=Math.trunc(10*e[0])/10}Object.keys(s).forEach((e=>yi(s[e]))),QY[n]=o,eJ=r,tJ=h(),a(o)})))}var aJ,sJ=[],oJ=0,iJ=0,lJ=Number.MAX_SAFE_INTEGER,uJ=[.2989,.587,.114];async function cJ(e,t,n,r){var a,s,o,i;if(!JY)return{gender:"unknown",genderScore:0};const l=lJ<((null==(a=t.face.ssrnet)?void 0:a.skipFrames)||0),u=((null==(s=t.face.ssrnet)?void 0:s.skipTime)||0)>h()-iJ;return t.skipAllowed&&l&&u&&oJ===r&&(null==(o=sJ[n])?void 0:o.gender)&&(null==(i=sJ[n])?void 0:i.genderScore)>0?(lJ++,sJ[n]):(lJ=0,new Promise((async a=>{if(!(null==JY?void 0:JY.inputs[0].shape))return;const s={};s.resize=Zp.resizeBilinear(e,[JY.inputs[0].shape[2],JY.inputs[0].shape[1]],!1),s.enhance=gi((()=>{const[e,t,n]=ch(s.resize,3,3),r=zl(e,uJ[0]),a=zl(t,uJ[1]),o=zl(n,uJ[2]),i=Wl([r,a,o]);return zl(Zc(i,YY.tf05),2)}));const o={gender:"unknown",genderScore:0};t.face.ssrnet.enabled&&(s.gender=JY.execute(s.enhance));const i=await s.gender.data();o.gender=i[0]>i[1]?"female":"male",o.genderScore=i[0]>i[1]?Math.trunc(100*i[0])/100:Math.trunc(100*i[1])/100,Object.keys(s).forEach((e=>yi(s[e]))),sJ[n]=o,oJ=r,iJ=h(),a(o)})))}var dJ=[],hJ=Number.MAX_SAFE_INTEGER,pJ=0,fJ=0;async function mJ(e,t,n,r){var a,s;if(!aJ)return 0;const o=((null==(a=t.face.antispoof)?void 0:a.skipTime)||0)>h()-fJ,i=hJ<((null==(s=t.face.antispoof)?void 0:s.skipFrames)||0);return t.skipAllowed&&o&&i&&pJ===r&&dJ[n]?(hJ++,dJ[n]):(hJ=0,new Promise((async t=>{const a=Zp.resizeBilinear(e,[(null==aJ?void 0:aJ.inputs[0].shape)?aJ.inputs[0].shape[2]:0,(null==aJ?void 0:aJ.inputs[0].shape)?aJ.inputs[0].shape[1]:0],!1),s=null==aJ?void 0:aJ.execute(a),o=(await s.data())[0];dJ[n]=Math.round(100*o)/100,pJ=r,fJ=h(),yi([a,s]),t(dJ[n])})))}var AJ={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[185,40,39,37,0,267,269,270,409],lipsLowerOuter:[61,146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[191,80,81,82,13,312,311,310,415],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],lipsLowerSemiOuter:[76,77,90,180,85,16,315,404,320,307,306],lipsUpperSemiOuter:[184,74,73,72,11,302,303,304,408],lipsLowerSemiInner:[62,96,89,179,86,15,316,403,319,325,292],lipsUpperSemiInner:[183,42,41,38,12,268,271,272,407],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],leftEyeIris:[468,469,470,471,472],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]},gJ={count:468,mouth:13,symmetryLine:[13,AJ.midwayBetweenEyes[0]]},yJ={leftEye:0,rightEye:1,nose:2,mouth:3,leftEar:4,rightEar:5,symmetryLine:[3,2]},xJ=[{key:"EyeUpper0",indices:[9,10,11,12,13,14,15]},{key:"EyeUpper1",indices:[25,26,27,28,29,30,31]},{key:"EyeUpper2",indices:[41,42,43,44,45,46,47]},{key:"EyeLower0",indices:[0,1,2,3,4,5,6,7,8]},{key:"EyeLower1",indices:[16,17,18,19,20,21,22,23,24]},{key:"EyeLower2",indices:[32,33,34,35,36,37,38,39,40]},{key:"EyeLower3",indices:[54,55,56,57,58,59,60,61,62]},{key:"EyebrowUpper",indices:[63,64,65,66,67,68,69,70]},{key:"EyebrowLower",indices:[48,49,50,51,52,53]}],bJ=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]],vJ=[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255];[127,234,132,58,172,150,149,148,152,377,378,379,397,288,361,454,356,70,63,105,66,107,336,296,334,293,300,168,6,195,4,98,97,2,326,327,33,160,158,133,153,144,362,385,387,263,373,380,57,40,37,0,267,270,287,321,314,17,84,91,78,81,13,311,308,402,14,178].map((e=>bJ[e])),[33,133,362,263,1,62,308,159,145,386,374,6,102,331,2,13,14,70,105,107,336,334,300,54,10,284,50,280,234,454,58,288,152].map((e=>bJ[e])),[33,133,362,263,1,78,308].map((e=>bJ[e]));function wJ(e){const t=e.map((e=>e[0]));return t.push(e[e.length-1][1]),t}wJ([[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]]),wJ([[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]]),wJ([[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]]),wJ([[474,475],[475,476],[476,477],[477,474]]),wJ([[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]]),wJ([[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]]),wJ([[469,470],[470,471],[471,472],[472,469]]),wJ([[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]]);var kJ=e=>[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])],SJ=e=>[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2,1],IJ=(e,t)=>e?[Math.trunc(Math.max(0,e.startPoint[0])),Math.trunc(Math.max(0,e.startPoint[1])),Math.trunc(Math.min(t.shape[2]||0,e.endPoint[0])-Math.max(0,e.startPoint[0])),Math.trunc(Math.min(t.shape[1]||0,e.endPoint[1])-Math.max(0,e.startPoint[1]))]:[0,0,0,0],CJ=(e,t)=>e?[e.startPoint[0]/(t.shape[2]||0),e.startPoint[1]/(t.shape[1]||0),(e.endPoint[0]-e.startPoint[0])/(t.shape[2]||0),(e.endPoint[1]-e.startPoint[1])/(t.shape[1]||0)]:[0,0,0,0],EJ=(e,t,n)=>{const r=t.shape[1],a=t.shape[2],s=[e.startPoint[1]/r,e.startPoint[0]/a,e.endPoint[1]/r,e.endPoint[0]/a],o=Zp.cropAndResize(t,[s],[0],n),i=Dl(o,YY.tf255);return yi(o),i},NJ=(e,t)=>{const n=SJ(e),r=kJ(e),a=[t*r[0]/2,t*r[1]/2];return{startPoint:[n[0]-a[0],n[1]-a[1]],endPoint:[n[0]+a[0],n[1]+a[1]],landmarks:e.landmarks,confidence:e.confidence}},TJ=e=>{const t=SJ(e),n=kJ(e),r=Math.max(...n)/2;return{startPoint:[Math.round(t[0]-r),Math.round(t[1]-r)],endPoint:[Math.round(t[0]+r),Math.round(t[1]+r)],landmarks:e.landmarks,confidence:e.confidence}},RJ=[[1,0,0],[0,1,0],[0,0,1]],_J=(e,t)=>{return(n=Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0]))-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI));var n},MJ=(e,t)=>[[1,0,e],[0,1,t],[0,0,1]],$J=(e,t)=>{let n=0;for(let r=0;r<e.length;r++)n+=e[r]*t[r];return n},FJ=(e,t)=>{const n=[];for(let r=0;r<e.length;r++)n.push(e[r][t]);return n},OJ=(e,t)=>{const n=[],r=e.length;for(let a=0;a<r;a++){n.push([]);for(let s=0;s<r;s++)n[a].push($J(e[a],FJ(t,s)))}return n},DJ=(e,t)=>{const n=Math.cos(e),r=Math.sin(e),a=[[n,-r,0],[r,n,0],[0,0,1]],s=MJ(t[0],t[1]),o=OJ(s,a),i=MJ(-t[0],-t[1]);return OJ(o,i)},zJ=(e,t)=>[$J(e,t[0]),$J(e,t[1])];function PJ(e,t,n,r,a){const s=kJ(t),o=e.map((e=>[s[0]/a*(e[0]-a/2),s[1]/a*(e[1]-a/2),e[2]||0])),i=n&&0!==n&&Math.abs(n)>.2,l=i?DJ(n,[0,0]):RJ,u=i?o.map((e=>[...zJ(e,l),e[2]])):o,c=i?(e=>{const t=[[e[0][0],e[1][0]],[e[0][1],e[1][1]]],n=[e[0][2],e[1][2]],r=[-$J(t[0],n),-$J(t[1],n)];return[t[0].concat(r[0]),t[1].concat(r[1]),[0,0,1]]})(r):RJ,d=SJ(t),h=[$J(d,c[0]),$J(d,c[1])];return u.map((e=>[Math.trunc(e[0]+h[0]),Math.trunc(e[1]+h[1]),Math.trunc(e[2]||0)]))}function LJ(e,t,n,r){const a=t.landmarks.length>=gJ.count?gJ.symmetryLine:yJ.symmetryLine;let s,o=0,i=RJ;if(e&&HZ.kernels.includes("rotatewithoffset")){o=_J(t.landmarks[a[0]],t.landmarks[a[1]]);if(o&&0!==o&&Math.abs(o)>.2){const e=SJ(t),a=[e[0]/n.shape[2],e[1]/n.shape[1]],l=Zp.rotateWithOffset(n,o,0,a);i=DJ(-o,e),s=EJ(t,l,[r,r]),yi(l)}else s=EJ(t,n,[r,r])}else s=EJ(t,n,[r,r]);return[o,i,s]}var BJ,WJ=(e,t)=>{const n=(e=>{const t=e.map((e=>e[0])),n=e.map((e=>e[1]));return[Math.min(...t)+(Math.max(...t)-Math.min(...t))/2,Math.min(...n)+(Math.max(...n)-Math.min(...n))/2]})(e),r=kJ(t);return{startPoint:[n[0]-r[0]/2,n[1]-r[1]/2],endPoint:[n[0]+r[0]/2,n[1]+r[1]/2]}},UJ=null,VJ=0,jJ=null,GJ=()=>VJ;async function HJ(e){var t;return HZ.initial&&(BJ=null),BJ?e.debug&&d("cached model:",BJ.modelUrl):BJ=await LY(null==(t=e.face.detector)?void 0:t.modelPath),VJ=BJ.inputs[0].shape?BJ.inputs[0].shape[2]:0,jJ=fc(VJ,"int32"),UJ=xh(function(e){const t=192===e?{strides:[4],anchors:[1]}:{strides:[e/16,e/8],anchors:[2,6]},n=[];for(let r=0;r<t.strides.length;r++){const a=t.strides[r],s=Math.floor((e+a-1)/a),o=Math.floor((e+a-1)/a),i=t.anchors[r];for(let e=0;e<s;e++){const t=a*(e+.5);for(let e=0;e<o;e++){const r=a*(e+.5);for(let e=0;e<i;e++)n.push([r,t])}}}return n}(VJ)),BJ}async function qJ(e,t){var n,r,a,s;if(!e||e.isDisposedInternal||4!==e.shape.length||e.shape[1]<1||e.shape[2]<1)return[];const o={};o.resized=Zp.resizeBilinear(e,[VJ,VJ]),o.div=Dl(o.resized,YY.tf127),o.normalized=Zc(o.div,YY.tf05);const i=null==BJ?void 0:BJ.execute(o.normalized);if(Array.isArray(i)&&i.length>2){const e=i.sort(((e,t)=>e.size-t.size));o.concat384=fu([e[0],e[2]],2),o.concat512=fu([e[1],e[3]],2),o.concat=fu([o.concat512,o.concat384],1),o.batch=ph(o.concat,0)}else Array.isArray(i)?o.batch=ph(i[0]):o.batch=ph(i);yi(i),o.boxes=function(e){const t={};t.boxStarts=Au(e,[0,1],[-1,2]),t.centers=Fl(t.boxStarts,UJ),t.boxSizes=Au(e,[0,3],[-1,2]),t.boxSizesNormalized=Dl(t.boxSizes,jJ),t.centersNormalized=Dl(t.centers,jJ),t.halfBoxSize=Dl(t.boxSizesNormalized,YY.tf2),t.starts=Zc(t.centersNormalized,t.halfBoxSize),t.ends=Fl(t.centersNormalized,t.halfBoxSize),t.startNormalized=zl(t.starts,jJ),t.endNormalized=zl(t.ends,jJ);const n=Ru([t.startNormalized,t.endNormalized],1);return Object.keys(t).forEach((e=>yi(t[e]))),n}(o.batch),o.logits=Au(o.batch,[0,0],[-1,1]),o.sigmoid=mu(o.logits),o.scores=ph(o.sigmoid),o.nms=await Zp.nonMaxSuppressionAsync(o.boxes,o.scores,(null==(n=t.face.detector)?void 0:n.maxDetected)||0,(null==(r=t.face.detector)?void 0:r.iouThreshold)||0,(null==(a=t.face.detector)?void 0:a.minConfidence)||0);const l=await o.nms.array(),u=[],c=await o.scores.data();for(let n=0;n<l.length;n++){const r=c[l[n]];if(r>((null==(s=t.face.detector)?void 0:s.minConfidence)||0)){const a={};a.bbox=Au(o.boxes,[l[n],0],[1,-1]),a.slice=Au(o.batch,[l[n],5],[1,-1]),a.squeeze=ph(a.slice),a.landmarks=du(a.squeeze,[6,-1]);const s=await a.bbox.data(),i={startPoint:[s[0],s[1]],endPoint:[s[2],s[3]],landmarks:await a.landmarks.array(),confidence:r},c=(d=i,h=[(e.shape[2]||0)/VJ,(e.shape[1]||0)/VJ],{startPoint:[d.startPoint[0]*h[0],d.startPoint[1]*h[1]],endPoint:[d.endPoint[0]*h[0],d.endPoint[1]*h[1]],landmarks:d.landmarks,confidence:d.confidence}),p=NJ(c,t.face.scale||1.4),f=TJ(p);u.push(f),Object.keys(a).forEach((e=>yi(a[e])))}}var d,h;return Object.keys(o).forEach((e=>yi(o[e]))),u}var XJ={};s(XJ,{connected:()=>ZJ,kpt:()=>KJ});var KJ=["nose","leftEyeInside","leftEye","leftEyeOutside","rightEyeInside","rightEye","rightEyeOutside","leftEar","rightEar","leftMouth","rightMouth","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftPinky","rightPinky","leftIndex","rightIndex","leftThumb","rightThumb","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle","leftHeel","rightHeel","leftFoot","rightFoot","bodyCenter","bodyTop","leftPalm","leftHand","rightPalm","rightHand"],ZJ={shoulders:["leftShoulder","rightShoulder"],hips:["rightHip","leftHip"],mouth:["leftMouth","rightMouth"],leftLegUpper:["leftHip","leftKnee"],leftLegLower:["leftKnee","leftAnkle"],leftFoot:["leftAnkle","leftHeel","leftFoot"],leftTorso:["leftShoulder","leftHip"],leftArmUpper:["leftShoulder","leftElbow"],leftArmLower:["leftElbow","leftWrist"],leftHand:["leftWrist","leftPalm"],leftHandPinky:["leftPalm","leftPinky"],leftHandIndex:["leftPalm","leftIndex"],leftHandThumb:["leftPalm","leftThumb"],leftEyeOutline:["leftEyeInside","leftEyeOutside"],rightLegUpper:["rightHip","rightKnee"],rightLegLower:["rightKnee","rightAnkle"],rightFoot:["rightAnkle","rightHeel","rightFoot"],rightTorso:["rightShoulder","rightHip"],rightArmUpper:["rightShoulder","rightElbow"],rightArmLower:["rightElbow","rightWrist"],rightHand:["rightWrist","rightPalm"],rightHandPinky:["rightPalm","rightPinky"],rightHandIndex:["rightPalm","rightIndex"],rightHandThumb:["rightPalm","rightThumb"],rightEyeOutline:["rightEyeInside","rightEyeOutside"]},YJ=[8,16,32,32,32];function JJ(e,t=[1,1]){const n=[e.map((e=>e[0])),e.map((e=>e[1]))],r=[Math.min(...n[0]),Math.min(...n[1])],a=[Math.max(...n[0]),Math.max(...n[1])],s=[r[0],r[1],a[0]-r[0],a[1]-r[1]];return{box:s,boxRaw:[s[0]/t[0],s[1]/t[1],s[2]/t[0],s[3]/t[1]]}}function QJ(e,t=[1,1]){const n=[e.map((e=>e[0])),e.map((e=>e[1]))],r=[Math.min(...n[0]),Math.min(...n[1])],a=[Math.max(...n[0]),Math.max(...n[1])],s=[(r[0]+a[0])/2,(r[1]+a[1])/2],o=Math.max(s[0]-r[0],s[1]-r[1],-s[0]+a[0],-s[1]+a[1]),i=[Math.trunc(s[0]-o),Math.trunc(s[1]-o),Math.trunc(2*o),Math.trunc(2*o)];return{box:i,boxRaw:[i[0]/t[0],i[1]/t[1],i[2]/t[0],i[3]/t[1]]}}function eQ(e,t){const n=[e[2]*t,e[3]*t];return[e[0]-(n[0]-e[2])/2,e[1]-(n[1]-e[3])/2,n[0],n[1]]}var tQ=!0,nQ={detector:null,landmarks:null},rQ={detector:[224,224],landmarks:[256,256]},aQ=Number.MAX_SAFE_INTEGER,sQ=["ld_3d","activation_segmentation","activation_heatmap","world_3d","output_poseflag"],oQ=null,iQ=[[0,0],[0,0],[0,0],[0,0]],lQ=0,uQ=e=>1-1/(1+Math.exp(e));async function cQ(e){if(tQ&&(nQ.detector=null),!nQ.detector&&e.body.detector&&e.body.detector.modelPath){nQ.detector=await LY(e.body.detector.modelPath);const t=Object.values(nQ.detector.modelSignature.inputs);rQ.detector[0]=Array.isArray(t)?parseInt(t[0].tensorShape.dim[1].size):0,rQ.detector[1]=Array.isArray(t)?parseInt(t[0].tensorShape.dim[2].size):0}else e.debug&&nQ.detector&&d("cached model:",nQ.detector.modelUrl);return await async function(){const e=[];let t=0;for(;t<5;){let n=0,r=t;for(;r<YJ.length&&YJ[r]===YJ[t];)n+=2,r++;const a=YJ[t],s=Math.ceil(224/a),o=Math.ceil(224/a);for(let t=0;t<s;++t)for(let r=0;r<o;++r)for(let a=0;a<n;++a)e.push({x:(r+.5)/o,y:(t+.5)/s});t=r}({x:yh(e.map((e=>e.x))),y:yh(e.map((e=>e.y)))})}(),nQ.detector}async function dQ(e,t,n){var r;const a={};[a.ld,a.segmentation,a.heatmap,a.world,a.poseflag]=null==(r=nQ.landmarks)?void 0:r.execute(e,sQ);const s=(await a.poseflag.data())[0],o=await a.ld.data(),i=await a.world.data();Object.keys(a).forEach((e=>yi(a[e])));const l=[];for(let e=0;e<o.length/5;e++){const t=uQ(o[5*e+3]),r=uQ(o[5*e+4]),a=Math.trunc(100*t*r*s)/100,u=[o[5*e+0]/rQ.landmarks[0],o[5*e+1]/rQ.landmarks[1],o[5*e+2]+0],c=[Math.trunc(n[0]*u[0]),Math.trunc(n[1]*u[1]),u[2]],d=[i[5*e+0],i[5*e+1],i[5*e+2]+0];l.push({part:KJ[e],positionRaw:u,position:c,distance:d,score:a})}if(s<(t.body.minConfidence||0))return null;!async function(e){const t=e.find((e=>"leftPalm"===e.part)),n=e.find((e=>"leftWrist"===e.part)),r=e.find((e=>"leftIndex"===e.part));t.position[2]=((n.position[2]||0)+(r.position[2]||0))/2;const a=e.find((e=>"rightPalm"===e.part)),s=e.find((e=>"rightWrist"===e.part)),o=e.find((e=>"rightIndex"===e.part));a.position[2]=((s.position[2]||0)+(o.position[2]||0))/2}(l);const u=function(e,t){for(const n of e)n.position=[Math.trunc(n.position[0]*(t[0]+iQ[2][0]+iQ[2][1])/t[0]-iQ[2][0]),Math.trunc(n.position[1]*(t[1]+iQ[1][0]+iQ[1][1])/t[1]-iQ[1][0]),n.position[2]],n.positionRaw=[n.position[0]/t[0],n.position[1]/t[1],2*n.position[2]/(t[0]+t[1])];return e}(l,n),c=JJ(u.map((e=>e.position)),[n[0],n[1]]),d={};for(const[e,t]of Object.entries(ZJ)){const n=[];for(let e=0;e<t.length-1;e++){const r=u.find((n=>n.part===t[e])),a=u.find((n=>n.part===t[e+1]));r&&a&&n.push([r.position,a.position])}d[e]=n}return{id:0,score:Math.trunc(100*s)/100,box:c.box,boxRaw:c.boxRaw,keypoints:u,annotations:d}}async function hQ(e,t){const n=[e.shape[2]||0,e.shape[1]||0],r=(t.body.skipTime||0)>h()-lQ,a=aQ<(t.body.skipFrames||0);if(t.skipAllowed&&r&&a&&null!==oQ)aQ++;else{const r={};r.landmarks=await async function(e,t){const n={};if(!e.shape||!e.shape[1]||!e.shape[2])return e;let r;if(e.shape[1]!==e.shape[2]){const a=[e.shape[2]>e.shape[1]?Math.trunc((e.shape[2]-e.shape[1])/2):0,e.shape[2]>e.shape[1]?Math.trunc((e.shape[2]-e.shape[1])/2):0],s=[e.shape[1]>e.shape[2]?Math.trunc((e.shape[1]-e.shape[2])/2):0,e.shape[1]>e.shape[2]?Math.trunc((e.shape[1]-e.shape[2])/2):0];iQ=[[0,0],a,s,[0,0]],n.pad=kd(n.cropped||e,iQ),n.resize=Zp.resizeBilinear(n.pad,[t,t]),r=Dl(n.resize,YY.tf255)}else e.shape[1]!==t?(n.resize=Zp.resizeBilinear(n.cropped||e,[t,t]),r=Dl(n.resize,YY.tf255)):r=Dl(n.cropped||e,YY.tf255);return Object.keys(n).forEach((e=>yi(n[e]))),r}(e,256),oQ=await dQ(r.landmarks,t,n),Object.keys(r).forEach((e=>yi(r[e]))),lQ=h(),aQ=0}return oQ?[oQ]:[]}var pQ,fQ=[{class:1,label:"person"},{class:2,label:"bicycle"},{class:3,label:"car"},{class:4,label:"motorcycle"},{class:5,label:"airplane"},{class:6,label:"bus"},{class:7,label:"train"},{class:8,label:"truck"},{class:9,label:"boat"},{class:10,label:"traffic light"},{class:11,label:"fire hydrant"},{class:12,label:"stop sign"},{class:13,label:"parking meter"},{class:14,label:"bench"},{class:15,label:"bird"},{class:16,label:"cat"},{class:17,label:"dog"},{class:18,label:"horse"},{class:19,label:"sheep"},{class:20,label:"cow"},{class:21,label:"elephant"},{class:22,label:"bear"},{class:23,label:"zebra"},{class:24,label:"giraffe"},{class:25,label:"backpack"},{class:26,label:"umbrella"},{class:27,label:"handbag"},{class:28,label:"tie"},{class:29,label:"suitcase"},{class:30,label:"frisbee"},{class:31,label:"skis"},{class:32,label:"snowboard"},{class:33,label:"sports ball"},{class:34,label:"kite"},{class:35,label:"baseball bat"},{class:36,label:"baseball glove"},{class:37,label:"skateboard"},{class:38,label:"surfboard"},{class:39,label:"tennis racket"},{class:40,label:"bottle"},{class:41,label:"wine glass"},{class:42,label:"cup"},{class:43,label:"fork"},{class:44,label:"knife"},{class:45,label:"spoon"},{class:46,label:"bowl"},{class:47,label:"banana"},{class:48,label:"apple"},{class:49,label:"sandwich"},{class:50,label:"orange"},{class:51,label:"broccoli"},{class:52,label:"carrot"},{class:53,label:"hot dog"},{class:54,label:"pizza"},{class:55,label:"donut"},{class:56,label:"cake"},{class:57,label:"chair"},{class:58,label:"couch"},{class:59,label:"potted plant"},{class:60,label:"bed"},{class:61,label:"dining table"},{class:62,label:"toilet"},{class:63,label:"tv"},{class:64,label:"laptop"},{class:65,label:"mouse"},{class:66,label:"remote"},{class:67,label:"keyboard"},{class:68,label:"cell phone"},{class:69,label:"microwave"},{class:70,label:"oven"},{class:71,label:"toaster"},{class:72,label:"sink"},{class:73,label:"refrigerator"},{class:74,label:"book"},{class:75,label:"clock"},{class:76,label:"vase"},{class:77,label:"scissors"},{class:78,label:"teddy bear"},{class:79,label:"hair drier"},{class:80,label:"toothbrush"}],mQ=0,AQ=[],gQ=0,yQ=Number.MAX_SAFE_INTEGER;async function xQ(e,t){const n=(t.object.skipTime||0)>h()-gQ,r=yQ<(t.object.skipFrames||0);return t.skipAllowed&&n&&r&&AQ.length>0?(yQ++,AQ):(yQ=0,new Promise((async n=>{const r=[e.shape[2]||0,e.shape[1]||0],a=Zp.resizeBilinear(e,[mQ,mQ]),s=t.object.enabled?null==pQ?void 0:pQ.execute(a,["tower_0/detections"]):null;gQ=h(),yi(a);const o=await async function(e,t,n){if(!e)return[];const r={},a=[],s=await e.array();r.squeeze=ph(e);const o=ch(r.squeeze,6,1);r.stack=fh([o[1],o[0],o[3],o[2]],1),r.boxes=ph(r.stack),r.scores=ph(o[4]),r.classes=ph(o[5]),yi([e,...o]),r.nms=await Zp.nonMaxSuppressionAsync(r.boxes,r.scores,n.object.maxDetected,n.object.iouThreshold,n.object.minConfidence||0);const i=await r.nms.data();let l=0;for(const e of Array.from(i)){const n=Math.trunc(100*s[0][e][4])/100,r=s[0][e][5],o=fQ[r].label,[i,u]=[s[0][e][0]/mQ,s[0][e][1]/mQ],c=[i,u,s[0][e][2]/mQ-i,s[0][e][3]/mQ-u],d=[Math.trunc(c[0]*t[0]),Math.trunc(c[1]*t[1]),Math.trunc(c[2]*t[0]),Math.trunc(c[3]*t[1])];a.push({id:l++,score:n,class:r,label:o,box:d,boxRaw:c})}return Object.keys(r).forEach((e=>yi(r[e]))),a}(s,r,t);AQ=o,n(o)})))}var bQ={};s(bQ,{connected:()=>kQ,kpt:()=>wQ});var vQ,wQ=["head","neck","rightShoulder","rightElbow","rightWrist","chest","leftShoulder","leftElbow","leftWrist","bodyCenter","rightHip","rightKnee","rightAnkle","leftHip","leftKnee","leftAnkle"],kQ={leftLeg:["leftHip","leftKnee","leftAnkle"],rightLeg:["rightHip","rightKnee","rightAnkle"],torso:["leftShoulder","rightShoulder","rightHip","leftHip","leftShoulder"],leftArm:["leftShoulder","leftElbow","leftWrist"],rightArm:["rightShoulder","rightElbow","rightWrist"],head:[]},SQ=0,IQ={id:0,keypoints:[],box:[0,0,0,0],boxRaw:[0,0,0,0],score:0,annotations:{}},CQ=Number.MAX_SAFE_INTEGER;async function EQ(e,t){const[n,r]=e.shape,a=du(e,[r*n]),s=dc(a,0),o=(await s.data())[0];if(yi([a,s]),o>t){const e=jl(a,0),t=Ad(e,n),r=(await t.data())[0],s=Dl(e,fc(n,"int32")),i=(await s.data())[0];return yi([t,s]),[r,i,o]}return[0,0,o]}async function NQ(e,t){const n=(t.body.skipTime||0)>h()-SQ,r=CQ<(t.body.skipFrames||0);return t.skipAllowed&&n&&r&&Object.keys(IQ.keypoints).length>0?(CQ++,[IQ]):(CQ=0,new Promise((async n=>{var r;const a=gi((()=>{if(!(null==vQ?void 0:vQ.inputs[0].shape))return null;const t=Zp.resizeBilinear(e,[vQ.inputs[0].shape[2],vQ.inputs[0].shape[1]],!1),n=zl(t,YY.tf2);return Zc(n,YY.tf1)}));let s;if(t.body.enabled&&(s=null==vQ?void 0:vQ.execute(a)),SQ=h(),yi(a),s){IQ.keypoints.length=0;const n=s.squeeze();yi(s);const a=n.unstack(2);yi(n);for(let n=0;n<a.length;n++){const[s,o,i]=await EQ(a[n],t.body.minConfidence);i>((null==(r=t.body)?void 0:r.minConfidence)||0)&&IQ.keypoints.push({score:Math.round(100*i)/100,part:wQ[n],positionRaw:[s/vQ.inputs[0].shape[2],o/vQ.inputs[0].shape[1]],position:[Math.round(e.shape[2]*s/vQ.inputs[0].shape[2]),Math.round(e.shape[1]*o/vQ.inputs[0].shape[1])]})}a.forEach((e=>yi(e)))}IQ.score=IQ.keypoints.reduce(((e,t)=>t.score>e?t.score:e),0);const o=IQ.keypoints.map((e=>e.position[0])),i=IQ.keypoints.map((e=>e.position[1]));IQ.box=[Math.min(...o),Math.min(...i),Math.max(...o)-Math.min(...o),Math.max(...i)-Math.min(...i)];const l=IQ.keypoints.map((e=>e.positionRaw[0])),u=IQ.keypoints.map((e=>e.positionRaw[1]));IQ.boxRaw=[Math.min(...l),Math.min(...u),Math.max(...l)-Math.min(...l),Math.max(...u)-Math.min(...u)];for(const[e,n]of Object.entries(kQ)){const r=[];for(let e=0;e<n.length-1;e++){const a=IQ.keypoints.find((t=>t.part===n[e])),s=IQ.keypoints.find((t=>t.part===n[e+1]));a&&s&&a.score>(t.body.minConfidence||0)&&s.score>(t.body.minConfidence||0)&&r.push([a.position,s.position])}IQ.annotations[e]=r}n([IQ])})))}var TQ,RQ,_Q=["angry","disgust","fear","happy","sad","surprise","neutral"],MQ=[],$Q=0,FQ=0,OQ=Number.MAX_SAFE_INTEGER;async function DQ(e,t,n,r){var a,s;if(!TQ)return[];const o=OQ<((null==(a=t.face.emotion)?void 0:a.skipFrames)||0),i=((null==(s=t.face.emotion)?void 0:s.skipTime)||0)>h()-FQ;return t.skipAllowed&&i&&o&&$Q===r&&MQ[n]&&MQ[n].length>0?(OQ++,MQ[n]):(OQ=0,new Promise((async a=>{var s,o;const i=[];if(null==(s=t.face.emotion)?void 0:s.enabled){const n={},r=(null==TQ?void 0:TQ.inputs[0].shape)?TQ.inputs[0].shape[2]:0;n.resize=Zp.resizeBilinear(e,[r,r],!1),n.channels=zl(n.resize,YY.rgb),n.grayscale=gc(n.channels,3,!0),n.grayscaleSub=Zc(n.grayscale,YY.tf05),n.grayscaleMul=zl(n.grayscaleSub,YY.tf2),n.emotion=null==TQ?void 0:TQ.execute(n.grayscaleMul),FQ=h();const a=await n.emotion.data();for(let e=0;e<a.length;e++)a[e]>((null==(o=t.face.emotion)?void 0:o.minConfidence)||0)&&i.push({score:Math.min(.99,Math.trunc(100*a[e])/100),emotion:_Q[e]});i.sort(((e,t)=>t.score-e.score)),Object.keys(n).forEach((e=>yi(n[e])))}MQ[n]=i,$Q=r,a(i)})))}var zQ,PQ=[],LQ=0,BQ=0,WQ=Number.MAX_SAFE_INTEGER;async function UQ(e,t,n,r){var a,s;if(!RQ)return[];const o=WQ<((null==(a=t.face.embedding)?void 0:a.skipFrames)||0),i=((null==(s=t.face.embedding)?void 0:s.skipTime)||0)>h()-BQ;return t.skipAllowed&&i&&o&&LQ===r&&PQ[n]?(WQ++,PQ[n]):new Promise((async a=>{var s;let o=[];if((null==(s=t.face.embedding)?void 0:s.enabled)&&(null==RQ?void 0:RQ.inputs[0].shape)){const t={};t.crop=Zp.resizeBilinear(e,[RQ.inputs[0].shape[2],RQ.inputs[0].shape[1]],!1),t.data=null==RQ?void 0:RQ.execute(t.crop);const n=await t.data.data();o=Array.from(n)}PQ[n]=o,LQ=r,BQ=h(),a(o)}))}var VQ=0,jQ=AJ.leftEyeLower0,GQ=AJ.rightEyeLower0,HQ={leftBounds:[jQ[0],jQ[jQ.length-1]],rightBounds:[GQ[0],GQ[GQ.length-1]]},qQ=3,XQ=4,KQ=71,ZQ=76;function YQ(e,t,n,r){for(let a=0;a<xJ.length;a++){const{key:s,indices:o}=xJ[a],i=AJ[`${n}${s}`];if(!r||r.includes(s))for(let n=0;n<o.length;n++){const r=o[n];e[i[n]]=[t[r][0],t[r][1],(t[r][2]+e[i[n]][2])/2]}}}var JQ=(e,t,n,r,a,s=!1)=>{const o=TJ(NJ((e=>{const t=e.map((e=>e[0])),n=e.map((e=>e[1]));return{startPoint:[Math.min(...t),Math.min(...n)],endPoint:[Math.max(...t),Math.max(...n)],landmarks:e}})([e[n],e[r]]),2.3)),i=kJ(o);let l=Zp.cropAndResize(t,[[o.startPoint[1]/a,o.startPoint[0]/a,o.endPoint[1]/a,o.endPoint[0]/a]],[0],[VQ,VQ]);if(s&&HZ.kernels.includes("flipleftright")){const e=Zp.flipLeftRight(l);yi(l),l=e}return{box:o,boxSize:i,crop:l}},QQ=(e,t,n,r=!1)=>{const a=[];for(let s=0;s<ZQ;s++){const o=e[3*s],i=e[3*s+1],l=e[3*s+2];a.push([(r?1-o/VQ:o/VQ)*n[0]+t.startPoint[0],i/VQ*n[1]+t.startPoint[1],l])}return{rawCoords:a,iris:a.slice(KQ)}},e0=(e,t,n)=>{const r=e[AJ[`${n}EyeUpper0`][qQ]][2],a=e[AJ[`${n}EyeLower0`][XQ]][2],s=(r+a)/2;return t.map(((e,t)=>{let n=s;return 2===t?n=r:4===t&&(n=a),[e[0],e[1],n]}))};async function t0(e,t,n,r){if(!zQ)return n.debug&&d("face mesh iris detection requested, but model is not loaded"),e;const{box:a,boxSize:s,crop:o}=JQ(e,t,HQ.leftBounds[0],HQ.leftBounds[1],r,!0),{box:i,boxSize:l,crop:u}=JQ(e,t,HQ.rightBounds[0],HQ.rightBounds[1],r,!0),c=fu([o,u]);yi(o),yi(u);const h=zQ.execute(c);yi(c);const p=await h.data();yi(h);const f=p.slice(0,3*ZQ),{rawCoords:m,iris:A}=QQ(f,a,s,!0),g=p.slice(3*ZQ),{rawCoords:y,iris:x}=QQ(g,i,l,!1),b=(e=>e[HQ.leftBounds[0]][2]-e[HQ.rightBounds[0]][2])(e);Math.abs(b)<30?(YQ(e,m,"left",null),YQ(e,y,"right",null)):b<1?YQ(e,m,"left",["EyeUpper0","EyeLower0"]):YQ(e,y,"right",["EyeUpper0","EyeLower0"]);const v=e0(e,A,"left"),w=e0(e,x,"right");return e.concat(v).concat(w)}function n0(e){const t=e.map((e=>e[0]));return t.push(e[e.length-1][1]),t}var r0={lips:n0([[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]]),leftEye:n0([[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]]),leftEyebrow:n0([[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]]),leftIris:n0([[474,475],[475,476],[476,477],[477,474]]),rightEye:n0([[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]]),rightEyebrow:n0([[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]]),rightIris:n0([[469,470],[470,471],[471,472],[472,469]]),faceOval:n0([[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]])},a0=Object.entries(r0).map((([e,t])=>t.map((t=>[t,e])))).flat(),s0=(new Map(a0),[61,146,91,181,84,17,314,405,321,375,291,185,40,39,37,0,267,269,270,409,78,95,88,178,87,14,317,402,318,324,308,191,80,81,82,13,312,311,310,415,76,77,90,180,85,16,315,404,320,307,306,184,74,73,72,11,302,303,304,408,62,96,89,179,86,15,316,403,319,325,292,183,42,41,38,12,268,271,272,407]),o0=[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173,130,25,110,24,23,22,26,112,243,247,30,29,27,28,56,190,226,31,228,229,230,231,232,233,244,113,225,224,223,222,221,189,35,124,46,53,52,65,143,111,117,118,119,120,121,128,245,156,70,63,105,66,107,55,193],i0=[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398,359,255,339,254,253,252,256,341,463,467,260,259,257,258,286,414,446,261,448,449,450,451,452,453,464,342,445,444,443,442,441,413,265,353,276,283,282,295,372,340,346,347,348,349,350,357,465,383,300,293,334,296,336,285,417];async function l0(e,t){const n={lips:await t.filter((e=>160===e.size))[0].data(),irisL:await t.filter((e=>10===e.size))[0].data(),eyeL:await t.filter((e=>142===e.size))[0].data(),irisR:await t.filter((e=>10===e.size))[1].data(),eyeR:await t.filter((e=>142===e.size))[1].data()},r=o0.reduce(((t,n)=>t+e[n][2]),0)/o0.length;for(let t=0;t<n.irisL.length/2;t++)e.push([n.irisL[2*t+0],n.irisL[2*t+1],r]);const a=i0.reduce(((t,n)=>t+e[n][2]),0)/i0.length;for(let t=0;t<n.irisR.length/2;t++)e.push([n.irisR[2*t+0],n.irisR[2*t+1],a]);for(let t=0;t<n.eyeL.length/2;t++)e[o0[t]]=[n.eyeL[2*t+0],n.eyeL[2*t+1],e[o0[t]][2]];for(let t=0;t<n.eyeR.length/2;t++)e[i0[t]]=[n.eyeR[2*t+0],n.eyeR[2*t+1],e[i0[t]][2]];for(let t=0;t<n.lips.length/2;t++)e[s0[t]]=[n.lips[2*t+0],n.lips[2*t+1],e[s0[t]][2]];return e}var u0={boxes:[],skipped:Number.MAX_SAFE_INTEGER,timestamp:0},c0=null,d0=0;var h0,p0=vJ,f0=bJ,m0=[],A0=0,g0=0,y0=Number.MAX_SAFE_INTEGER;function x0(e){const t=e.image||e.tensor||e;if(!(null==h0?void 0:h0.inputs[0].shape))return t;const n=Zp.resizeBilinear(t,[h0.inputs[0].shape[2],h0.inputs[0].shape[1]],!1),r=zl(n,YY.tf255);return yi(n),r}async function b0(e,t,n,r){var a,s,o,i;if(!h0)return{age:0,gender:"unknown",genderScore:0,descriptor:[]};const l=y0<((null==(a=t.face.description)?void 0:a.skipFrames)||0),u=((null==(s=t.face.description)?void 0:s.skipTime)||0)>h()-A0;return t.skipAllowed&&l&&u&&g0===r&&(null==(o=m0[n])?void 0:o.age)&&(null==(i=m0[n])?void 0:i.age)>0?(y0++,m0[n]):(y0=0,new Promise((async a=>{var s,o;const i={age:0,gender:"unknown",genderScore:0,descriptor:[]};if(null==(s=t.face.description)?void 0:s.enabled){const n=x0(e),r=null==h0?void 0:h0.execute(n);A0=h(),yi(n);const a=await r.find((e=>1===e.shape[1])),s=await a.data(),l=Math.trunc(200*Math.abs(s[0]-.5))/100;l>((null==(o=t.face.description)?void 0:o.minConfidence)||0)&&(i.gender=s[0]<=.5?"female":"male",i.genderScore=Math.min(.99,l));const u=jl(r.find((e=>100===e.shape[1])),1),c=(await u.data())[0];yi(u);const d=r.find((e=>100===e.shape[1])),p=await d.data();i.age=Math.round(p[c-1]>p[c+1]?10*c-100*p[c-1]:10*c+100*p[c+1])/10;const f=r.find((e=>1024===e.shape[1])),m=f?await f.data():[];i.descriptor=Array.from(m),r.forEach((e=>yi(e)))}m0[n]=i,g0=r,a(i)})))}function v0(e){return[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])]}function w0(e){return[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2]}function k0(e,t,n){const r=t.shape[1],a=t.shape[2],s=[[e.startPoint[1]/r,e.startPoint[0]/a,e.endPoint[1]/r,e.endPoint[0]/a]];return Zp.cropAndResize(t,s,[0],n)}function S0(e,t){return{startPoint:[e.startPoint[0]*t[0],e.startPoint[1]*t[1]],endPoint:[e.endPoint[0]*t[0],e.endPoint[1]*t[1]],palmLandmarks:e.palmLandmarks.map((e=>[e[0]*t[0],e[1]*t[1]])),confidence:e.confidence}}function I0(e,t=1.5){const n=w0(e),r=v0(e),a=[t*r[0]/2,t*r[1]/2];return{startPoint:[n[0]-a[0],n[1]-a[1]],endPoint:[n[0]+a[0],n[1]+a[1]],palmLandmarks:e.palmLandmarks}}function C0(e){const t=w0(e),n=v0(e),r=Math.max(...n)/2;return{startPoint:[t[0]-r,t[1]-r],endPoint:[t[0]+r,t[1]+r],palmLandmarks:e.palmLandmarks}}function E0(e,t){const n=Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0]);return(r=n)-2*Math.PI*Math.floor((r+Math.PI)/(2*Math.PI));var r}var N0=(e,t)=>[[1,0,e],[0,1,t],[0,0,1]];function T0(e,t){let n=0;for(let r=0;r<e.length;r++)n+=e[r]*t[r];return n}function R0(e,t){const n=[];for(let r=0;r<e.length;r++)n.push(e[r][t]);return n}function _0(e,t){const n=[],r=e.length;for(let a=0;a<r;a++){n.push([]);for(let s=0;s<r;s++)n[a].push(T0(e[a],R0(t,s)))}return n}function M0(e,t){const n=Math.cos(e),r=Math.sin(e),a=[[n,-r,0],[r,n,0],[0,0,1]],s=_0(N0(t[0],t[1]),a);return _0(s,N0(-t[0],-t[1]))}function $0(e,t){return[T0(e,t[0]),T0(e,t[1])]}var F0=[{x:.015625,y:.015625},{x:.015625,y:.015625},{x:.046875,y:.015625},{x:.046875,y:.015625},{x:.078125,y:.015625},{x:.078125,y:.015625},{x:.109375,y:.015625},{x:.109375,y:.015625},{x:.140625,y:.015625},{x:.140625,y:.015625},{x:.171875,y:.015625},{x:.171875,y:.015625},{x:.203125,y:.015625},{x:.203125,y:.015625},{x:.234375,y:.015625},{x:.234375,y:.015625},{x:.265625,y:.015625},{x:.265625,y:.015625},{x:.296875,y:.015625},{x:.296875,y:.015625},{x:.328125,y:.015625},{x:.328125,y:.015625},{x:.359375,y:.015625},{x:.359375,y:.015625},{x:.390625,y:.015625},{x:.390625,y:.015625},{x:.421875,y:.015625},{x:.421875,y:.015625},{x:.453125,y:.015625},{x:.453125,y:.015625},{x:.484375,y:.015625},{x:.484375,y:.015625},{x:.515625,y:.015625},{x:.515625,y:.015625},{x:.546875,y:.015625},{x:.546875,y:.015625},{x:.578125,y:.015625},{x:.578125,y:.015625},{x:.609375,y:.015625},{x:.609375,y:.015625},{x:.640625,y:.015625},{x:.640625,y:.015625},{x:.671875,y:.015625},{x:.671875,y:.015625},{x:.703125,y:.015625},{x:.703125,y:.015625},{x:.734375,y:.015625},{x:.734375,y:.015625},{x:.765625,y:.015625},{x:.765625,y:.015625},{x:.796875,y:.015625},{x:.796875,y:.015625},{x:.828125,y:.015625},{x:.828125,y:.015625},{x:.859375,y:.015625},{x:.859375,y:.015625},{x:.890625,y:.015625},{x:.890625,y:.015625},{x:.921875,y:.015625},{x:.921875,y:.015625},{x:.953125,y:.015625},{x:.953125,y:.015625},{x:.984375,y:.015625},{x:.984375,y:.015625},{x:.015625,y:.046875},{x:.015625,y:.046875},{x:.046875,y:.046875},{x:.046875,y:.046875},{x:.078125,y:.046875},{x:.078125,y:.046875},{x:.109375,y:.046875},{x:.109375,y:.046875},{x:.140625,y:.046875},{x:.140625,y:.046875},{x:.171875,y:.046875},{x:.171875,y:.046875},{x:.203125,y:.046875},{x:.203125,y:.046875},{x:.234375,y:.046875},{x:.234375,y:.046875},{x:.265625,y:.046875},{x:.265625,y:.046875},{x:.296875,y:.046875},{x:.296875,y:.046875},{x:.328125,y:.046875},{x:.328125,y:.046875},{x:.359375,y:.046875},{x:.359375,y:.046875},{x:.390625,y:.046875},{x:.390625,y:.046875},{x:.421875,y:.046875},{x:.421875,y:.046875},{x:.453125,y:.046875},{x:.453125,y:.046875},{x:.484375,y:.046875},{x:.484375,y:.046875},{x:.515625,y:.046875},{x:.515625,y:.046875},{x:.546875,y:.046875},{x:.546875,y:.046875},{x:.578125,y:.046875},{x:.578125,y:.046875},{x:.609375,y:.046875},{x:.609375,y:.046875},{x:.640625,y:.046875},{x:.640625,y:.046875},{x:.671875,y:.046875},{x:.671875,y:.046875},{x:.703125,y:.046875},{x:.703125,y:.046875},{x:.734375,y:.046875},{x:.734375,y:.046875},{x:.765625,y:.046875},{x:.765625,y:.046875},{x:.796875,y:.046875},{x:.796875,y:.046875},{x:.828125,y:.046875},{x:.828125,y:.046875},{x:.859375,y:.046875},{x:.859375,y:.046875},{x:.890625,y:.046875},{x:.890625,y:.046875},{x:.921875,y:.046875},{x:.921875,y:.046875},{x:.953125,y:.046875},{x:.953125,y:.046875},{x:.984375,y:.046875},{x:.984375,y:.046875},{x:.015625,y:.078125},{x:.015625,y:.078125},{x:.046875,y:.078125},{x:.046875,y:.078125},{x:.078125,y:.078125},{x:.078125,y:.078125},{x:.109375,y:.078125},{x:.109375,y:.078125},{x:.140625,y:.078125},{x:.140625,y:.078125},{x:.171875,y:.078125},{x:.171875,y:.078125},{x:.203125,y:.078125},{x:.203125,y:.078125},{x:.234375,y:.078125},{x:.234375,y:.078125},{x:.265625,y:.078125},{x:.265625,y:.078125},{x:.296875,y:.078125},{x:.296875,y:.078125},{x:.328125,y:.078125},{x:.328125,y:.078125},{x:.359375,y:.078125},{x:.359375,y:.078125},{x:.390625,y:.078125},{x:.390625,y:.078125},{x:.421875,y:.078125},{x:.421875,y:.078125},{x:.453125,y:.078125},{x:.453125,y:.078125},{x:.484375,y:.078125},{x:.484375,y:.078125},{x:.515625,y:.078125},{x:.515625,y:.078125},{x:.546875,y:.078125},{x:.546875,y:.078125},{x:.578125,y:.078125},{x:.578125,y:.078125},{x:.609375,y:.078125},{x:.609375,y:.078125},{x:.640625,y:.078125},{x:.640625,y:.078125},{x:.671875,y:.078125},{x:.671875,y:.078125},{x:.703125,y:.078125},{x:.703125,y:.078125},{x:.734375,y:.078125},{x:.734375,y:.078125},{x:.765625,y:.078125},{x:.765625,y:.078125},{x:.796875,y:.078125},{x:.796875,y:.078125},{x:.828125,y:.078125},{x:.828125,y:.078125},{x:.859375,y:.078125},{x:.859375,y:.078125},{x:.890625,y:.078125},{x:.890625,y:.078125},{x:.921875,y:.078125},{x:.921875,y:.078125},{x:.953125,y:.078125},{x:.953125,y:.078125},{x:.984375,y:.078125},{x:.984375,y:.078125},{x:.015625,y:.109375},{x:.015625,y:.109375},{x:.046875,y:.109375},{x:.046875,y:.109375},{x:.078125,y:.109375},{x:.078125,y:.109375},{x:.109375,y:.109375},{x:.109375,y:.109375},{x:.140625,y:.109375},{x:.140625,y:.109375},{x:.171875,y:.109375},{x:.171875,y:.109375},{x:.203125,y:.109375},{x:.203125,y:.109375},{x:.234375,y:.109375},{x:.234375,y:.109375},{x:.265625,y:.109375},{x:.265625,y:.109375},{x:.296875,y:.109375},{x:.296875,y:.109375},{x:.328125,y:.109375},{x:.328125,y:.109375},{x:.359375,y:.109375},{x:.359375,y:.109375},{x:.390625,y:.109375},{x:.390625,y:.109375},{x:.421875,y:.109375},{x:.421875,y:.109375},{x:.453125,y:.109375},{x:.453125,y:.109375},{x:.484375,y:.109375},{x:.484375,y:.109375},{x:.515625,y:.109375},{x:.515625,y:.109375},{x:.546875,y:.109375},{x:.546875,y:.109375},{x:.578125,y:.109375},{x:.578125,y:.109375},{x:.609375,y:.109375},{x:.609375,y:.109375},{x:.640625,y:.109375},{x:.640625,y:.109375},{x:.671875,y:.109375},{x:.671875,y:.109375},{x:.703125,y:.109375},{x:.703125,y:.109375},{x:.734375,y:.109375},{x:.734375,y:.109375},{x:.765625,y:.109375},{x:.765625,y:.109375},{x:.796875,y:.109375},{x:.796875,y:.109375},{x:.828125,y:.109375},{x:.828125,y:.109375},{x:.859375,y:.109375},{x:.859375,y:.109375},{x:.890625,y:.109375},{x:.890625,y:.109375},{x:.921875,y:.109375},{x:.921875,y:.109375},{x:.953125,y:.109375},{x:.953125,y:.109375},{x:.984375,y:.109375},{x:.984375,y:.109375},{x:.015625,y:.140625},{x:.015625,y:.140625},{x:.046875,y:.140625},{x:.046875,y:.140625},{x:.078125,y:.140625},{x:.078125,y:.140625},{x:.109375,y:.140625},{x:.109375,y:.140625},{x:.140625,y:.140625},{x:.140625,y:.140625},{x:.171875,y:.140625},{x:.171875,y:.140625},{x:.203125,y:.140625},{x:.203125,y:.140625},{x:.234375,y:.140625},{x:.234375,y:.140625},{x:.265625,y:.140625},{x:.265625,y:.140625},{x:.296875,y:.140625},{x:.296875,y:.140625},{x:.328125,y:.140625},{x:.328125,y:.140625},{x:.359375,y:.140625},{x:.359375,y:.140625},{x:.390625,y:.140625},{x:.390625,y:.140625},{x:.421875,y:.140625},{x:.421875,y:.140625},{x:.453125,y:.140625},{x:.453125,y:.140625},{x:.484375,y:.140625},{x:.484375,y:.140625},{x:.515625,y:.140625},{x:.515625,y:.140625},{x:.546875,y:.140625},{x:.546875,y:.140625},{x:.578125,y:.140625},{x:.578125,y:.140625},{x:.609375,y:.140625},{x:.609375,y:.140625},{x:.640625,y:.140625},{x:.640625,y:.140625},{x:.671875,y:.140625},{x:.671875,y:.140625},{x:.703125,y:.140625},{x:.703125,y:.140625},{x:.734375,y:.140625},{x:.734375,y:.140625},{x:.765625,y:.140625},{x:.765625,y:.140625},{x:.796875,y:.140625},{x:.796875,y:.140625},{x:.828125,y:.140625},{x:.828125,y:.140625},{x:.859375,y:.140625},{x:.859375,y:.140625},{x:.890625,y:.140625},{x:.890625,y:.140625},{x:.921875,y:.140625},{x:.921875,y:.140625},{x:.953125,y:.140625},{x:.953125,y:.140625},{x:.984375,y:.140625},{x:.984375,y:.140625},{x:.015625,y:.171875},{x:.015625,y:.171875},{x:.046875,y:.171875},{x:.046875,y:.171875},{x:.078125,y:.171875},{x:.078125,y:.171875},{x:.109375,y:.171875},{x:.109375,y:.171875},{x:.140625,y:.171875},{x:.140625,y:.171875},{x:.171875,y:.171875},{x:.171875,y:.171875},{x:.203125,y:.171875},{x:.203125,y:.171875},{x:.234375,y:.171875},{x:.234375,y:.171875},{x:.265625,y:.171875},{x:.265625,y:.171875},{x:.296875,y:.171875},{x:.296875,y:.171875},{x:.328125,y:.171875},{x:.328125,y:.171875},{x:.359375,y:.171875},{x:.359375,y:.171875},{x:.390625,y:.171875},{x:.390625,y:.171875},{x:.421875,y:.171875},{x:.421875,y:.171875},{x:.453125,y:.171875},{x:.453125,y:.171875},{x:.484375,y:.171875},{x:.484375,y:.171875},{x:.515625,y:.171875},{x:.515625,y:.171875},{x:.546875,y:.171875},{x:.546875,y:.171875},{x:.578125,y:.171875},{x:.578125,y:.171875},{x:.609375,y:.171875},{x:.609375,y:.171875},{x:.640625,y:.171875},{x:.640625,y:.171875},{x:.671875,y:.171875},{x:.671875,y:.171875},{x:.703125,y:.171875},{x:.703125,y:.171875},{x:.734375,y:.171875},{x:.734375,y:.171875},{x:.765625,y:.171875},{x:.765625,y:.171875},{x:.796875,y:.171875},{x:.796875,y:.171875},{x:.828125,y:.171875},{x:.828125,y:.171875},{x:.859375,y:.171875},{x:.859375,y:.171875},{x:.890625,y:.171875},{x:.890625,y:.171875},{x:.921875,y:.171875},{x:.921875,y:.171875},{x:.953125,y:.171875},{x:.953125,y:.171875},{x:.984375,y:.171875},{x:.984375,y:.171875},{x:.015625,y:.203125},{x:.015625,y:.203125},{x:.046875,y:.203125},{x:.046875,y:.203125},{x:.078125,y:.203125},{x:.078125,y:.203125},{x:.109375,y:.203125},{x:.109375,y:.203125},{x:.140625,y:.203125},{x:.140625,y:.203125},{x:.171875,y:.203125},{x:.171875,y:.203125},{x:.203125,y:.203125},{x:.203125,y:.203125},{x:.234375,y:.203125},{x:.234375,y:.203125},{x:.265625,y:.203125},{x:.265625,y:.203125},{x:.296875,y:.203125},{x:.296875,y:.203125},{x:.328125,y:.203125},{x:.328125,y:.203125},{x:.359375,y:.203125},{x:.359375,y:.203125},{x:.390625,y:.203125},{x:.390625,y:.203125},{x:.421875,y:.203125},{x:.421875,y:.203125},{x:.453125,y:.203125},{x:.453125,y:.203125},{x:.484375,y:.203125},{x:.484375,y:.203125},{x:.515625,y:.203125},{x:.515625,y:.203125},{x:.546875,y:.203125},{x:.546875,y:.203125},{x:.578125,y:.203125},{x:.578125,y:.203125},{x:.609375,y:.203125},{x:.609375,y:.203125},{x:.640625,y:.203125},{x:.640625,y:.203125},{x:.671875,y:.203125},{x:.671875,y:.203125},{x:.703125,y:.203125},{x:.703125,y:.203125},{x:.734375,y:.203125},{x:.734375,y:.203125},{x:.765625,y:.203125},{x:.765625,y:.203125},{x:.796875,y:.203125},{x:.796875,y:.203125},{x:.828125,y:.203125},{x:.828125,y:.203125},{x:.859375,y:.203125},{x:.859375,y:.203125},{x:.890625,y:.203125},{x:.890625,y:.203125},{x:.921875,y:.203125},{x:.921875,y:.203125},{x:.953125,y:.203125},{x:.953125,y:.203125},{x:.984375,y:.203125},{x:.984375,y:.203125},{x:.015625,y:.234375},{x:.015625,y:.234375},{x:.046875,y:.234375},{x:.046875,y:.234375},{x:.078125,y:.234375},{x:.078125,y:.234375},{x:.109375,y:.234375},{x:.109375,y:.234375},{x:.140625,y:.234375},{x:.140625,y:.234375},{x:.171875,y:.234375},{x:.171875,y:.234375},{x:.203125,y:.234375},{x:.203125,y:.234375},{x:.234375,y:.234375},{x:.234375,y:.234375},{x:.265625,y:.234375},{x:.265625,y:.234375},{x:.296875,y:.234375},{x:.296875,y:.234375},{x:.328125,y:.234375},{x:.328125,y:.234375},{x:.359375,y:.234375},{x:.359375,y:.234375},{x:.390625,y:.234375},{x:.390625,y:.234375},{x:.421875,y:.234375},{x:.421875,y:.234375},{x:.453125,y:.234375},{x:.453125,y:.234375},{x:.484375,y:.234375},{x:.484375,y:.234375},{x:.515625,y:.234375},{x:.515625,y:.234375},{x:.546875,y:.234375},{x:.546875,y:.234375},{x:.578125,y:.234375},{x:.578125,y:.234375},{x:.609375,y:.234375},{x:.609375,y:.234375},{x:.640625,y:.234375},{x:.640625,y:.234375},{x:.671875,y:.234375},{x:.671875,y:.234375},{x:.703125,y:.234375},{x:.703125,y:.234375},{x:.734375,y:.234375},{x:.734375,y:.234375},{x:.765625,y:.234375},{x:.765625,y:.234375},{x:.796875,y:.234375},{x:.796875,y:.234375},{x:.828125,y:.234375},{x:.828125,y:.234375},{x:.859375,y:.234375},{x:.859375,y:.234375},{x:.890625,y:.234375},{x:.890625,y:.234375},{x:.921875,y:.234375},{x:.921875,y:.234375},{x:.953125,y:.234375},{x:.953125,y:.234375},{x:.984375,y:.234375},{x:.984375,y:.234375},{x:.015625,y:.265625},{x:.015625,y:.265625},{x:.046875,y:.265625},{x:.046875,y:.265625},{x:.078125,y:.265625},{x:.078125,y:.265625},{x:.109375,y:.265625},{x:.109375,y:.265625},{x:.140625,y:.265625},{x:.140625,y:.265625},{x:.171875,y:.265625},{x:.171875,y:.265625},{x:.203125,y:.265625},{x:.203125,y:.265625},{x:.234375,y:.265625},{x:.234375,y:.265625},{x:.265625,y:.265625},{x:.265625,y:.265625},{x:.296875,y:.265625},{x:.296875,y:.265625},{x:.328125,y:.265625},{x:.328125,y:.265625},{x:.359375,y:.265625},{x:.359375,y:.265625},{x:.390625,y:.265625},{x:.390625,y:.265625},{x:.421875,y:.265625},{x:.421875,y:.265625},{x:.453125,y:.265625},{x:.453125,y:.265625},{x:.484375,y:.265625},{x:.484375,y:.265625},{x:.515625,y:.265625},{x:.515625,y:.265625},{x:.546875,y:.265625},{x:.546875,y:.265625},{x:.578125,y:.265625},{x:.578125,y:.265625},{x:.609375,y:.265625},{x:.609375,y:.265625},{x:.640625,y:.265625},{x:.640625,y:.265625},{x:.671875,y:.265625},{x:.671875,y:.265625},{x:.703125,y:.265625},{x:.703125,y:.265625},{x:.734375,y:.265625},{x:.734375,y:.265625},{x:.765625,y:.265625},{x:.765625,y:.265625},{x:.796875,y:.265625},{x:.796875,y:.265625},{x:.828125,y:.265625},{x:.828125,y:.265625},{x:.859375,y:.265625},{x:.859375,y:.265625},{x:.890625,y:.265625},{x:.890625,y:.265625},{x:.921875,y:.265625},{x:.921875,y:.265625},{x:.953125,y:.265625},{x:.953125,y:.265625},{x:.984375,y:.265625},{x:.984375,y:.265625},{x:.015625,y:.296875},{x:.015625,y:.296875},{x:.046875,y:.296875},{x:.046875,y:.296875},{x:.078125,y:.296875},{x:.078125,y:.296875},{x:.109375,y:.296875},{x:.109375,y:.296875},{x:.140625,y:.296875},{x:.140625,y:.296875},{x:.171875,y:.296875},{x:.171875,y:.296875},{x:.203125,y:.296875},{x:.203125,y:.296875},{x:.234375,y:.296875},{x:.234375,y:.296875},{x:.265625,y:.296875},{x:.265625,y:.296875},{x:.296875,y:.296875},{x:.296875,y:.296875},{x:.328125,y:.296875},{x:.328125,y:.296875},{x:.359375,y:.296875},{x:.359375,y:.296875},{x:.390625,y:.296875},{x:.390625,y:.296875},{x:.421875,y:.296875},{x:.421875,y:.296875},{x:.453125,y:.296875},{x:.453125,y:.296875},{x:.484375,y:.296875},{x:.484375,y:.296875},{x:.515625,y:.296875},{x:.515625,y:.296875},{x:.546875,y:.296875},{x:.546875,y:.296875},{x:.578125,y:.296875},{x:.578125,y:.296875},{x:.609375,y:.296875},{x:.609375,y:.296875},{x:.640625,y:.296875},{x:.640625,y:.296875},{x:.671875,y:.296875},{x:.671875,y:.296875},{x:.703125,y:.296875},{x:.703125,y:.296875},{x:.734375,y:.296875},{x:.734375,y:.296875},{x:.765625,y:.296875},{x:.765625,y:.296875},{x:.796875,y:.296875},{x:.796875,y:.296875},{x:.828125,y:.296875},{x:.828125,y:.296875},{x:.859375,y:.296875},{x:.859375,y:.296875},{x:.890625,y:.296875},{x:.890625,y:.296875},{x:.921875,y:.296875},{x:.921875,y:.296875},{x:.953125,y:.296875},{x:.953125,y:.296875},{x:.984375,y:.296875},{x:.984375,y:.296875},{x:.015625,y:.328125},{x:.015625,y:.328125},{x:.046875,y:.328125},{x:.046875,y:.328125},{x:.078125,y:.328125},{x:.078125,y:.328125},{x:.109375,y:.328125},{x:.109375,y:.328125},{x:.140625,y:.328125},{x:.140625,y:.328125},{x:.171875,y:.328125},{x:.171875,y:.328125},{x:.203125,y:.328125},{x:.203125,y:.328125},{x:.234375,y:.328125},{x:.234375,y:.328125},{x:.265625,y:.328125},{x:.265625,y:.328125},{x:.296875,y:.328125},{x:.296875,y:.328125},{x:.328125,y:.328125},{x:.328125,y:.328125},{x:.359375,y:.328125},{x:.359375,y:.328125},{x:.390625,y:.328125},{x:.390625,y:.328125},{x:.421875,y:.328125},{x:.421875,y:.328125},{x:.453125,y:.328125},{x:.453125,y:.328125},{x:.484375,y:.328125},{x:.484375,y:.328125},{x:.515625,y:.328125},{x:.515625,y:.328125},{x:.546875,y:.328125},{x:.546875,y:.328125},{x:.578125,y:.328125},{x:.578125,y:.328125},{x:.609375,y:.328125},{x:.609375,y:.328125},{x:.640625,y:.328125},{x:.640625,y:.328125},{x:.671875,y:.328125},{x:.671875,y:.328125},{x:.703125,y:.328125},{x:.703125,y:.328125},{x:.734375,y:.328125},{x:.734375,y:.328125},{x:.765625,y:.328125},{x:.765625,y:.328125},{x:.796875,y:.328125},{x:.796875,y:.328125},{x:.828125,y:.328125},{x:.828125,y:.328125},{x:.859375,y:.328125},{x:.859375,y:.328125},{x:.890625,y:.328125},{x:.890625,y:.328125},{x:.921875,y:.328125},{x:.921875,y:.328125},{x:.953125,y:.328125},{x:.953125,y:.328125},{x:.984375,y:.328125},{x:.984375,y:.328125},{x:.015625,y:.359375},{x:.015625,y:.359375},{x:.046875,y:.359375},{x:.046875,y:.359375},{x:.078125,y:.359375},{x:.078125,y:.359375},{x:.109375,y:.359375},{x:.109375,y:.359375},{x:.140625,y:.359375},{x:.140625,y:.359375},{x:.171875,y:.359375},{x:.171875,y:.359375},{x:.203125,y:.359375},{x:.203125,y:.359375},{x:.234375,y:.359375},{x:.234375,y:.359375},{x:.265625,y:.359375},{x:.265625,y:.359375},{x:.296875,y:.359375},{x:.296875,y:.359375},{x:.328125,y:.359375},{x:.328125,y:.359375},{x:.359375,y:.359375},{x:.359375,y:.359375},{x:.390625,y:.359375},{x:.390625,y:.359375},{x:.421875,y:.359375},{x:.421875,y:.359375},{x:.453125,y:.359375},{x:.453125,y:.359375},{x:.484375,y:.359375},{x:.484375,y:.359375},{x:.515625,y:.359375},{x:.515625,y:.359375},{x:.546875,y:.359375},{x:.546875,y:.359375},{x:.578125,y:.359375},{x:.578125,y:.359375},{x:.609375,y:.359375},{x:.609375,y:.359375},{x:.640625,y:.359375},{x:.640625,y:.359375},{x:.671875,y:.359375},{x:.671875,y:.359375},{x:.703125,y:.359375},{x:.703125,y:.359375},{x:.734375,y:.359375},{x:.734375,y:.359375},{x:.765625,y:.359375},{x:.765625,y:.359375},{x:.796875,y:.359375},{x:.796875,y:.359375},{x:.828125,y:.359375},{x:.828125,y:.359375},{x:.859375,y:.359375},{x:.859375,y:.359375},{x:.890625,y:.359375},{x:.890625,y:.359375},{x:.921875,y:.359375},{x:.921875,y:.359375},{x:.953125,y:.359375},{x:.953125,y:.359375},{x:.984375,y:.359375},{x:.984375,y:.359375},{x:.015625,y:.390625},{x:.015625,y:.390625},{x:.046875,y:.390625},{x:.046875,y:.390625},{x:.078125,y:.390625},{x:.078125,y:.390625},{x:.109375,y:.390625},{x:.109375,y:.390625},{x:.140625,y:.390625},{x:.140625,y:.390625},{x:.171875,y:.390625},{x:.171875,y:.390625},{x:.203125,y:.390625},{x:.203125,y:.390625},{x:.234375,y:.390625},{x:.234375,y:.390625},{x:.265625,y:.390625},{x:.265625,y:.390625},{x:.296875,y:.390625},{x:.296875,y:.390625},{x:.328125,y:.390625},{x:.328125,y:.390625},{x:.359375,y:.390625},{x:.359375,y:.390625},{x:.390625,y:.390625},{x:.390625,y:.390625},{x:.421875,y:.390625},{x:.421875,y:.390625},{x:.453125,y:.390625},{x:.453125,y:.390625},{x:.484375,y:.390625},{x:.484375,y:.390625},{x:.515625,y:.390625},{x:.515625,y:.390625},{x:.546875,y:.390625},{x:.546875,y:.390625},{x:.578125,y:.390625},{x:.578125,y:.390625},{x:.609375,y:.390625},{x:.609375,y:.390625},{x:.640625,y:.390625},{x:.640625,y:.390625},{x:.671875,y:.390625},{x:.671875,y:.390625},{x:.703125,y:.390625},{x:.703125,y:.390625},{x:.734375,y:.390625},{x:.734375,y:.390625},{x:.765625,y:.390625},{x:.765625,y:.390625},{x:.796875,y:.390625},{x:.796875,y:.390625},{x:.828125,y:.390625},{x:.828125,y:.390625},{x:.859375,y:.390625},{x:.859375,y:.390625},{x:.890625,y:.390625},{x:.890625,y:.390625},{x:.921875,y:.390625},{x:.921875,y:.390625},{x:.953125,y:.390625},{x:.953125,y:.390625},{x:.984375,y:.390625},{x:.984375,y:.390625},{x:.015625,y:.421875},{x:.015625,y:.421875},{x:.046875,y:.421875},{x:.046875,y:.421875},{x:.078125,y:.421875},{x:.078125,y:.421875},{x:.109375,y:.421875},{x:.109375,y:.421875},{x:.140625,y:.421875},{x:.140625,y:.421875},{x:.171875,y:.421875},{x:.171875,y:.421875},{x:.203125,y:.421875},{x:.203125,y:.421875},{x:.234375,y:.421875},{x:.234375,y:.421875},{x:.265625,y:.421875},{x:.265625,y:.421875},{x:.296875,y:.421875},{x:.296875,y:.421875},{x:.328125,y:.421875},{x:.328125,y:.421875},{x:.359375,y:.421875},{x:.359375,y:.421875},{x:.390625,y:.421875},{x:.390625,y:.421875},{x:.421875,y:.421875},{x:.421875,y:.421875},{x:.453125,y:.421875},{x:.453125,y:.421875},{x:.484375,y:.421875},{x:.484375,y:.421875},{x:.515625,y:.421875},{x:.515625,y:.421875},{x:.546875,y:.421875},{x:.546875,y:.421875},{x:.578125,y:.421875},{x:.578125,y:.421875},{x:.609375,y:.421875},{x:.609375,y:.421875},{x:.640625,y:.421875},{x:.640625,y:.421875},{x:.671875,y:.421875},{x:.671875,y:.421875},{x:.703125,y:.421875},{x:.703125,y:.421875},{x:.734375,y:.421875},{x:.734375,y:.421875},{x:.765625,y:.421875},{x:.765625,y:.421875},{x:.796875,y:.421875},{x:.796875,y:.421875},{x:.828125,y:.421875},{x:.828125,y:.421875},{x:.859375,y:.421875},{x:.859375,y:.421875},{x:.890625,y:.421875},{x:.890625,y:.421875},{x:.921875,y:.421875},{x:.921875,y:.421875},{x:.953125,y:.421875},{x:.953125,y:.421875},{x:.984375,y:.421875},{x:.984375,y:.421875},{x:.015625,y:.453125},{x:.015625,y:.453125},{x:.046875,y:.453125},{x:.046875,y:.453125},{x:.078125,y:.453125},{x:.078125,y:.453125},{x:.109375,y:.453125},{x:.109375,y:.453125},{x:.140625,y:.453125},{x:.140625,y:.453125},{x:.171875,y:.453125},{x:.171875,y:.453125},{x:.203125,y:.453125},{x:.203125,y:.453125},{x:.234375,y:.453125},{x:.234375,y:.453125},{x:.265625,y:.453125},{x:.265625,y:.453125},{x:.296875,y:.453125},{x:.296875,y:.453125},{x:.328125,y:.453125},{x:.328125,y:.453125},{x:.359375,y:.453125},{x:.359375,y:.453125},{x:.390625,y:.453125},{x:.390625,y:.453125},{x:.421875,y:.453125},{x:.421875,y:.453125},{x:.453125,y:.453125},{x:.453125,y:.453125},{x:.484375,y:.453125},{x:.484375,y:.453125},{x:.515625,y:.453125},{x:.515625,y:.453125},{x:.546875,y:.453125},{x:.546875,y:.453125},{x:.578125,y:.453125},{x:.578125,y:.453125},{x:.609375,y:.453125},{x:.609375,y:.453125},{x:.640625,y:.453125},{x:.640625,y:.453125},{x:.671875,y:.453125},{x:.671875,y:.453125},{x:.703125,y:.453125},{x:.703125,y:.453125},{x:.734375,y:.453125},{x:.734375,y:.453125},{x:.765625,y:.453125},{x:.765625,y:.453125},{x:.796875,y:.453125},{x:.796875,y:.453125},{x:.828125,y:.453125},{x:.828125,y:.453125},{x:.859375,y:.453125},{x:.859375,y:.453125},{x:.890625,y:.453125},{x:.890625,y:.453125},{x:.921875,y:.453125},{x:.921875,y:.453125},{x:.953125,y:.453125},{x:.953125,y:.453125},{x:.984375,y:.453125},{x:.984375,y:.453125},{x:.015625,y:.484375},{x:.015625,y:.484375},{x:.046875,y:.484375},{x:.046875,y:.484375},{x:.078125,y:.484375},{x:.078125,y:.484375},{x:.109375,y:.484375},{x:.109375,y:.484375},{x:.140625,y:.484375},{x:.140625,y:.484375},{x:.171875,y:.484375},{x:.171875,y:.484375},{x:.203125,y:.484375},{x:.203125,y:.484375},{x:.234375,y:.484375},{x:.234375,y:.484375},{x:.265625,y:.484375},{x:.265625,y:.484375},{x:.296875,y:.484375},{x:.296875,y:.484375},{x:.328125,y:.484375},{x:.328125,y:.484375},{x:.359375,y:.484375},{x:.359375,y:.484375},{x:.390625,y:.484375},{x:.390625,y:.484375},{x:.421875,y:.484375},{x:.421875,y:.484375},{x:.453125,y:.484375},{x:.453125,y:.484375},{x:.484375,y:.484375},{x:.484375,y:.484375},{x:.515625,y:.484375},{x:.515625,y:.484375},{x:.546875,y:.484375},{x:.546875,y:.484375},{x:.578125,y:.484375},{x:.578125,y:.484375},{x:.609375,y:.484375},{x:.609375,y:.484375},{x:.640625,y:.484375},{x:.640625,y:.484375},{x:.671875,y:.484375},{x:.671875,y:.484375},{x:.703125,y:.484375},{x:.703125,y:.484375},{x:.734375,y:.484375},{x:.734375,y:.484375},{x:.765625,y:.484375},{x:.765625,y:.484375},{x:.796875,y:.484375},{x:.796875,y:.484375},{x:.828125,y:.484375},{x:.828125,y:.484375},{x:.859375,y:.484375},{x:.859375,y:.484375},{x:.890625,y:.484375},{x:.890625,y:.484375},{x:.921875,y:.484375},{x:.921875,y:.484375},{x:.953125,y:.484375},{x:.953125,y:.484375},{x:.984375,y:.484375},{x:.984375,y:.484375},{x:.015625,y:.515625},{x:.015625,y:.515625},{x:.046875,y:.515625},{x:.046875,y:.515625},{x:.078125,y:.515625},{x:.078125,y:.515625},{x:.109375,y:.515625},{x:.109375,y:.515625},{x:.140625,y:.515625},{x:.140625,y:.515625},{x:.171875,y:.515625},{x:.171875,y:.515625},{x:.203125,y:.515625},{x:.203125,y:.515625},{x:.234375,y:.515625},{x:.234375,y:.515625},{x:.265625,y:.515625},{x:.265625,y:.515625},{x:.296875,y:.515625},{x:.296875,y:.515625},{x:.328125,y:.515625},{x:.328125,y:.515625},{x:.359375,y:.515625},{x:.359375,y:.515625},{x:.390625,y:.515625},{x:.390625,y:.515625},{x:.421875,y:.515625},{x:.421875,y:.515625},{x:.453125,y:.515625},{x:.453125,y:.515625},{x:.484375,y:.515625},{x:.484375,y:.515625},{x:.515625,y:.515625},{x:.515625,y:.515625},{x:.546875,y:.515625},{x:.546875,y:.515625},{x:.578125,y:.515625},{x:.578125,y:.515625},{x:.609375,y:.515625},{x:.609375,y:.515625},{x:.640625,y:.515625},{x:.640625,y:.515625},{x:.671875,y:.515625},{x:.671875,y:.515625},{x:.703125,y:.515625},{x:.703125,y:.515625},{x:.734375,y:.515625},{x:.734375,y:.515625},{x:.765625,y:.515625},{x:.765625,y:.515625},{x:.796875,y:.515625},{x:.796875,y:.515625},{x:.828125,y:.515625},{x:.828125,y:.515625},{x:.859375,y:.515625},{x:.859375,y:.515625},{x:.890625,y:.515625},{x:.890625,y:.515625},{x:.921875,y:.515625},{x:.921875,y:.515625},{x:.953125,y:.515625},{x:.953125,y:.515625},{x:.984375,y:.515625},{x:.984375,y:.515625},{x:.015625,y:.546875},{x:.015625,y:.546875},{x:.046875,y:.546875},{x:.046875,y:.546875},{x:.078125,y:.546875},{x:.078125,y:.546875},{x:.109375,y:.546875},{x:.109375,y:.546875},{x:.140625,y:.546875},{x:.140625,y:.546875},{x:.171875,y:.546875},{x:.171875,y:.546875},{x:.203125,y:.546875},{x:.203125,y:.546875},{x:.234375,y:.546875},{x:.234375,y:.546875},{x:.265625,y:.546875},{x:.265625,y:.546875},{x:.296875,y:.546875},{x:.296875,y:.546875},{x:.328125,y:.546875},{x:.328125,y:.546875},{x:.359375,y:.546875},{x:.359375,y:.546875},{x:.390625,y:.546875},{x:.390625,y:.546875},{x:.421875,y:.546875},{x:.421875,y:.546875},{x:.453125,y:.546875},{x:.453125,y:.546875},{x:.484375,y:.546875},{x:.484375,y:.546875},{x:.515625,y:.546875},{x:.515625,y:.546875},{x:.546875,y:.546875},{x:.546875,y:.546875},{x:.578125,y:.546875},{x:.578125,y:.546875},{x:.609375,y:.546875},{x:.609375,y:.546875},{x:.640625,y:.546875},{x:.640625,y:.546875},{x:.671875,y:.546875},{x:.671875,y:.546875},{x:.703125,y:.546875},{x:.703125,y:.546875},{x:.734375,y:.546875},{x:.734375,y:.546875},{x:.765625,y:.546875},{x:.765625,y:.546875},{x:.796875,y:.546875},{x:.796875,y:.546875},{x:.828125,y:.546875},{x:.828125,y:.546875},{x:.859375,y:.546875},{x:.859375,y:.546875},{x:.890625,y:.546875},{x:.890625,y:.546875},{x:.921875,y:.546875},{x:.921875,y:.546875},{x:.953125,y:.546875},{x:.953125,y:.546875},{x:.984375,y:.546875},{x:.984375,y:.546875},{x:.015625,y:.578125},{x:.015625,y:.578125},{x:.046875,y:.578125},{x:.046875,y:.578125},{x:.078125,y:.578125},{x:.078125,y:.578125},{x:.109375,y:.578125},{x:.109375,y:.578125},{x:.140625,y:.578125},{x:.140625,y:.578125},{x:.171875,y:.578125},{x:.171875,y:.578125},{x:.203125,y:.578125},{x:.203125,y:.578125},{x:.234375,y:.578125},{x:.234375,y:.578125},{x:.265625,y:.578125},{x:.265625,y:.578125},{x:.296875,y:.578125},{x:.296875,y:.578125},{x:.328125,y:.578125},{x:.328125,y:.578125},{x:.359375,y:.578125},{x:.359375,y:.578125},{x:.390625,y:.578125},{x:.390625,y:.578125},{x:.421875,y:.578125},{x:.421875,y:.578125},{x:.453125,y:.578125},{x:.453125,y:.578125},{x:.484375,y:.578125},{x:.484375,y:.578125},{x:.515625,y:.578125},{x:.515625,y:.578125},{x:.546875,y:.578125},{x:.546875,y:.578125},{x:.578125,y:.578125},{x:.578125,y:.578125},{x:.609375,y:.578125},{x:.609375,y:.578125},{x:.640625,y:.578125},{x:.640625,y:.578125},{x:.671875,y:.578125},{x:.671875,y:.578125},{x:.703125,y:.578125},{x:.703125,y:.578125},{x:.734375,y:.578125},{x:.734375,y:.578125},{x:.765625,y:.578125},{x:.765625,y:.578125},{x:.796875,y:.578125},{x:.796875,y:.578125},{x:.828125,y:.578125},{x:.828125,y:.578125},{x:.859375,y:.578125},{x:.859375,y:.578125},{x:.890625,y:.578125},{x:.890625,y:.578125},{x:.921875,y:.578125},{x:.921875,y:.578125},{x:.953125,y:.578125},{x:.953125,y:.578125},{x:.984375,y:.578125},{x:.984375,y:.578125},{x:.015625,y:.609375},{x:.015625,y:.609375},{x:.046875,y:.609375},{x:.046875,y:.609375},{x:.078125,y:.609375},{x:.078125,y:.609375},{x:.109375,y:.609375},{x:.109375,y:.609375},{x:.140625,y:.609375},{x:.140625,y:.609375},{x:.171875,y:.609375},{x:.171875,y:.609375},{x:.203125,y:.609375},{x:.203125,y:.609375},{x:.234375,y:.609375},{x:.234375,y:.609375},{x:.265625,y:.609375},{x:.265625,y:.609375},{x:.296875,y:.609375},{x:.296875,y:.609375},{x:.328125,y:.609375},{x:.328125,y:.609375},{x:.359375,y:.609375},{x:.359375,y:.609375},{x:.390625,y:.609375},{x:.390625,y:.609375},{x:.421875,y:.609375},{x:.421875,y:.609375},{x:.453125,y:.609375},{x:.453125,y:.609375},{x:.484375,y:.609375},{x:.484375,y:.609375},{x:.515625,y:.609375},{x:.515625,y:.609375},{x:.546875,y:.609375},{x:.546875,y:.609375},{x:.578125,y:.609375},{x:.578125,y:.609375},{x:.609375,y:.609375},{x:.609375,y:.609375},{x:.640625,y:.609375},{x:.640625,y:.609375},{x:.671875,y:.609375},{x:.671875,y:.609375},{x:.703125,y:.609375},{x:.703125,y:.609375},{x:.734375,y:.609375},{x:.734375,y:.609375},{x:.765625,y:.609375},{x:.765625,y:.609375},{x:.796875,y:.609375},{x:.796875,y:.609375},{x:.828125,y:.609375},{x:.828125,y:.609375},{x:.859375,y:.609375},{x:.859375,y:.609375},{x:.890625,y:.609375},{x:.890625,y:.609375},{x:.921875,y:.609375},{x:.921875,y:.609375},{x:.953125,y:.609375},{x:.953125,y:.609375},{x:.984375,y:.609375},{x:.984375,y:.609375},{x:.015625,y:.640625},{x:.015625,y:.640625},{x:.046875,y:.640625},{x:.046875,y:.640625},{x:.078125,y:.640625},{x:.078125,y:.640625},{x:.109375,y:.640625},{x:.109375,y:.640625},{x:.140625,y:.640625},{x:.140625,y:.640625},{x:.171875,y:.640625},{x:.171875,y:.640625},{x:.203125,y:.640625},{x:.203125,y:.640625},{x:.234375,y:.640625},{x:.234375,y:.640625},{x:.265625,y:.640625},{x:.265625,y:.640625},{x:.296875,y:.640625},{x:.296875,y:.640625},{x:.328125,y:.640625},{x:.328125,y:.640625},{x:.359375,y:.640625},{x:.359375,y:.640625},{x:.390625,y:.640625},{x:.390625,y:.640625},{x:.421875,y:.640625},{x:.421875,y:.640625},{x:.453125,y:.640625},{x:.453125,y:.640625},{x:.484375,y:.640625},{x:.484375,y:.640625},{x:.515625,y:.640625},{x:.515625,y:.640625},{x:.546875,y:.640625},{x:.546875,y:.640625},{x:.578125,y:.640625},{x:.578125,y:.640625},{x:.609375,y:.640625},{x:.609375,y:.640625},{x:.640625,y:.640625},{x:.640625,y:.640625},{x:.671875,y:.640625},{x:.671875,y:.640625},{x:.703125,y:.640625},{x:.703125,y:.640625},{x:.734375,y:.640625},{x:.734375,y:.640625},{x:.765625,y:.640625},{x:.765625,y:.640625},{x:.796875,y:.640625},{x:.796875,y:.640625},{x:.828125,y:.640625},{x:.828125,y:.640625},{x:.859375,y:.640625},{x:.859375,y:.640625},{x:.890625,y:.640625},{x:.890625,y:.640625},{x:.921875,y:.640625},{x:.921875,y:.640625},{x:.953125,y:.640625},{x:.953125,y:.640625},{x:.984375,y:.640625},{x:.984375,y:.640625},{x:.015625,y:.671875},{x:.015625,y:.671875},{x:.046875,y:.671875},{x:.046875,y:.671875},{x:.078125,y:.671875},{x:.078125,y:.671875},{x:.109375,y:.671875},{x:.109375,y:.671875},{x:.140625,y:.671875},{x:.140625,y:.671875},{x:.171875,y:.671875},{x:.171875,y:.671875},{x:.203125,y:.671875},{x:.203125,y:.671875},{x:.234375,y:.671875},{x:.234375,y:.671875},{x:.265625,y:.671875},{x:.265625,y:.671875},{x:.296875,y:.671875},{x:.296875,y:.671875},{x:.328125,y:.671875},{x:.328125,y:.671875},{x:.359375,y:.671875},{x:.359375,y:.671875},{x:.390625,y:.671875},{x:.390625,y:.671875},{x:.421875,y:.671875},{x:.421875,y:.671875},{x:.453125,y:.671875},{x:.453125,y:.671875},{x:.484375,y:.671875},{x:.484375,y:.671875},{x:.515625,y:.671875},{x:.515625,y:.671875},{x:.546875,y:.671875},{x:.546875,y:.671875},{x:.578125,y:.671875},{x:.578125,y:.671875},{x:.609375,y:.671875},{x:.609375,y:.671875},{x:.640625,y:.671875},{x:.640625,y:.671875},{x:.671875,y:.671875},{x:.671875,y:.671875},{x:.703125,y:.671875},{x:.703125,y:.671875},{x:.734375,y:.671875},{x:.734375,y:.671875},{x:.765625,y:.671875},{x:.765625,y:.671875},{x:.796875,y:.671875},{x:.796875,y:.671875},{x:.828125,y:.671875},{x:.828125,y:.671875},{x:.859375,y:.671875},{x:.859375,y:.671875},{x:.890625,y:.671875},{x:.890625,y:.671875},{x:.921875,y:.671875},{x:.921875,y:.671875},{x:.953125,y:.671875},{x:.953125,y:.671875},{x:.984375,y:.671875},{x:.984375,y:.671875},{x:.015625,y:.703125},{x:.015625,y:.703125},{x:.046875,y:.703125},{x:.046875,y:.703125},{x:.078125,y:.703125},{x:.078125,y:.703125},{x:.109375,y:.703125},{x:.109375,y:.703125},{x:.140625,y:.703125},{x:.140625,y:.703125},{x:.171875,y:.703125},{x:.171875,y:.703125},{x:.203125,y:.703125},{x:.203125,y:.703125},{x:.234375,y:.703125},{x:.234375,y:.703125},{x:.265625,y:.703125},{x:.265625,y:.703125},{x:.296875,y:.703125},{x:.296875,y:.703125},{x:.328125,y:.703125},{x:.328125,y:.703125},{x:.359375,y:.703125},{x:.359375,y:.703125},{x:.390625,y:.703125},{x:.390625,y:.703125},{x:.421875,y:.703125},{x:.421875,y:.703125},{x:.453125,y:.703125},{x:.453125,y:.703125},{x:.484375,y:.703125},{x:.484375,y:.703125},{x:.515625,y:.703125},{x:.515625,y:.703125},{x:.546875,y:.703125},{x:.546875,y:.703125},{x:.578125,y:.703125},{x:.578125,y:.703125},{x:.609375,y:.703125},{x:.609375,y:.703125},{x:.640625,y:.703125},{x:.640625,y:.703125},{x:.671875,y:.703125},{x:.671875,y:.703125},{x:.703125,y:.703125},{x:.703125,y:.703125},{x:.734375,y:.703125},{x:.734375,y:.703125},{x:.765625,y:.703125},{x:.765625,y:.703125},{x:.796875,y:.703125},{x:.796875,y:.703125},{x:.828125,y:.703125},{x:.828125,y:.703125},{x:.859375,y:.703125},{x:.859375,y:.703125},{x:.890625,y:.703125},{x:.890625,y:.703125},{x:.921875,y:.703125},{x:.921875,y:.703125},{x:.953125,y:.703125},{x:.953125,y:.703125},{x:.984375,y:.703125},{x:.984375,y:.703125},{x:.015625,y:.734375},{x:.015625,y:.734375},{x:.046875,y:.734375},{x:.046875,y:.734375},{x:.078125,y:.734375},{x:.078125,y:.734375},{x:.109375,y:.734375},{x:.109375,y:.734375},{x:.140625,y:.734375},{x:.140625,y:.734375},{x:.171875,y:.734375},{x:.171875,y:.734375},{x:.203125,y:.734375},{x:.203125,y:.734375},{x:.234375,y:.734375},{x:.234375,y:.734375},{x:.265625,y:.734375},{x:.265625,y:.734375},{x:.296875,y:.734375},{x:.296875,y:.734375},{x:.328125,y:.734375},{x:.328125,y:.734375},{x:.359375,y:.734375},{x:.359375,y:.734375},{x:.390625,y:.734375},{x:.390625,y:.734375},{x:.421875,y:.734375},{x:.421875,y:.734375},{x:.453125,y:.734375},{x:.453125,y:.734375},{x:.484375,y:.734375},{x:.484375,y:.734375},{x:.515625,y:.734375},{x:.515625,y:.734375},{x:.546875,y:.734375},{x:.546875,y:.734375},{x:.578125,y:.734375},{x:.578125,y:.734375},{x:.609375,y:.734375},{x:.609375,y:.734375},{x:.640625,y:.734375},{x:.640625,y:.734375},{x:.671875,y:.734375},{x:.671875,y:.734375},{x:.703125,y:.734375},{x:.703125,y:.734375},{x:.734375,y:.734375},{x:.734375,y:.734375},{x:.765625,y:.734375},{x:.765625,y:.734375},{x:.796875,y:.734375},{x:.796875,y:.734375},{x:.828125,y:.734375},{x:.828125,y:.734375},{x:.859375,y:.734375},{x:.859375,y:.734375},{x:.890625,y:.734375},{x:.890625,y:.734375},{x:.921875,y:.734375},{x:.921875,y:.734375},{x:.953125,y:.734375},{x:.953125,y:.734375},{x:.984375,y:.734375},{x:.984375,y:.734375},{x:.015625,y:.765625},{x:.015625,y:.765625},{x:.046875,y:.765625},{x:.046875,y:.765625},{x:.078125,y:.765625},{x:.078125,y:.765625},{x:.109375,y:.765625},{x:.109375,y:.765625},{x:.140625,y:.765625},{x:.140625,y:.765625},{x:.171875,y:.765625},{x:.171875,y:.765625},{x:.203125,y:.765625},{x:.203125,y:.765625},{x:.234375,y:.765625},{x:.234375,y:.765625},{x:.265625,y:.765625},{x:.265625,y:.765625},{x:.296875,y:.765625},{x:.296875,y:.765625},{x:.328125,y:.765625},{x:.328125,y:.765625},{x:.359375,y:.765625},{x:.359375,y:.765625},{x:.390625,y:.765625},{x:.390625,y:.765625},{x:.421875,y:.765625},{x:.421875,y:.765625},{x:.453125,y:.765625},{x:.453125,y:.765625},{x:.484375,y:.765625},{x:.484375,y:.765625},{x:.515625,y:.765625},{x:.515625,y:.765625},{x:.546875,y:.765625},{x:.546875,y:.765625},{x:.578125,y:.765625},{x:.578125,y:.765625},{x:.609375,y:.765625},{x:.609375,y:.765625},{x:.640625,y:.765625},{x:.640625,y:.765625},{x:.671875,y:.765625},{x:.671875,y:.765625},{x:.703125,y:.765625},{x:.703125,y:.765625},{x:.734375,y:.765625},{x:.734375,y:.765625},{x:.765625,y:.765625},{x:.765625,y:.765625},{x:.796875,y:.765625},{x:.796875,y:.765625},{x:.828125,y:.765625},{x:.828125,y:.765625},{x:.859375,y:.765625},{x:.859375,y:.765625},{x:.890625,y:.765625},{x:.890625,y:.765625},{x:.921875,y:.765625},{x:.921875,y:.765625},{x:.953125,y:.765625},{x:.953125,y:.765625},{x:.984375,y:.765625},{x:.984375,y:.765625},{x:.015625,y:.796875},{x:.015625,y:.796875},{x:.046875,y:.796875},{x:.046875,y:.796875},{x:.078125,y:.796875},{x:.078125,y:.796875},{x:.109375,y:.796875},{x:.109375,y:.796875},{x:.140625,y:.796875},{x:.140625,y:.796875},{x:.171875,y:.796875},{x:.171875,y:.796875},{x:.203125,y:.796875},{x:.203125,y:.796875},{x:.234375,y:.796875},{x:.234375,y:.796875},{x:.265625,y:.796875},{x:.265625,y:.796875},{x:.296875,y:.796875},{x:.296875,y:.796875},{x:.328125,y:.796875},{x:.328125,y:.796875},{x:.359375,y:.796875},{x:.359375,y:.796875},{x:.390625,y:.796875},{x:.390625,y:.796875},{x:.421875,y:.796875},{x:.421875,y:.796875},{x:.453125,y:.796875},{x:.453125,y:.796875},{x:.484375,y:.796875},{x:.484375,y:.796875},{x:.515625,y:.796875},{x:.515625,y:.796875},{x:.546875,y:.796875},{x:.546875,y:.796875},{x:.578125,y:.796875},{x:.578125,y:.796875},{x:.609375,y:.796875},{x:.609375,y:.796875},{x:.640625,y:.796875},{x:.640625,y:.796875},{x:.671875,y:.796875},{x:.671875,y:.796875},{x:.703125,y:.796875},{x:.703125,y:.796875},{x:.734375,y:.796875},{x:.734375,y:.796875},{x:.765625,y:.796875},{x:.765625,y:.796875},{x:.796875,y:.796875},{x:.796875,y:.796875},{x:.828125,y:.796875},{x:.828125,y:.796875},{x:.859375,y:.796875},{x:.859375,y:.796875},{x:.890625,y:.796875},{x:.890625,y:.796875},{x:.921875,y:.796875},{x:.921875,y:.796875},{x:.953125,y:.796875},{x:.953125,y:.796875},{x:.984375,y:.796875},{x:.984375,y:.796875},{x:.015625,y:.828125},{x:.015625,y:.828125},{x:.046875,y:.828125},{x:.046875,y:.828125},{x:.078125,y:.828125},{x:.078125,y:.828125},{x:.109375,y:.828125},{x:.109375,y:.828125},{x:.140625,y:.828125},{x:.140625,y:.828125},{x:.171875,y:.828125},{x:.171875,y:.828125},{x:.203125,y:.828125},{x:.203125,y:.828125},{x:.234375,y:.828125},{x:.234375,y:.828125},{x:.265625,y:.828125},{x:.265625,y:.828125},{x:.296875,y:.828125},{x:.296875,y:.828125},{x:.328125,y:.828125},{x:.328125,y:.828125},{x:.359375,y:.828125},{x:.359375,y:.828125},{x:.390625,y:.828125},{x:.390625,y:.828125},{x:.421875,y:.828125},{x:.421875,y:.828125},{x:.453125,y:.828125},{x:.453125,y:.828125},{x:.484375,y:.828125},{x:.484375,y:.828125},{x:.515625,y:.828125},{x:.515625,y:.828125},{x:.546875,y:.828125},{x:.546875,y:.828125},{x:.578125,y:.828125},{x:.578125,y:.828125},{x:.609375,y:.828125},{x:.609375,y:.828125},{x:.640625,y:.828125},{x:.640625,y:.828125},{x:.671875,y:.828125},{x:.671875,y:.828125},{x:.703125,y:.828125},{x:.703125,y:.828125},{x:.734375,y:.828125},{x:.734375,y:.828125},{x:.765625,y:.828125},{x:.765625,y:.828125},{x:.796875,y:.828125},{x:.796875,y:.828125},{x:.828125,y:.828125},{x:.828125,y:.828125},{x:.859375,y:.828125},{x:.859375,y:.828125},{x:.890625,y:.828125},{x:.890625,y:.828125},{x:.921875,y:.828125},{x:.921875,y:.828125},{x:.953125,y:.828125},{x:.953125,y:.828125},{x:.984375,y:.828125},{x:.984375,y:.828125},{x:.015625,y:.859375},{x:.015625,y:.859375},{x:.046875,y:.859375},{x:.046875,y:.859375},{x:.078125,y:.859375},{x:.078125,y:.859375},{x:.109375,y:.859375},{x:.109375,y:.859375},{x:.140625,y:.859375},{x:.140625,y:.859375},{x:.171875,y:.859375},{x:.171875,y:.859375},{x:.203125,y:.859375},{x:.203125,y:.859375},{x:.234375,y:.859375},{x:.234375,y:.859375},{x:.265625,y:.859375},{x:.265625,y:.859375},{x:.296875,y:.859375},{x:.296875,y:.859375},{x:.328125,y:.859375},{x:.328125,y:.859375},{x:.359375,y:.859375},{x:.359375,y:.859375},{x:.390625,y:.859375},{x:.390625,y:.859375},{x:.421875,y:.859375},{x:.421875,y:.859375},{x:.453125,y:.859375},{x:.453125,y:.859375},{x:.484375,y:.859375},{x:.484375,y:.859375},{x:.515625,y:.859375},{x:.515625,y:.859375},{x:.546875,y:.859375},{x:.546875,y:.859375},{x:.578125,y:.859375},{x:.578125,y:.859375},{x:.609375,y:.859375},{x:.609375,y:.859375},{x:.640625,y:.859375},{x:.640625,y:.859375},{x:.671875,y:.859375},{x:.671875,y:.859375},{x:.703125,y:.859375},{x:.703125,y:.859375},{x:.734375,y:.859375},{x:.734375,y:.859375},{x:.765625,y:.859375},{x:.765625,y:.859375},{x:.796875,y:.859375},{x:.796875,y:.859375},{x:.828125,y:.859375},{x:.828125,y:.859375},{x:.859375,y:.859375},{x:.859375,y:.859375},{x:.890625,y:.859375},{x:.890625,y:.859375},{x:.921875,y:.859375},{x:.921875,y:.859375},{x:.953125,y:.859375},{x:.953125,y:.859375},{x:.984375,y:.859375},{x:.984375,y:.859375},{x:.015625,y:.890625},{x:.015625,y:.890625},{x:.046875,y:.890625},{x:.046875,y:.890625},{x:.078125,y:.890625},{x:.078125,y:.890625},{x:.109375,y:.890625},{x:.109375,y:.890625},{x:.140625,y:.890625},{x:.140625,y:.890625},{x:.171875,y:.890625},{x:.171875,y:.890625},{x:.203125,y:.890625},{x:.203125,y:.890625},{x:.234375,y:.890625},{x:.234375,y:.890625},{x:.265625,y:.890625},{x:.265625,y:.890625},{x:.296875,y:.890625},{x:.296875,y:.890625},{x:.328125,y:.890625},{x:.328125,y:.890625},{x:.359375,y:.890625},{x:.359375,y:.890625},{x:.390625,y:.890625},{x:.390625,y:.890625},{x:.421875,y:.890625},{x:.421875,y:.890625},{x:.453125,y:.890625},{x:.453125,y:.890625},{x:.484375,y:.890625},{x:.484375,y:.890625},{x:.515625,y:.890625},{x:.515625,y:.890625},{x:.546875,y:.890625},{x:.546875,y:.890625},{x:.578125,y:.890625},{x:.578125,y:.890625},{x:.609375,y:.890625},{x:.609375,y:.890625},{x:.640625,y:.890625},{x:.640625,y:.890625},{x:.671875,y:.890625},{x:.671875,y:.890625},{x:.703125,y:.890625},{x:.703125,y:.890625},{x:.734375,y:.890625},{x:.734375,y:.890625},{x:.765625,y:.890625},{x:.765625,y:.890625},{x:.796875,y:.890625},{x:.796875,y:.890625},{x:.828125,y:.890625},{x:.828125,y:.890625},{x:.859375,y:.890625},{x:.859375,y:.890625},{x:.890625,y:.890625},{x:.890625,y:.890625},{x:.921875,y:.890625},{x:.921875,y:.890625},{x:.953125,y:.890625},{x:.953125,y:.890625},{x:.984375,y:.890625},{x:.984375,y:.890625},{x:.015625,y:.921875},{x:.015625,y:.921875},{x:.046875,y:.921875},{x:.046875,y:.921875},{x:.078125,y:.921875},{x:.078125,y:.921875},{x:.109375,y:.921875},{x:.109375,y:.921875},{x:.140625,y:.921875},{x:.140625,y:.921875},{x:.171875,y:.921875},{x:.171875,y:.921875},{x:.203125,y:.921875},{x:.203125,y:.921875},{x:.234375,y:.921875},{x:.234375,y:.921875},{x:.265625,y:.921875},{x:.265625,y:.921875},{x:.296875,y:.921875},{x:.296875,y:.921875},{x:.328125,y:.921875},{x:.328125,y:.921875},{x:.359375,y:.921875},{x:.359375,y:.921875},{x:.390625,y:.921875},{x:.390625,y:.921875},{x:.421875,y:.921875},{x:.421875,y:.921875},{x:.453125,y:.921875},{x:.453125,y:.921875},{x:.484375,y:.921875},{x:.484375,y:.921875},{x:.515625,y:.921875},{x:.515625,y:.921875},{x:.546875,y:.921875},{x:.546875,y:.921875},{x:.578125,y:.921875},{x:.578125,y:.921875},{x:.609375,y:.921875},{x:.609375,y:.921875},{x:.640625,y:.921875},{x:.640625,y:.921875},{x:.671875,y:.921875},{x:.671875,y:.921875},{x:.703125,y:.921875},{x:.703125,y:.921875},{x:.734375,y:.921875},{x:.734375,y:.921875},{x:.765625,y:.921875},{x:.765625,y:.921875},{x:.796875,y:.921875},{x:.796875,y:.921875},{x:.828125,y:.921875},{x:.828125,y:.921875},{x:.859375,y:.921875},{x:.859375,y:.921875},{x:.890625,y:.921875},{x:.890625,y:.921875},{x:.921875,y:.921875},{x:.921875,y:.921875},{x:.953125,y:.921875},{x:.953125,y:.921875},{x:.984375,y:.921875},{x:.984375,y:.921875},{x:.015625,y:.953125},{x:.015625,y:.953125},{x:.046875,y:.953125},{x:.046875,y:.953125},{x:.078125,y:.953125},{x:.078125,y:.953125},{x:.109375,y:.953125},{x:.109375,y:.953125},{x:.140625,y:.953125},{x:.140625,y:.953125},{x:.171875,y:.953125},{x:.171875,y:.953125},{x:.203125,y:.953125},{x:.203125,y:.953125},{x:.234375,y:.953125},{x:.234375,y:.953125},{x:.265625,y:.953125},{x:.265625,y:.953125},{x:.296875,y:.953125},{x:.296875,y:.953125},{x:.328125,y:.953125},{x:.328125,y:.953125},{x:.359375,y:.953125},{x:.359375,y:.953125},{x:.390625,y:.953125},{x:.390625,y:.953125},{x:.421875,y:.953125},{x:.421875,y:.953125},{x:.453125,y:.953125},{x:.453125,y:.953125},{x:.484375,y:.953125},{x:.484375,y:.953125},{x:.515625,y:.953125},{x:.515625,y:.953125},{x:.546875,y:.953125},{x:.546875,y:.953125},{x:.578125,y:.953125},{x:.578125,y:.953125},{x:.609375,y:.953125},{x:.609375,y:.953125},{x:.640625,y:.953125},{x:.640625,y:.953125},{x:.671875,y:.953125},{x:.671875,y:.953125},{x:.703125,y:.953125},{x:.703125,y:.953125},{x:.734375,y:.953125},{x:.734375,y:.953125},{x:.765625,y:.953125},{x:.765625,y:.953125},{x:.796875,y:.953125},{x:.796875,y:.953125},{x:.828125,y:.953125},{x:.828125,y:.953125},{x:.859375,y:.953125},{x:.859375,y:.953125},{x:.890625,y:.953125},{x:.890625,y:.953125},{x:.921875,y:.953125},{x:.921875,y:.953125},{x:.953125,y:.953125},{x:.953125,y:.953125},{x:.984375,y:.953125},{x:.984375,y:.953125},{x:.015625,y:.984375},{x:.015625,y:.984375},{x:.046875,y:.984375},{x:.046875,y:.984375},{x:.078125,y:.984375},{x:.078125,y:.984375},{x:.109375,y:.984375},{x:.109375,y:.984375},{x:.140625,y:.984375},{x:.140625,y:.984375},{x:.171875,y:.984375},{x:.171875,y:.984375},{x:.203125,y:.984375},{x:.203125,y:.984375},{x:.234375,y:.984375},{x:.234375,y:.984375},{x:.265625,y:.984375},{x:.265625,y:.984375},{x:.296875,y:.984375},{x:.296875,y:.984375},{x:.328125,y:.984375},{x:.328125,y:.984375},{x:.359375,y:.984375},{x:.359375,y:.984375},{x:.390625,y:.984375},{x:.390625,y:.984375},{x:.421875,y:.984375},{x:.421875,y:.984375},{x:.453125,y:.984375},{x:.453125,y:.984375},{x:.484375,y:.984375},{x:.484375,y:.984375},{x:.515625,y:.984375},{x:.515625,y:.984375},{x:.546875,y:.984375},{x:.546875,y:.984375},{x:.578125,y:.984375},{x:.578125,y:.984375},{x:.609375,y:.984375},{x:.609375,y:.984375},{x:.640625,y:.984375},{x:.640625,y:.984375},{x:.671875,y:.984375},{x:.671875,y:.984375},{x:.703125,y:.984375},{x:.703125,y:.984375},{x:.734375,y:.984375},{x:.734375,y:.984375},{x:.765625,y:.984375},{x:.765625,y:.984375},{x:.796875,y:.984375},{x:.796875,y:.984375},{x:.828125,y:.984375},{x:.828125,y:.984375},{x:.859375,y:.984375},{x:.859375,y:.984375},{x:.890625,y:.984375},{x:.890625,y:.984375},{x:.921875,y:.984375},{x:.921875,y:.984375},{x:.953125,y:.984375},{x:.953125,y:.984375},{x:.984375,y:.984375},{x:.984375,y:.984375},{x:.03125,y:.03125},{x:.03125,y:.03125},{x:.09375,y:.03125},{x:.09375,y:.03125},{x:.15625,y:.03125},{x:.15625,y:.03125},{x:.21875,y:.03125},{x:.21875,y:.03125},{x:.28125,y:.03125},{x:.28125,y:.03125},{x:.34375,y:.03125},{x:.34375,y:.03125},{x:.40625,y:.03125},{x:.40625,y:.03125},{x:.46875,y:.03125},{x:.46875,y:.03125},{x:.53125,y:.03125},{x:.53125,y:.03125},{x:.59375,y:.03125},{x:.59375,y:.03125},{x:.65625,y:.03125},{x:.65625,y:.03125},{x:.71875,y:.03125},{x:.71875,y:.03125},{x:.78125,y:.03125},{x:.78125,y:.03125},{x:.84375,y:.03125},{x:.84375,y:.03125},{x:.90625,y:.03125},{x:.90625,y:.03125},{x:.96875,y:.03125},{x:.96875,y:.03125},{x:.03125,y:.09375},{x:.03125,y:.09375},{x:.09375,y:.09375},{x:.09375,y:.09375},{x:.15625,y:.09375},{x:.15625,y:.09375},{x:.21875,y:.09375},{x:.21875,y:.09375},{x:.28125,y:.09375},{x:.28125,y:.09375},{x:.34375,y:.09375},{x:.34375,y:.09375},{x:.40625,y:.09375},{x:.40625,y:.09375},{x:.46875,y:.09375},{x:.46875,y:.09375},{x:.53125,y:.09375},{x:.53125,y:.09375},{x:.59375,y:.09375},{x:.59375,y:.09375},{x:.65625,y:.09375},{x:.65625,y:.09375},{x:.71875,y:.09375},{x:.71875,y:.09375},{x:.78125,y:.09375},{x:.78125,y:.09375},{x:.84375,y:.09375},{x:.84375,y:.09375},{x:.90625,y:.09375},{x:.90625,y:.09375},{x:.96875,y:.09375},{x:.96875,y:.09375},{x:.03125,y:.15625},{x:.03125,y:.15625},{x:.09375,y:.15625},{x:.09375,y:.15625},{x:.15625,y:.15625},{x:.15625,y:.15625},{x:.21875,y:.15625},{x:.21875,y:.15625},{x:.28125,y:.15625},{x:.28125,y:.15625},{x:.34375,y:.15625},{x:.34375,y:.15625},{x:.40625,y:.15625},{x:.40625,y:.15625},{x:.46875,y:.15625},{x:.46875,y:.15625},{x:.53125,y:.15625},{x:.53125,y:.15625},{x:.59375,y:.15625},{x:.59375,y:.15625},{x:.65625,y:.15625},{x:.65625,y:.15625},{x:.71875,y:.15625},{x:.71875,y:.15625},{x:.78125,y:.15625},{x:.78125,y:.15625},{x:.84375,y:.15625},{x:.84375,y:.15625},{x:.90625,y:.15625},{x:.90625,y:.15625},{x:.96875,y:.15625},{x:.96875,y:.15625},{x:.03125,y:.21875},{x:.03125,y:.21875},{x:.09375,y:.21875},{x:.09375,y:.21875},{x:.15625,y:.21875},{x:.15625,y:.21875},{x:.21875,y:.21875},{x:.21875,y:.21875},{x:.28125,y:.21875},{x:.28125,y:.21875},{x:.34375,y:.21875},{x:.34375,y:.21875},{x:.40625,y:.21875},{x:.40625,y:.21875},{x:.46875,y:.21875},{x:.46875,y:.21875},{x:.53125,y:.21875},{x:.53125,y:.21875},{x:.59375,y:.21875},{x:.59375,y:.21875},{x:.65625,y:.21875},{x:.65625,y:.21875},{x:.71875,y:.21875},{x:.71875,y:.21875},{x:.78125,y:.21875},{x:.78125,y:.21875},{x:.84375,y:.21875},{x:.84375,y:.21875},{x:.90625,y:.21875},{x:.90625,y:.21875},{x:.96875,y:.21875},{x:.96875,y:.21875},{x:.03125,y:.28125},{x:.03125,y:.28125},{x:.09375,y:.28125},{x:.09375,y:.28125},{x:.15625,y:.28125},{x:.15625,y:.28125},{x:.21875,y:.28125},{x:.21875,y:.28125},{x:.28125,y:.28125},{x:.28125,y:.28125},{x:.34375,y:.28125},{x:.34375,y:.28125},{x:.40625,y:.28125},{x:.40625,y:.28125},{x:.46875,y:.28125},{x:.46875,y:.28125},{x:.53125,y:.28125},{x:.53125,y:.28125},{x:.59375,y:.28125},{x:.59375,y:.28125},{x:.65625,y:.28125},{x:.65625,y:.28125},{x:.71875,y:.28125},{x:.71875,y:.28125},{x:.78125,y:.28125},{x:.78125,y:.28125},{x:.84375,y:.28125},{x:.84375,y:.28125},{x:.90625,y:.28125},{x:.90625,y:.28125},{x:.96875,y:.28125},{x:.96875,y:.28125},{x:.03125,y:.34375},{x:.03125,y:.34375},{x:.09375,y:.34375},{x:.09375,y:.34375},{x:.15625,y:.34375},{x:.15625,y:.34375},{x:.21875,y:.34375},{x:.21875,y:.34375},{x:.28125,y:.34375},{x:.28125,y:.34375},{x:.34375,y:.34375},{x:.34375,y:.34375},{x:.40625,y:.34375},{x:.40625,y:.34375},{x:.46875,y:.34375},{x:.46875,y:.34375},{x:.53125,y:.34375},{x:.53125,y:.34375},{x:.59375,y:.34375},{x:.59375,y:.34375},{x:.65625,y:.34375},{x:.65625,y:.34375},{x:.71875,y:.34375},{x:.71875,y:.34375},{x:.78125,y:.34375},{x:.78125,y:.34375},{x:.84375,y:.34375},{x:.84375,y:.34375},{x:.90625,y:.34375},{x:.90625,y:.34375},{x:.96875,y:.34375},{x:.96875,y:.34375},{x:.03125,y:.40625},{x:.03125,y:.40625},{x:.09375,y:.40625},{x:.09375,y:.40625},{x:.15625,y:.40625},{x:.15625,y:.40625},{x:.21875,y:.40625},{x:.21875,y:.40625},{x:.28125,y:.40625},{x:.28125,y:.40625},{x:.34375,y:.40625},{x:.34375,y:.40625},{x:.40625,y:.40625},{x:.40625,y:.40625},{x:.46875,y:.40625},{x:.46875,y:.40625},{x:.53125,y:.40625},{x:.53125,y:.40625},{x:.59375,y:.40625},{x:.59375,y:.40625},{x:.65625,y:.40625},{x:.65625,y:.40625},{x:.71875,y:.40625},{x:.71875,y:.40625},{x:.78125,y:.40625},{x:.78125,y:.40625},{x:.84375,y:.40625},{x:.84375,y:.40625},{x:.90625,y:.40625},{x:.90625,y:.40625},{x:.96875,y:.40625},{x:.96875,y:.40625},{x:.03125,y:.46875},{x:.03125,y:.46875},{x:.09375,y:.46875},{x:.09375,y:.46875},{x:.15625,y:.46875},{x:.15625,y:.46875},{x:.21875,y:.46875},{x:.21875,y:.46875},{x:.28125,y:.46875},{x:.28125,y:.46875},{x:.34375,y:.46875},{x:.34375,y:.46875},{x:.40625,y:.46875},{x:.40625,y:.46875},{x:.46875,y:.46875},{x:.46875,y:.46875},{x:.53125,y:.46875},{x:.53125,y:.46875},{x:.59375,y:.46875},{x:.59375,y:.46875},{x:.65625,y:.46875},{x:.65625,y:.46875},{x:.71875,y:.46875},{x:.71875,y:.46875},{x:.78125,y:.46875},{x:.78125,y:.46875},{x:.84375,y:.46875},{x:.84375,y:.46875},{x:.90625,y:.46875},{x:.90625,y:.46875},{x:.96875,y:.46875},{x:.96875,y:.46875},{x:.03125,y:.53125},{x:.03125,y:.53125},{x:.09375,y:.53125},{x:.09375,y:.53125},{x:.15625,y:.53125},{x:.15625,y:.53125},{x:.21875,y:.53125},{x:.21875,y:.53125},{x:.28125,y:.53125},{x:.28125,y:.53125},{x:.34375,y:.53125},{x:.34375,y:.53125},{x:.40625,y:.53125},{x:.40625,y:.53125},{x:.46875,y:.53125},{x:.46875,y:.53125},{x:.53125,y:.53125},{x:.53125,y:.53125},{x:.59375,y:.53125},{x:.59375,y:.53125},{x:.65625,y:.53125},{x:.65625,y:.53125},{x:.71875,y:.53125},{x:.71875,y:.53125},{x:.78125,y:.53125},{x:.78125,y:.53125},{x:.84375,y:.53125},{x:.84375,y:.53125},{x:.90625,y:.53125},{x:.90625,y:.53125},{x:.96875,y:.53125},{x:.96875,y:.53125},{x:.03125,y:.59375},{x:.03125,y:.59375},{x:.09375,y:.59375},{x:.09375,y:.59375},{x:.15625,y:.59375},{x:.15625,y:.59375},{x:.21875,y:.59375},{x:.21875,y:.59375},{x:.28125,y:.59375},{x:.28125,y:.59375},{x:.34375,y:.59375},{x:.34375,y:.59375},{x:.40625,y:.59375},{x:.40625,y:.59375},{x:.46875,y:.59375},{x:.46875,y:.59375},{x:.53125,y:.59375},{x:.53125,y:.59375},{x:.59375,y:.59375},{x:.59375,y:.59375},{x:.65625,y:.59375},{x:.65625,y:.59375},{x:.71875,y:.59375},{x:.71875,y:.59375},{x:.78125,y:.59375},{x:.78125,y:.59375},{x:.84375,y:.59375},{x:.84375,y:.59375},{x:.90625,y:.59375},{x:.90625,y:.59375},{x:.96875,y:.59375},{x:.96875,y:.59375},{x:.03125,y:.65625},{x:.03125,y:.65625},{x:.09375,y:.65625},{x:.09375,y:.65625},{x:.15625,y:.65625},{x:.15625,y:.65625},{x:.21875,y:.65625},{x:.21875,y:.65625},{x:.28125,y:.65625},{x:.28125,y:.65625},{x:.34375,y:.65625},{x:.34375,y:.65625},{x:.40625,y:.65625},{x:.40625,y:.65625},{x:.46875,y:.65625},{x:.46875,y:.65625},{x:.53125,y:.65625},{x:.53125,y:.65625},{x:.59375,y:.65625},{x:.59375,y:.65625},{x:.65625,y:.65625},{x:.65625,y:.65625},{x:.71875,y:.65625},{x:.71875,y:.65625},{x:.78125,y:.65625},{x:.78125,y:.65625},{x:.84375,y:.65625},{x:.84375,y:.65625},{x:.90625,y:.65625},{x:.90625,y:.65625},{x:.96875,y:.65625},{x:.96875,y:.65625},{x:.03125,y:.71875},{x:.03125,y:.71875},{x:.09375,y:.71875},{x:.09375,y:.71875},{x:.15625,y:.71875},{x:.15625,y:.71875},{x:.21875,y:.71875},{x:.21875,y:.71875},{x:.28125,y:.71875},{x:.28125,y:.71875},{x:.34375,y:.71875},{x:.34375,y:.71875},{x:.40625,y:.71875},{x:.40625,y:.71875},{x:.46875,y:.71875},{x:.46875,y:.71875},{x:.53125,y:.71875},{x:.53125,y:.71875},{x:.59375,y:.71875},{x:.59375,y:.71875},{x:.65625,y:.71875},{x:.65625,y:.71875},{x:.71875,y:.71875},{x:.71875,y:.71875},{x:.78125,y:.71875},{x:.78125,y:.71875},{x:.84375,y:.71875},{x:.84375,y:.71875},{x:.90625,y:.71875},{x:.90625,y:.71875},{x:.96875,y:.71875},{x:.96875,y:.71875},{x:.03125,y:.78125},{x:.03125,y:.78125},{x:.09375,y:.78125},{x:.09375,y:.78125},{x:.15625,y:.78125},{x:.15625,y:.78125},{x:.21875,y:.78125},{x:.21875,y:.78125},{x:.28125,y:.78125},{x:.28125,y:.78125},{x:.34375,y:.78125},{x:.34375,y:.78125},{x:.40625,y:.78125},{x:.40625,y:.78125},{x:.46875,y:.78125},{x:.46875,y:.78125},{x:.53125,y:.78125},{x:.53125,y:.78125},{x:.59375,y:.78125},{x:.59375,y:.78125},{x:.65625,y:.78125},{x:.65625,y:.78125},{x:.71875,y:.78125},{x:.71875,y:.78125},{x:.78125,y:.78125},{x:.78125,y:.78125},{x:.84375,y:.78125},{x:.84375,y:.78125},{x:.90625,y:.78125},{x:.90625,y:.78125},{x:.96875,y:.78125},{x:.96875,y:.78125},{x:.03125,y:.84375},{x:.03125,y:.84375},{x:.09375,y:.84375},{x:.09375,y:.84375},{x:.15625,y:.84375},{x:.15625,y:.84375},{x:.21875,y:.84375},{x:.21875,y:.84375},{x:.28125,y:.84375},{x:.28125,y:.84375},{x:.34375,y:.84375},{x:.34375,y:.84375},{x:.40625,y:.84375},{x:.40625,y:.84375},{x:.46875,y:.84375},{x:.46875,y:.84375},{x:.53125,y:.84375},{x:.53125,y:.84375},{x:.59375,y:.84375},{x:.59375,y:.84375},{x:.65625,y:.84375},{x:.65625,y:.84375},{x:.71875,y:.84375},{x:.71875,y:.84375},{x:.78125,y:.84375},{x:.78125,y:.84375},{x:.84375,y:.84375},{x:.84375,y:.84375},{x:.90625,y:.84375},{x:.90625,y:.84375},{x:.96875,y:.84375},{x:.96875,y:.84375},{x:.03125,y:.90625},{x:.03125,y:.90625},{x:.09375,y:.90625},{x:.09375,y:.90625},{x:.15625,y:.90625},{x:.15625,y:.90625},{x:.21875,y:.90625},{x:.21875,y:.90625},{x:.28125,y:.90625},{x:.28125,y:.90625},{x:.34375,y:.90625},{x:.34375,y:.90625},{x:.40625,y:.90625},{x:.40625,y:.90625},{x:.46875,y:.90625},{x:.46875,y:.90625},{x:.53125,y:.90625},{x:.53125,y:.90625},{x:.59375,y:.90625},{x:.59375,y:.90625},{x:.65625,y:.90625},{x:.65625,y:.90625},{x:.71875,y:.90625},{x:.71875,y:.90625},{x:.78125,y:.90625},{x:.78125,y:.90625},{x:.84375,y:.90625},{x:.84375,y:.90625},{x:.90625,y:.90625},{x:.90625,y:.90625},{x:.96875,y:.90625},{x:.96875,y:.90625},{x:.03125,y:.96875},{x:.03125,y:.96875},{x:.09375,y:.96875},{x:.09375,y:.96875},{x:.15625,y:.96875},{x:.15625,y:.96875},{x:.21875,y:.96875},{x:.21875,y:.96875},{x:.28125,y:.96875},{x:.28125,y:.96875},{x:.34375,y:.96875},{x:.34375,y:.96875},{x:.40625,y:.96875},{x:.40625,y:.96875},{x:.46875,y:.96875},{x:.46875,y:.96875},{x:.53125,y:.96875},{x:.53125,y:.96875},{x:.59375,y:.96875},{x:.59375,y:.96875},{x:.65625,y:.96875},{x:.65625,y:.96875},{x:.71875,y:.96875},{x:.71875,y:.96875},{x:.78125,y:.96875},{x:.78125,y:.96875},{x:.84375,y:.96875},{x:.84375,y:.96875},{x:.90625,y:.96875},{x:.90625,y:.96875},{x:.96875,y:.96875},{x:.96875,y:.96875},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.0625,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.1875,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.3125,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.4375,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.5625,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.6875,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.8125,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.9375,y:.0625},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.0625,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.1875,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.3125,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.4375,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.5625,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.6875,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.8125,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.9375,y:.1875},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.0625,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.1875,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.3125,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.4375,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.5625,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.6875,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.8125,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.9375,y:.3125},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.0625,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.1875,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.3125,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.4375,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.5625,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.6875,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.8125,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.9375,y:.4375},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.0625,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.1875,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.3125,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.4375,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.5625,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.6875,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.8125,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.9375,y:.5625},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.0625,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.1875,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.3125,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.4375,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.5625,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.6875,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.8125,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.9375,y:.6875},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.0625,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.1875,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.3125,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.4375,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.5625,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.6875,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.8125,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.9375,y:.8125},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.0625,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.1875,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.3125,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.4375,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.5625,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.6875,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.8125,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375},{x:.9375,y:.9375}],O0=[0,5,9,13,17,1,2],D0=0,z0={thumb:0,index:1,middle:2,ring:3,pinky:4,all:[0,1,2,3,4],nameMapping:{0:"thumb",1:"index",2:"middle",3:"ring",4:"pinky"},pointsMapping:{0:[[0,1],[1,2],[2,3],[3,4]],1:[[0,5],[5,6],[6,7],[7,8]],2:[[0,9],[9,10],[10,11],[11,12]],3:[[0,13],[13,14],[14,15],[15,16]],4:[[0,17],[17,18],[18,19],[19,20]]},getName:e=>z0.nameMapping[e],getPoints:e=>z0.pointsMapping[e]},P0={none:0,half:1,full:2,nameMapping:{0:"none",1:"half",2:"full"},getName:e=>P0.nameMapping[e]},L0={verticalUp:0,verticalDown:1,horizontalLeft:2,horizontalRight:3,diagonalUpRight:4,diagonalUpLeft:5,diagonalDownRight:6,diagonalDownLeft:7,nameMapping:{0:"verticalUp",1:"verticalDown",2:"horizontalLeft",3:"horizontalRight",4:"diagonalUpRight",5:"diagonalUpLeft",6:"diagonalDownRight",7:"diagonalDownLeft"},getName:e=>L0.nameMapping[e]},B0=class{constructor(e){o(this,"name"),o(this,"curls"),o(this,"directions"),o(this,"weights"),o(this,"weightsRelative"),this.name=e,this.curls={},this.directions={},this.weights=[1,1,1,1,1],this.weightsRelative=[1,1,1,1,1]}curl(e,t,n){void 0===this.curls[e]&&(this.curls[e]=[]),this.curls[e].push([t,n])}direction(e,t,n){this.directions[e]||(this.directions[e]=[]),this.directions[e].push([t,n])}weight(e,t){this.weights[e]=t;const n=this.weights.reduce(((e,t)=>e+t),0);this.weightsRelative=this.weights.map((e=>5*e/n))}matchAgainst(e,t){let n=0;for(const t in e){const r=e[t],a=this.curls[t];if(void 0!==a){for(const[e,s]of a)if(r===e){n+=s*this.weightsRelative[t];break}}else n+=this.weightsRelative[t]}for(const e in t){const r=t[e],a=this.directions[e];if(void 0!==a){for(const[t,s]of a)if(r===t){n+=s*this.weightsRelative[e];break}}else n+=this.weightsRelative[e]}return n/10}},{thumb:W0,index:U0,middle:V0,ring:j0,pinky:G0}=z0,{none:H0,half:q0,full:X0}=P0,{verticalUp:K0,verticalDown:Z0,horizontalLeft:Y0,horizontalRight:J0,diagonalUpRight:Q0,diagonalUpLeft:e1,diagonalDownRight:t1,diagonalDownLeft:n1}=L0,r1=new B0("thumbs up");r1.curl(W0,H0,1),r1.direction(W0,K0,1),r1.direction(W0,e1,.25),r1.direction(W0,Q0,.25);for(const e of[z0.index,z0.middle,z0.ring,z0.pinky])r1.curl(e,X0,1),r1.direction(e,Y0,1),r1.direction(e,J0,1);var a1=new B0("victory");a1.curl(W0,q0,.5),a1.curl(W0,H0,.5),a1.direction(W0,K0,1),a1.direction(W0,e1,1),a1.curl(U0,H0,1),a1.direction(U0,K0,.75),a1.direction(U0,e1,1),a1.curl(V0,H0,1),a1.direction(V0,K0,1),a1.direction(V0,e1,.75),a1.curl(j0,X0,1),a1.direction(j0,K0,.2),a1.direction(j0,e1,1),a1.direction(j0,Y0,.2),a1.curl(G0,X0,1),a1.direction(G0,K0,.2),a1.direction(G0,e1,1),a1.direction(G0,Y0,.2),a1.weight(U0,2),a1.weight(V0,2);var s1=new B0("point");s1.curl(W0,X0,1),s1.curl(U0,H0,.5),s1.curl(V0,X0,.5),s1.curl(j0,X0,.5),s1.curl(G0,X0,.5),s1.weight(U0,2),s1.weight(V0,2);var o1=new B0("middle finger");o1.curl(W0,H0,1),o1.curl(U0,X0,.5),o1.curl(V0,X0,.5),o1.curl(j0,X0,.5),o1.curl(G0,X0,.5),o1.weight(U0,2),o1.weight(V0,2);var i1=new B0("open palm");i1.curl(W0,H0,.75),i1.curl(U0,H0,.75),i1.curl(V0,H0,.75),i1.curl(j0,H0,.75),i1.curl(G0,H0,.75);var l1=[r1,a1,s1,o1,i1],u1=60,c1=130,d1=1.1,h1=.9,p1=1.6;function f1(e,t,n,r){const a=(t-r)/(e-n);let s=180*Math.atan(a)/Math.PI;return s<=0?s=-s:s>0&&(s=180-s),s}function m1(e,t){if(!e||!t)return[0,0];const n=f1(e[0],e[1],t[0],t[1]);if(2===e.length)return n;return[n,f1(e[1],e[2],t[1],t[2])]}function A1(e,t=1){let n=0,r=0,a=0;return e>=75&&e<=105?n=1*t:e>=25&&e<=155?r=1*t:a=1*t,[n,r,a]}function g1(e,t,n){const r=e[0]-t[0],a=e[0]-n[0],s=t[0]-n[0],o=e[1]-t[1],i=e[1]-n[1],l=t[1]-n[1],u=e[2]-t[2],c=e[2]-n[2],d=t[2]-n[2],h=Math.sqrt(r*r+o*o+u*u),p=Math.sqrt(a*a+i*i+c*c),f=Math.sqrt(s*s+l*l+d*d);let m=(f*f+h*h-p*p)/(2*f*h);m>1?m=1:m<-1&&(m=-1);let A,g=Math.acos(m);return g=57.2958*g%180,A=g>c1?P0.none:g>u1?P0.half:P0.full,A}function y1(e,t,n,r){let a;return a=r===Math.abs(e)?e>0?L0.horizontalLeft:L0.horizontalRight:r===Math.abs(t)?t>0?L0.horizontalLeft:L0.horizontalRight:n>0?L0.horizontalLeft:L0.horizontalRight,a}function x1(e,t,n,r){let a;return a=r===Math.abs(e)?e<0?L0.verticalDown:L0.verticalUp:r===Math.abs(t)?t<0?L0.verticalDown:L0.verticalUp:n<0?L0.verticalDown:L0.verticalUp,a}function b1(e,t,n,r){const a=e[0]-t[0],s=e[0]-n[0],o=t[0]-n[0],i=e[1]-t[1],l=e[1]-n[1],u=t[1]-n[1],c=Math.max(Math.abs(a),Math.abs(s),Math.abs(o)),d=Math.max(Math.abs(i),Math.abs(l),Math.abs(u));let h=0,p=0,f=0;const m=d/(c+1e-5);m>1.5?h+=d1:m>.66?p+=d1:f+=d1;const A=Math.sqrt(a*a+i*i),g=Math.sqrt(s*s+l*l),y=Math.sqrt(o*o+u*u),x=Math.max(A,g,y);let b=e[0],v=e[1],w=n[0],k=n[1];x===A?(w=n[0],k=n[1]):x===y&&(b=t[0],v=t[1]);const S=A1(m1([b,v],[w,k]),p1);h+=S[0],p+=S[1],f+=S[2];for(const e of r){const t=A1(e,h1);h+=t[0],p+=t[1],f+=t[2]}let I;return I=h===Math.max(h,p,f)?x1(l,i,u,d):f===Math.max(p,f)?y1(s,a,o,c):function(e,t,n,r,a,s,o,i){let l;const u=x1(e,t,n,r),c=y1(a,s,o,i);return l=u===L0.verticalUp?c===L0.horizontalLeft?L0.diagonalUpLeft:L0.diagonalUpRight:c===L0.horizontalLeft?L0.diagonalDownLeft:L0.diagonalDownRight,l}(l,i,u,d,s,a,o,c),I}function v1(e){const t=[],n=[],r=[],a=[];if(!e)return{curls:r,directions:a};for(const r of z0.all){const a=z0.getPoints(r),s=[],o=[];for(const t of a){const n=m1(e[t[0]],e[t[1]]),r=n[0],a=n[1];s.push(r),o.push(a)}t.push(s),n.push(o)}for(const n of z0.all){const s=n===z0.thumb?1:0,o=z0.getPoints(n),i=e[o[s][0]],l=e[o[s+1][1]],u=e[o[3][1]],c=g1(i,l,u),d=b1(i,l,u,t[n].slice(s));r[n]=c,a[n]=d}return{curls:r,directions:a}}function w1(e){if(!e||0===e.length)return null;const t=v1(e),n={};for(const e of z0.all)n[z0.getName(e)]={curl:P0.getName(t.curls[e]),direction:L0.getName(t.directions[e])};return n}function k1(e){const t=[];if(!e||0===e.length)return t;const n=v1(e);for(const e of l1){const r=e.matchAgainst(n.curls,n.directions);r>=.7&&t.push({name:e.name,confidence:r})}return t}var S1,I1,C1,E1={thumb:[1,2,3,4],index:[5,6,7,8],middle:[9,10,11,12],ring:[13,14,15,16],pinky:[17,18,19,20],palm:[0]};async function N1(e,t){const n=await C1.estimateHands(e,t);if(!n)return[];const r=[];for(let t=0;t<n.length;t++){const a={};if(n[t].landmarks)for(const e of Object.keys(E1))a[e]=E1[e].map((e=>n[t].landmarks[e]));const s=n[t].landmarks;let o=[Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,0,0],i=[0,0,0,0];if(s&&s.length>0){for(const e of s)e[0]<o[0]&&(o[0]=e[0]),e[1]<o[1]&&(o[1]=e[1]),e[0]>o[2]&&(o[2]=e[0]),e[1]>o[3]&&(o[3]=e[1]);o[2]-=o[0],o[3]-=o[1],i=[o[0]/(e.shape[2]||0),o[1]/(e.shape[1]||0),o[2]/(e.shape[2]||0),o[3]/(e.shape[1]||0)]}else o=n[t].box?[Math.trunc(Math.max(0,n[t].box.topLeft[0])),Math.trunc(Math.max(0,n[t].box.topLeft[1])),Math.trunc(Math.min(e.shape[2]||0,n[t].box.bottomRight[0])-Math.max(0,n[t].box.topLeft[0])),Math.trunc(Math.min(e.shape[1]||0,n[t].box.bottomRight[1])-Math.max(0,n[t].box.topLeft[1]))]:[0,0,0,0],i=[n[t].box.topLeft[0]/(e.shape[2]||0),n[t].box.topLeft[1]/(e.shape[1]||0),(n[t].box.bottomRight[0]-n[t].box.topLeft[0])/(e.shape[2]||0),(n[t].box.bottomRight[1]-n[t].box.topLeft[1])/(e.shape[1]||0)];const l=w1(s);r.push({id:t,score:Math.round(100*n[t].confidence)/100,boxScore:Math.round(100*n[t].boxConfidence)/100,fingerScore:Math.round(100*n[t].fingerConfidence)/100,label:"hand",box:o,boxRaw:i,keypoints:s,annotations:a,landmarks:l})}return r}async function T1(e){var t,n;HZ.initial&&(S1=null,I1=null),S1&&I1?(e.debug&&d("cached model:",S1.modelUrl),e.debug&&d("cached model:",I1.modelUrl)):[S1,I1]=await Promise.all([e.hand.enabled?LY(null==(t=e.hand.detector)?void 0:t.modelPath):null,e.hand.landmarks?LY(null==(n=e.hand.skeleton)?void 0:n.modelPath):null]);const r=new class{constructor(e){o(this,"model"),o(this,"anchors"),o(this,"anchorsTensor"),o(this,"inputSize"),o(this,"inputSizeTensor"),o(this,"doubleInputSizeTensor"),this.model=e,this.anchors=F0.map((e=>[e.x,e.y])),this.anchorsTensor=xh(this.anchors),this.inputSize=this.model&&this.model.inputs&&this.model.inputs[0].shape?this.model.inputs[0].shape[2]:0,this.inputSizeTensor=yh([this.inputSize,this.inputSize]),this.doubleInputSizeTensor=yh([2*this.inputSize,2*this.inputSize])}normalizeBoxes(e){const t={};t.boxOffsets=Au(e,[0,0],[-1,2]),t.boxSizes=Au(e,[0,2],[-1,2]),t.div=Dl(t.boxOffsets,this.inputSizeTensor),t.boxCenterPoints=Fl(t.div,this.anchorsTensor),t.halfBoxSizes=Dl(t.boxSizes,this.doubleInputSizeTensor),t.sub=Zc(t.boxCenterPoints,t.halfBoxSizes),t.startPoints=zl(t.sub,this.inputSizeTensor),t.add=Fl(t.boxCenterPoints,t.halfBoxSizes),t.endPoints=zl(t.add,this.inputSizeTensor);const n=Ru([t.startPoints,t.endPoints],1);return Object.keys(t).forEach((e=>yi(t[e]))),n}normalizeLandmarks(e,t){const n={};n.reshape=du(e,[-1,7,2]),n.div=Dl(n.reshape,this.inputSizeTensor),n.landmarks=Fl(n.div,this.anchors[t]);const r=zl(n.landmarks,this.inputSizeTensor);return Object.keys(n).forEach((e=>yi(n[e]))),r}async predict(e,t){const n={};n.resize=Zp.resizeBilinear(e,[this.inputSize,this.inputSize]),n.div=Dl(n.resize,YY.tf127),n.image=Zc(n.div,YY.tf1),n.batched=this.model.execute(n.image),n.predictions=ph(n.batched),n.slice=Au(n.predictions,[0,0],[-1,1]),n.sigmoid=mu(n.slice),n.scores=ph(n.sigmoid);const r=await n.scores.data();n.boxes=Au(n.predictions,[0,1],[-1,4]),n.norm=this.normalizeBoxes(n.boxes),n.nms=await Zp.nonMaxSuppressionAsync(n.norm,n.scores,3*t.hand.maxDetected,t.hand.iouThreshold,t.hand.minConfidence);const a=await n.nms.array(),s=[];for(const t of a){const a={};a.box=Au(n.norm,[t,0],[1,-1]),a.slice=Au(n.predictions,[t,5],[1,14]),a.norm=this.normalizeLandmarks(a.slice,t),a.palmLandmarks=du(a.norm,[-1,2]);const o=await a.box.data(),i=S0({startPoint:o.slice(0,2),endPoint:o.slice(2,4),palmLandmarks:await a.palmLandmarks.array(),confidence:r[t]},[e.shape[2]/this.inputSize,e.shape[1]/this.inputSize]);s.push(i),Object.keys(a).forEach((e=>yi(a[e])))}return Object.keys(n).forEach((e=>yi(n[e]))),s}}(S1);return C1=new class{constructor(e,t){o(this,"handDetector"),o(this,"handPoseModel"),o(this,"inputSize"),o(this,"storedBoxes"),o(this,"skipped"),o(this,"detectedHands"),this.handDetector=e,this.handPoseModel=t,this.inputSize=this.handPoseModel&&this.handPoseModel.inputs[0].shape?this.handPoseModel.inputs[0].shape[2]:0,this.storedBoxes=[],this.skipped=Number.MAX_SAFE_INTEGER,this.detectedHands=0}calculateLandmarksBoundingBox(e){const t=e.map((e=>e[0])),n=e.map((e=>e[1]));return{startPoint:[Math.min(...t),Math.min(...n)],endPoint:[Math.max(...t),Math.max(...n)]}}getBoxForPalmLandmarks(e,t){const n=e.map((e=>$0([...e,1],t)));return I0(C0(this.calculateLandmarksBoundingBox(n)),5)}getBoxForHandLandmarks(e){const t=I0(C0(this.calculateLandmarksBoundingBox(e)),1.65);t.palmLandmarks=[];for(let n=0;n<O0.length;n++)t.palmLandmarks.push(e[O0[n]].slice(0,2));return t}transformRawCoords(e,t,n,r){const a=v0(t),s=[a[0]/this.inputSize,a[1]/this.inputSize,(a[0]+a[1])/this.inputSize/2],o=e.map((e=>[s[0]*(e[0]-this.inputSize/2),s[1]*(e[1]-this.inputSize/2),s[2]*e[2]])),i=M0(n,[0,0]),l=o.map((e=>[...$0(e,i),e[2]])),u=function(e){const t=[[e[0][0],e[1][0]],[e[0][1],e[1][1]]],n=[e[0][2],e[1][2]],r=[-T0(t[0],n),-T0(t[1],n)];return[t[0].concat(r[0]),t[1].concat(r[1]),[0,0,1]]}(r),c=[...w0(t),1],d=[T0(c,u[0]),T0(c,u[1])];return l.map((e=>[Math.trunc(e[0]+d[0]),Math.trunc(e[1]+d[1]),Math.trunc(e[2])]))}async estimateHands(e,t){let n,r=!1;const a=(t.hand.skipTime||0)>h()-D0,s=this.skipped<(t.hand.skipFrames||0);t.skipAllowed&&a&&s&&(n=await this.handDetector.predict(e,t),this.skipped=0),t.skipAllowed&&this.skipped++,n&&n.length>0&&(n.length!==this.detectedHands&&this.detectedHands!==t.hand.maxDetected||!t.hand.landmarks)&&(this.detectedHands=0,this.storedBoxes=[...n],this.storedBoxes.length>0&&(r=!0));const o=[];for(let n=0;n<this.storedBoxes.length;n++){const a=this.storedBoxes[n];if(a)if(t.hand.landmarks){const s=t.hand.rotation?E0(a.palmLandmarks[0],a.palmLandmarks[2]):0,i=w0(a),l=[i[0]/e.shape[2],i[1]/e.shape[1]],u=t.hand.rotation&&HZ.kernels.includes("rotatewithoffset")?Zp.rotateWithOffset(e,s,0,l):e.clone(),c=M0(-s,i),d=r?this.getBoxForPalmLandmarks(a.palmLandmarks,c):a,p=k0(d,u,[this.inputSize,this.inputSize]),f=Dl(p,YY.tf255);yi(p),yi(u);const[m,A]=this.handPoseModel.execute(f);D0=h(),yi(f);const g=(await m.data())[0];if(yi(m),g>=t.hand.minConfidence/4){const e=du(A,[-1,3]),t=await e.array();yi(A),yi(e);const r=this.transformRawCoords(t,d,s,c),i=this.getBoxForHandLandmarks(r);this.storedBoxes[n]={...i,confidence:g};const l={landmarks:r,confidence:g,boxConfidence:a.confidence,fingerConfidence:g,box:{topLeft:i.startPoint,bottomRight:i.endPoint}};o.push(l)}else this.storedBoxes[n]=null;yi(A)}else{const e=I0(C0(a),1.65),t={confidence:a.confidence,boxConfidence:a.confidence,fingerConfidence:0,box:{topLeft:e.startPoint,bottomRight:e.endPoint},landmarks:[]};o.push(t)}}return this.storedBoxes=this.storedBoxes.filter((e=>null!==e)),this.detectedHands=o.length,o.length>t.hand.maxDetected&&(o.length=t.hand.maxDetected),o}}(r,I1),[S1,I1]}var R1,_1=[null,null],M1=["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],$1=[[0,0],[0,0]],F1=["hand","fist","pinch","point","face","tip","pinchtip"],O1=Number.MAX_SAFE_INTEGER,D1=0,z1=[0,0],P1={boxes:[],hands:[]},L1={thumb:[1,2,3,4],index:[5,6,7,8],middle:[9,10,11,12],ring:[13,14,15,16],pinky:[17,18,19,20],base:[0],palm:[0,17,13,9,5,1,0]};async function B1(e,t,n){const r={id:t.id,score:Math.round(100*t.score)/100,boxScore:Math.round(100*t.score)/100,fingerScore:0,box:t.box,boxRaw:t.boxRaw,label:t.label,keypoints:[],landmarks:{},annotations:{}};if(e&&_1[1]&&n.hand.landmarks&&t.score>(n.hand.minConfidence||0)){const a={},s=[t.boxRaw[1],t.boxRaw[0],t.boxRaw[3]+t.boxRaw[1],t.boxRaw[2]+t.boxRaw[0]];a.crop=Zp.cropAndResize(e,[s],[0],[$1[1][0],$1[1][1]],"bilinear"),a.div=Dl(a.crop,YY.tf255),[a.score,a.keypoints]=_1[1].execute(a.div,["Identity_1","Identity"]);const o=(await a.score.data())[0],i=(100-Math.trunc(100/(1+Math.exp(o))))/100;if(i>=(n.hand.minConfidence||0)){r.fingerScore=i,a.reshaped=du(a.keypoints,[-1,3]);const e=(await a.reshaped.array()).map((e=>[e[0]/$1[1][1],e[1]/$1[1][0],e[2]||0])).map((e=>[e[0]*t.boxRaw[2],e[1]*t.boxRaw[3],e[2]||0]));r.keypoints=e.map((e=>[z1[0]*(e[0]+t.boxRaw[0]),z1[1]*(e[1]+t.boxRaw[1]),e[2]||0])),r.landmarks=w1(r.keypoints);for(const e of Object.keys(L1))r.annotations[e]=L1[e].map((e=>r.landmarks&&r.keypoints[e]?r.keypoints[e]:null))}Object.keys(a).forEach((e=>yi(a[e])))}return r}async function W1(e,t){var n,r;if(!(_1[0]&&_1[1]&&(null==(n=_1[0])?void 0:n.inputs[0].shape)&&(null==(r=_1[1])?void 0:r.inputs[0].shape)))return[];z1=[e.shape[2]||0,e.shape[1]||0],O1++;const a=(t.hand.skipTime||0)>h()-D1,s=O1<(t.hand.skipFrames||0);return t.skipAllowed&&a&&s?P1.hands:new Promise((async n=>{const r=3*(t.hand.skipTime||0)>h()-D1,a=O1<3*(t.hand.skipFrames||0);t.skipAllowed&&P1.hands.length===t.hand.maxDetected||t.skipAllowed&&r&&a&&P1.hands.length>0?P1.hands=await Promise.all(P1.boxes.map((n=>B1(e,n,t)))):(P1.boxes=await async function(e,t){const n=[];if(!e||!_1[0])return n;const r={},a=(e.shape[2]||1)/(e.shape[1]||1),s=Math.min(8*Math.round((e.shape[1]||0)/8),512),o=8*Math.round(s*a/8);r.resize=Zp.resizeBilinear(e,[s,o]),r.cast=zo(r.resize,"int32"),[r.rawScores,r.rawBoxes]=await _1[0].executeAsync(r.cast,M1),r.boxes=ph(r.rawBoxes,[0,2]),r.scores=ph(r.rawScores,[0]);const i=Eh(r.scores,1);yi(i[4]),i.splice(4,1),r.filtered=fh(i,1),yi(i),r.max=dc(r.filtered,1),r.argmax=jl(r.filtered,1);let l=0;r.nms=await Zp.nonMaxSuppressionAsync(r.boxes,r.max,(t.hand.maxDetected||0)+1,t.hand.iouThreshold||0,t.hand.minConfidence||1);const u=await r.nms.data(),c=await r.max.data(),d=await r.argmax.data();for(const e of Array.from(u)){const t=Au(r.boxes,e,1),a=await t.data();yi(t);const s=[a[1],a[0],a[3]-a[1],a[2]-a[0]],o=eQ(s,1.4),i=[Math.trunc(s[0]*z1[0]),Math.trunc(s[1]*z1[1]),Math.trunc(s[2]*z1[0]),Math.trunc(s[3]*z1[1])],u={id:l++,score:c[e],box:i,boxRaw:o,label:F1[d[e]]};n.push(u)}return Object.keys(r).forEach((e=>yi(r[e]))),n.sort(((e,t)=>t.score-e.score)),n.length>(t.hand.maxDetected||1)&&(n.length=t.hand.maxDetected||1),n}(e,t),D1=h(),P1.hands=await Promise.all(P1.boxes.map((n=>B1(e,n,t)))),O1=0);const s=[...P1.boxes];if(P1.boxes.length=0,t.cacheSensitivity>0)for(let n=0;n<P1.hands.length;n++){const r=QJ(P1.hands[n].keypoints,z1);if(r.box[2]/(e.shape[2]||1)>.05&&r.box[3]/(e.shape[1]||1)>.05&&P1.hands[n].fingerScore&&P1.hands[n].fingerScore>(t.hand.minConfidence||0)){const e=eQ(r.box,1.6),t=eQ(r.boxRaw,1.6);P1.boxes.push({...s[n],box:e,boxRaw:t})}}for(let e=0;e<P1.hands.length;e++){const t=JJ(P1.hands[e].keypoints,z1);P1.hands[e].box=t.box,P1.hands[e].boxRaw=t.boxRaw}n(P1.hands)}))}var U1=[],V1=Number.MAX_SAFE_INTEGER,j1=0,G1=0;async function H1(e,t,n,r){var a,s;if(!R1)return 0;const o=((null==(a=t.face.liveness)?void 0:a.skipTime)||0)>h()-G1,i=V1<((null==(s=t.face.liveness)?void 0:s.skipFrames)||0);return t.skipAllowed&&o&&i&&j1===r&&U1[n]?(V1++,U1[n]):(V1=0,new Promise((async t=>{const a=Zp.resizeBilinear(e,[(null==R1?void 0:R1.inputs[0].shape)?R1.inputs[0].shape[2]:0,(null==R1?void 0:R1.inputs[0].shape)?R1.inputs[0].shape[1]:0],!1),s=null==R1?void 0:R1.execute(a),o=(await s.data())[0];U1[n]=Math.round(100*o)/100,j1=r,G1=h(),yi([a,s]),t(U1[n])})))}var q1={};s(q1,{connected:()=>Q1,horizontal:()=>Z1,kpt:()=>K1,relative:()=>J1,vertical:()=>Y1});var X1,K1=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],Z1=[["leftEye","rightEye"],["leftEar","rightEar"],["leftShoulder","rightShoulder"],["leftElbow","rightElbow"],["leftWrist","rightWrist"],["leftHip","rightHip"],["leftKnee","rightKnee"],["leftAnkle","rightAnkle"]],Y1=[["leftKnee","leftShoulder"],["rightKnee","rightShoulder"],["leftAnkle","leftKnee"],["rightAnkle","rightKnee"]],J1=[[["leftHip","rightHip"],["leftShoulder","rightShoulder"]],[["leftElbow","rightElbow"],["leftShoulder","rightShoulder"]]],Q1={leftLeg:["leftHip","leftKnee","leftAnkle"],rightLeg:["rightHip","rightKnee","rightAnkle"],torso:["leftShoulder","rightShoulder","rightHip","leftHip","leftShoulder"],leftArm:["leftShoulder","leftElbow","leftWrist"],rightArm:["rightShoulder","rightElbow","rightWrist"],head:[]},e2={keypoints:[],padding:[[0,0],[0,0],[0,0],[0,0]]};function t2(e){for(const t of Z1){const n=e.keypoints.findIndex((e=>e.part===t[0])),r=e.keypoints.findIndex((e=>e.part===t[1]));if(e.keypoints[n]&&e.keypoints[r]&&e.keypoints[n].position[0]<e.keypoints[r].position[0]){const t=e.keypoints[n];e.keypoints[n]=e.keypoints[r],e.keypoints[r]=t}}for(const t of Y1){const n=e.keypoints.findIndex((e=>e&&e.part===t[0])),r=e.keypoints.findIndex((e=>e&&e.part===t[1]));e.keypoints[n]&&e.keypoints[r]&&e.keypoints[n].position[1]<e.keypoints[r].position[1]&&e.keypoints.splice(n,1)}for(const[t,n]of J1){const r=e.keypoints.findIndex((e=>e&&e.part===t[0])),a=e.keypoints.findIndex((e=>e&&e.part===t[1])),s=e.keypoints.findIndex((e=>e&&e.part===n[0])),o=e.keypoints.findIndex((e=>e&&e.part===n[1]));if(!e.keypoints[s]||!e.keypoints[o])continue;const i=e.keypoints[r]?[Math.abs(e.keypoints[s].position[0]-e.keypoints[r].position[0]),Math.abs(e.keypoints[o].position[0]-e.keypoints[r].position[0])]:[0,0],l=e.keypoints[a]?[Math.abs(e.keypoints[o].position[0]-e.keypoints[a].position[0]),Math.abs(e.keypoints[s].position[0]-e.keypoints[a].position[0])]:[0,0];if(i[0]>i[1]||l[0]>l[1]){const t=e.keypoints[r];e.keypoints[r]=e.keypoints[a],e.keypoints[a]=t}}}function n2(e){for(let t=0;t<e.length;t++)if(e[t]&&e2.keypoints[t]){const n=[Math.abs(e[t].positionRaw[0]-e2.keypoints[t].positionRaw[0]),Math.abs(e[t].positionRaw[1]-e2.keypoints[t].positionRaw[1])];n[0]<.005&&n[1]<.005?e[t]=e2.keypoints[t]:e2.keypoints[t]=e[t]}else e2.keypoints[t]=e[t];return e}function r2(e,t){e.keypoints=e.keypoints.filter((e=>e&&e.position));for(const n of e.keypoints)n.position=[n.position[0]*(t[0]+e2.padding[2][0]+e2.padding[2][1])/t[0]-e2.padding[2][0],n.position[1]*(t[1]+e2.padding[1][0]+e2.padding[1][1])/t[1]-e2.padding[1][0]],n.positionRaw=[n.position[0]/t[0],n.position[1]/t[1]];const n=JJ(e.keypoints.map((e=>e.position)),t);return e.box=n.box,e.boxRaw=n.boxRaw,e}var a2,s2=0,o2=Number.MAX_SAFE_INTEGER,i2={boxes:[],bodies:[],last:0};async function l2(e,t){if(!X1||!(null==X1?void 0:X1.inputs[0].shape))return[];t.skipAllowed||(i2.boxes.length=0),o2++;const n=(t.body.skipTime||0)>h()-i2.last,r=o2<(t.body.skipFrames||0);return t.skipAllowed&&n&&r?i2.bodies:new Promise((async n=>{const r={};o2=0,r.input=function(e,t){const n={};if(!e.shape||!e.shape[1]||!e.shape[2])return e;e2.padding=[[0,0],[e.shape[2]>e.shape[1]?Math.trunc((e.shape[2]-e.shape[1])/2):0,e.shape[2]>e.shape[1]?Math.trunc((e.shape[2]-e.shape[1])/2):0],[e.shape[1]>e.shape[2]?Math.trunc((e.shape[1]-e.shape[2])/2):0,e.shape[1]>e.shape[2]?Math.trunc((e.shape[1]-e.shape[2])/2):0],[0,0]],n.pad=kd(e,e2.padding),n.resize=Zp.resizeBilinear(n.pad,[t,t]);const r=zo(n.resize,"int32");return Object.keys(n).forEach((e=>yi(n[e]))),r}(e,s2),r.res=null==X1?void 0:X1.execute(r.input),i2.last=h();const a=await r.res.array();i2.bodies=17===r.res.shape[2]?await async function(e,t,n){const r=e[0][0],a=[];let s=0;for(let e=0;e<r.length;e++)if(s=r[e][2],s>t.body.minConfidence){const t=[r[e][1],r[e][0]];a.push({score:Math.round(100*s)/100,part:K1[e],positionRaw:t,position:[Math.round((n.shape[2]||0)*t[0]),Math.round((n.shape[1]||0)*t[1])]})}s=a.reduce(((e,t)=>t.score>e?t.score:e),0);const o=[],i=JJ(a.map((e=>e.position)),[n.shape[2],n.shape[1]]),l={};for(const[e,n]of Object.entries(Q1)){const r=[];for(let e=0;e<n.length-1;e++){const s=a.find((t=>t.part===n[e])),o=a.find((t=>t.part===n[e+1]));s&&o&&s.score>(t.body.minConfidence||0)&&o.score>(t.body.minConfidence||0)&&r.push([s.position,o.position])}l[e]=r}const u={id:0,score:s,box:i.box,boxRaw:i.boxRaw,keypoints:a,annotations:l};return t2(u),o.push(u),o}(a,t,e):await async function(e,t,n){const r=[];for(let a=0;a<e[0].length;a++){const s=e[0][a],o=Math.round(100*s[55])/100;if(o>t.body.minConfidence){const e=[];for(let r=0;r<17;r++){const a=s[3*r+2];if(a>t.body.minConfidence){const t=[s[3*r+1],s[3*r+0]];e.push({part:K1[r],score:Math.round(100*a)/100,positionRaw:t,position:[Math.round((n.shape[2]||0)*t[0]),Math.round((n.shape[1]||0)*t[1])]})}}const i=JJ(e.map((e=>e.position)),[n.shape[2],n.shape[1]]),l={};for(const[n,r]of Object.entries(Q1)){const a=[];for(let n=0;n<r.length-1;n++){const s=e.find((e=>e.part===r[n])),o=e.find((e=>e.part===r[n+1]));s&&o&&s.score>(t.body.minConfidence||0)&&o.score>(t.body.minConfidence||0)&&a.push([s.position,o.position])}l[n]=a}const u={id:a,score:o,box:i.box,boxRaw:i.boxRaw,keypoints:[...e],annotations:l};t2(u),r.push(u)}}return r.sort(((e,t)=>t.score-e.score)),r.length>t.body.maxDetected&&(r.length=t.body.maxDetected),r}(a,t,e);for(const t of i2.bodies)r2(t,[e.shape[2]||1,e.shape[1]||1]),n2(t.keypoints);Object.keys(r).forEach((e=>yi(r[e]))),n(i2.bodies)}))}var u2=[],c2=0,d2=Number.MAX_SAFE_INTEGER,h2=0,p2=2.5;async function f2(e,t){const n=(t.object.skipTime||0)>h()-c2,r=d2<(t.object.skipFrames||0);return t.skipAllowed&&n&&r&&u2.length>0?(d2++,u2):(d2=0,HZ.kernels.includes("mod")&&HZ.kernels.includes("sparsetodense")?new Promise((async n=>{const r=[e.shape[2]||0,e.shape[1]||0],a=Zp.resizeBilinear(e,[h2,h2],!1),s=Dl(a,YY.tf255),o=s.transpose([0,3,1,2]);let i;yi(s),yi(a),t.object.enabled&&(i=a2.execute(o)),c2=h(),yi(o);const l=await async function(e,t,n){let r=0,a=[];for(const s of[1,2,4])gi((async()=>{const o=13*s,i=ph(e.find((e=>e.shape[1]===o**2&&(e.shape[2]||0)===fQ.length))),l=ph(e.find((e=>e.shape[1]===o**2&&(e.shape[2]||0)<fQ.length))),u=l.reshape([-1,4,l.shape[1]/4]),c=await u.argMax(2).array(),d=await i.array();for(let e=0;e<i.shape[0];e++)for(let l=0;l<i.shape[1];l++){const i=d[e][l];if(i>(n.object.minConfidence||0)&&61!==l){const n=(.5+Math.trunc(e%o))/o,u=(.5+Math.trunc(e/o))/o,d=c[e].map((e=>e*(o/s/h2))),[h,p]=[n-p2/s*d[0],u-p2/s*d[1]],[f,m]=[n+p2/s*d[2]-h,u+p2/s*d[3]-p];let A=[h,p,f,m];A=A.map((e=>Math.max(0,Math.min(e,1))));const g=[A[0]*t[0],A[1]*t[1],A[2]*t[0],A[3]*t[1]],y={id:r++,score:Math.round(100*i)/100,class:l+1,label:fQ[l].label,box:g.map((e=>Math.trunc(e))),boxRaw:A};a.push(y)}}}));e.forEach((e=>yi(e)));const s=a.map((e=>[e.boxRaw[1],e.boxRaw[0],e.boxRaw[3],e.boxRaw[2]])),o=a.map((e=>e.score));let i=[];if(s&&s.length>0){const e=await Zp.nonMaxSuppressionAsync(s,o,n.object.maxDetected,n.object.iouThreshold,n.object.minConfidence);i=await e.data(),yi(e)}return a=a.filter(((e,t)=>i.includes(t))).sort(((e,t)=>t.score-e.score)),a}(i,r,t);u2=l,n(l)})):u2)}var m2=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],A2=m2.length,g2=m2.reduce(((e,t,n)=>(e[t]=n,e)),{}),y2=([["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map((([e,t])=>[g2[e],g2[t]])),[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]]);function x2(e){const t=e.reduce((({maxX:e,maxY:t,minX:n,minY:r},{position:{x:a,y:s}})=>({maxX:Math.max(e,a),maxY:Math.max(t,s),minX:Math.min(n,a),minY:Math.min(r,s)})),{maxX:Number.NEGATIVE_INFINITY,maxY:Number.NEGATIVE_INFINITY,minX:Number.POSITIVE_INFINITY,minY:Number.POSITIVE_INFINITY});return[t.minX,t.minY,t.maxX-t.minX,t.maxY-t.minY]}function b2(e,[t,n],[r,a]){const s=t/r,o=n/a;return e.map(((e,t)=>((e,t)=>({id:t,score:e.score,boxRaw:[e.box[0]/a,e.box[1]/r,e.box[2]/a,e.box[3]/r],box:[Math.trunc(e.box[0]*o),Math.trunc(e.box[1]*s),Math.trunc(e.box[2]*o),Math.trunc(e.box[3]*s)],keypoints:e.keypoints.map((({score:e,part:t,position:n})=>({score:e,part:t,position:[Math.trunc(n.x*o),Math.trunc(n.y*s)],positionRaw:[n.x/r,n.y/r]}))),annotations:{}}))(e,t)))}var v2;function w2(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+A2)}}function k2(e,t,n){const{heatmapY:r,heatmapX:a,id:s}=e,{y:o,x:i}=w2(r,a,s,n);return{x:e.heatmapX*t+i,y:e.heatmapY*t+o}}function S2(e,t,n){return e<t?t:e>n?n:e}function I2(e,t){return{x:e.x+t.x,y:e.y+t.y}}var C2,E2=["MobilenetV1/offset_2/BiasAdd","MobilenetV1/heatmap_2/BiasAdd","MobilenetV1/displacement_fwd_2/BiasAdd","MobilenetV1/displacement_bwd_2/BiasAdd"],N2=16;function T2(e,t,n,r,a,s,o=2){const i=(e,t,n)=>({y:S2(Math.round(e.y/N2),0,t-1),x:S2(Math.round(e.x/N2),0,n-1)}),[l,u]=r.shape,c=i(t.position,l,u),d=(h=c,{y:s.get(h.y,h.x,e),x:s.get(h.y,h.x,s.shape[2]/2+e)});var h;let p=I2(t.position,d);for(let e=0;e<o;e++){const e=i(p,l,u),t=w2(e.y,e.x,n,a);p=I2({x:e.x*N2,y:e.y*N2},{x:t.x,y:t.y})}const f=i(p,l,u),m=r.get(f.y,f.x,n);return{position:p,part:m2[n],score:m}}function R2(e,t,n,r,a){const s=y2.map((([e,t])=>[g2[e],g2[t]])),o=s.map((([,e])=>e)),i=s.map((([e])=>e)),l=t.shape[2],u=o.length,c=new Array(l),d=k2(e.part,N2,n);c[e.part.id]={score:e.score,part:m2[e.part.id],position:d};for(let e=u-1;e>=0;--e){const r=o[e],s=i[e];c[r]&&!c[s]&&(c[s]=T2(e,c[r],s,t,n,a))}for(let e=0;e<u;++e){const a=i[e],s=o[e];c[a]&&!c[s]&&(c[s]=T2(e,c[a],s,t,n,r))}return c}function _2(e,t,n,r,a){const[s,o]=a.shape;let i=!0;const l=Math.max(n-1,0),u=Math.min(n+1+1,s);for(let n=l;n<u;++n){const s=Math.max(r-1,0),l=Math.min(r+1+1,o);for(let r=s;r<l;++r)if(a.get(n,r,e)>t){i=!1;break}if(!i)break}return i}function M2(e,t){const[n,r,a]=t.shape,s=new class{constructor(e,t){o(this,"priorityQueue"),o(this,"numberOfElements"),o(this,"getElementValue"),this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}enqueue(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)}dequeue(){const e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e}empty(){return-1===this.numberOfElements}size(){return this.numberOfElements+1}all(){return this.priorityQueue.slice(0,this.numberOfElements+1)}max(){return this.priorityQueue[0]}swim(e){for(;e>0&&this.less(Math.floor(e/2),e);)this.exchange(e,Math.floor(e/2)),e=Math.floor(e/2)}sink(e){for(;2*e<=this.numberOfElements;){let t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}}getValueAt(e){return this.getElementValue(this.priorityQueue[e])}less(e,t){return this.getValueAt(e)<this.getValueAt(t)}exchange(e,t){const n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n}}(n*r*a,(({score:e})=>e));for(let o=0;o<n;++o)for(let n=0;n<r;++n)for(let r=0;r<a;++r){const a=t.get(o,n,r);a<e||_2(r,a,o,n,t)&&s.enqueue({score:a,part:{heatmapY:o,heatmapX:n,id:r}})}return s}function $2(e,{x:t,y:n},r){return e.some((({keypoints:e})=>{var a;const s=null==(a=e[r])?void 0:a.position;return!!s&&function(e,t,n,r){const a=n-e,s=r-t;return a*a+s*s}(n,t,s.y,s.x)<=2500}))}function F2(e,t){return t.reduce(((t,{position:n,score:r},a)=>($2(e,n,a)||(t+=r),t)),0)/t.length}async function O2(e,t){const n=gi((()=>{if(!v2.inputs[0].shape)return[];const t=Zp.resizeBilinear(e,[v2.inputs[0].shape[2],v2.inputs[0].shape[1]]),n=Zc(Dl(zo(t,"float32"),127.5),1),r=v2.execute(n,E2).map((e=>ph(e,[0])));return r[1]=mu(r[1]),r})),r=await Promise.all(n.map((e=>e.buffer())));for(const e of n)yi(e);const a=await function(e,t,n,r,a,s){const o=[],i=M2(s,t);for(;o.length<a&&!i.empty();){const a=i.dequeue();if($2(o,k2(a.part,N2,e),a.part.id))continue;let l=R2(a,t,e,n,r);l=l.filter((e=>e.score>s));const u=F2(o,l),c=x2(l);u>s&&o.push({keypoints:l,box:c,score:Math.round(100*u)/100})}return o}(r[0],r[1],r[2],r[3],t.body.maxDetected,t.body.minConfidence);if(!v2.inputs[0].shape)return[];return b2(a,[e.shape[1],e.shape[2]],[v2.inputs[0].shape[2],v2.inputs[0].shape[1]])}var D2=!1;async function z2(e){return!C2||HZ.initial?C2=await LY(e.segmentation.modelPath):e.debug&&d("cached model:",C2.modelUrl),C2}var P2=class{constructor(){o(this,"ssrnetage",null),o(this,"gear",null),o(this,"blazeposedetect",null),o(this,"blazepose",null),o(this,"centernet",null),o(this,"efficientpose",null),o(this,"mobilefacenet",null),o(this,"emotion",null),o(this,"facedetect",null),o(this,"faceiris",null),o(this,"facemesh",null),o(this,"faceres",null),o(this,"ssrnetgender",null),o(this,"handpose",null),o(this,"handskeleton",null),o(this,"handtrack",null),o(this,"liveness",null),o(this,"movenet",null),o(this,"nanodet",null),o(this,"posenet",null),o(this,"segmentation",null),o(this,"antispoof",null)}},L2=e=>{let t=0,n=0,r=0;for(const e of Object.values(PY))t+=e.sizeFromManifest,n+=e.sizeLoadedWeights,r+=e.sizeDesired;const a=r>0?n/r:0;return{numLoadedModels:Object.values(PY).length,numEnabledModels:void 0,numDefinedModels:Object.keys(e.models).length,percentageLoaded:a,totalSizeFromManifest:t,totalSizeWeights:n,totalSizeLoading:r,totalSizeEnabled:void 0,modelStats:Object.values(PY)}};function B2(e){for(const t of Object.keys(e.models))e.models[t]=null}async function W2(e){var t,n,r,a,s,o,i,l,u,c,h,p,f,m,A,g,y,x,b,v,w,k,S,I,C,E,N,T,R,_,M;HZ.initial&&B2(e),e.config.hand.enabled&&(!e.models.handpose&&(null==(n=null==(t=e.config.hand.detector)?void 0:t.modelPath)?void 0:n.includes("handdetect"))&&([e.models.handpose,e.models.handskeleton]=await T1(e.config)),!e.models.handskeleton&&e.config.hand.landmarks&&(null==(a=null==(r=e.config.hand.detector)?void 0:r.modelPath)?void 0:a.includes("handdetect"))&&([e.models.handpose,e.models.handskeleton]=await T1(e.config))),e.config.body.enabled&&!e.models.blazepose&&(null==(o=null==(s=e.config.body)?void 0:s.modelPath)?void 0:o.includes("blazepose"))&&(e.models.blazepose=async function(e){if(tQ&&(nQ.landmarks=null),nQ.landmarks)e.debug&&d("cached model:",nQ.landmarks.modelUrl);else{nQ.landmarks=await LY(e.body.modelPath);const t=Object.values(nQ.landmarks.modelSignature.inputs);rQ.landmarks[0]=Array.isArray(t)?parseInt(t[0].tensorShape.dim[1].size):0,rQ.landmarks[1]=Array.isArray(t)?parseInt(t[0].tensorShape.dim[2].size):0}return nQ.landmarks}(e.config)),e.config.body.enabled&&!e.models.blazeposedetect&&e.config.body.detector&&e.config.body.detector.modelPath&&(e.models.blazeposedetect=cQ(e.config)),e.config.body.enabled&&!e.models.efficientpose&&(null==(l=null==(i=e.config.body)?void 0:i.modelPath)?void 0:l.includes("efficientpose"))&&(e.models.efficientpose=async function(e){return HZ.initial&&(vQ=null),vQ?e.debug&&d("cached model:",vQ.modelUrl):vQ=await LY(e.body.modelPath),vQ}(e.config)),e.config.body.enabled&&!e.models.movenet&&(null==(c=null==(u=e.config.body)?void 0:u.modelPath)?void 0:c.includes("movenet"))&&(e.models.movenet=async function(e){return HZ.initial&&(X1=null),X1?e.debug&&d("cached model:",X1.modelUrl):(H2(["size"],e),X1=await LY(e.body.modelPath)),(s2=X1.inputs[0].shape?X1.inputs[0].shape[2]:0)<64&&(s2=256),X1}(e.config)),e.config.body.enabled&&!e.models.posenet&&(null==(p=null==(h=e.config.body)?void 0:h.modelPath)?void 0:p.includes("posenet"))&&(e.models.posenet=async function(e){return!v2||HZ.initial?v2=await LY(e.body.modelPath):e.debug&&d("cached model:",v2.modelUrl),v2}(e.config)),e.config.face.enabled&&!e.models.facedetect&&(e.models.facedetect=HJ(e.config)),e.config.face.enabled&&(null==(f=e.config.face.antispoof)?void 0:f.enabled)&&!e.models.antispoof&&(e.models.antispoof=async function(e){var t;return HZ.initial&&(aJ=null),aJ?e.debug&&d("cached model:",aJ.modelUrl):aJ=await LY(null==(t=e.face.antispoof)?void 0:t.modelPath),aJ}(e.config)),e.config.face.enabled&&(null==(m=e.config.face.liveness)?void 0:m.enabled)&&!e.models.liveness&&(e.models.liveness=async function(e){var t;return HZ.initial&&(R1=null),R1?e.debug&&d("cached model:",R1.modelUrl):R1=await LY(null==(t=e.face.liveness)?void 0:t.modelPath),R1}(e.config)),e.config.face.enabled&&(null==(A=e.config.face.description)?void 0:A.enabled)&&!e.models.faceres&&(e.models.faceres=async function(e){var t;return HZ.initial&&(h0=null),h0?e.debug&&d("cached model:",h0.modelUrl):h0=await LY(null==(t=e.face.description)?void 0:t.modelPath),h0}(e.config)),e.config.face.enabled&&(null==(g=e.config.face.emotion)?void 0:g.enabled)&&!e.models.emotion&&(e.models.emotion=async function(e){var t;return HZ.initial&&(TQ=null),TQ?e.debug&&d("cached model:",TQ.modelUrl):TQ=await LY(null==(t=e.face.emotion)?void 0:t.modelPath),TQ}(e.config)),e.config.face.enabled&&(null==(y=e.config.face.iris)?void 0:y.enabled)&&!(null==(x=e.config.face.attention)?void 0:x.enabled)&&!e.models.faceiris&&(e.models.faceiris=async function(e){var t;return HZ.initial&&(zQ=null),zQ?e.debug&&d("cached model:",zQ.modelUrl):zQ=await LY(null==(t=e.face.iris)?void 0:t.modelPath),-1===(VQ=zQ.inputs[0].shape?zQ.inputs[0].shape[2]:0)&&(VQ=64),zQ}(e.config)),e.config.face.enabled&&(null==(b=e.config.face.mesh)?void 0:b.enabled)&&!e.models.facemesh&&(e.models.facemesh=async function(e){var t,n,r,a,s,o;return HZ.initial&&(c0=null),(null==(n=null==(t=null==e?void 0:e.face)?void 0:t.attention)?void 0:n.enabled)&&(null==c0?void 0:c0.signature)&&Object.keys((null==(r=null==c0?void 0:c0.signature)?void 0:r.outputs)||{}).length<6&&(c0=null),c0?e.debug&&d("cached model:",c0.modelUrl):c0=(null==(a=e.face.attention)?void 0:a.enabled)?await LY(null==(s=e.face.attention)?void 0:s.modelPath):await LY(null==(o=e.face.mesh)?void 0:o.modelPath),d0=c0.inputs[0].shape?c0.inputs[0].shape[2]:0,c0}(e.config)),e.config.face.enabled&&(null==(v=e.config.face.gear)?void 0:v.enabled)&&!e.models.gear&&(e.models.gear=async function(e){var t;return HZ.initial&&(BY=null),BY?e.debug&&d("cached model:",BY.modelUrl):BY=await LY(null==(t=e.face.gear)?void 0:t.modelPath),BY}(e.config)),e.config.face.enabled&&(null==(w=e.config.face.ssrnet)?void 0:w.enabled)&&!e.models.ssrnetage&&(e.models.ssrnetage=async function(e){return HZ.initial&&(ZY=null),ZY?e.debug&&d("cached model:",ZY.modelUrl):ZY=await LY(e.face.ssrnet.modelPathAge),ZY}(e.config)),e.config.face.enabled&&(null==(k=e.config.face.ssrnet)?void 0:k.enabled)&&!e.models.ssrnetgender&&(e.models.ssrnetgender=async function(e){return HZ.initial&&(JY=null),JY?e.debug&&d("cached model:",JY.modelUrl):JY=await LY(e.face.ssrnet.modelPathGender),JY}(e.config)),e.config.face.enabled&&(null==(S=e.config.face.mobilefacenet)?void 0:S.enabled)&&!e.models.mobilefacenet&&(e.models.mobilefacenet=async function(e){return HZ.initial&&(RQ=null),RQ?e.debug&&d("cached model:",RQ.modelUrl):RQ=await LY(e.face.mobilefacenet.modelPath),RQ}(e.config)),e.config.hand.enabled&&!e.models.handtrack&&(null==(C=null==(I=e.config.hand.detector)?void 0:I.modelPath)?void 0:C.includes("handtrack"))&&(e.models.handtrack=async function(e){var t;if(HZ.initial&&(_1[0]=null),_1[0])e.debug&&d("cached model:",_1[0].modelUrl);else{H2(["tensorlistreserve","enter","tensorlistfromtensor","merge","loopcond","switch","exit","tensorliststack","nextiteration","tensorlistsetitem","tensorlistgetitem","reciprocal","shape","split","where"],e),_1[0]=await LY(null==(t=e.hand.detector)?void 0:t.modelPath);const n=Object.values(_1[0].modelSignature.inputs);$1[0][0]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[1].size):0,$1[0][1]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[2].size):0}return _1[0]}(e.config)),e.config.hand.enabled&&e.config.hand.landmarks&&!e.models.handskeleton&&(null==(N=null==(E=e.config.hand.detector)?void 0:E.modelPath)?void 0:N.includes("handtrack"))&&(e.models.handskeleton=async function(e){var t;if(HZ.initial&&(_1[1]=null),_1[1])e.debug&&d("cached model:",_1[1].modelUrl);else{_1[1]=await LY(null==(t=e.hand.skeleton)?void 0:t.modelPath);const n=Object.values(_1[1].modelSignature.inputs);$1[1][0]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[1].size):0,$1[1][1]=Array.isArray(n)?parseInt(n[0].tensorShape.dim[2].size):0}return _1[1]}(e.config)),e.config.object.enabled&&!e.models.centernet&&(null==(R=null==(T=e.config.object)?void 0:T.modelPath)?void 0:R.includes("centernet"))&&(e.models.centernet=async function(e){if(HZ.initial&&(pQ=null),pQ)e.debug&&d("cached model:",pQ.modelUrl);else{pQ=await LY(e.object.modelPath);const t=Object.values(pQ.modelSignature.inputs);mQ=Array.isArray(t)?parseInt(t[0].tensorShape.dim[2].size):0}return pQ}(e.config)),e.config.object.enabled&&!e.models.nanodet&&(null==(M=null==(_=e.config.object)?void 0:_.modelPath)?void 0:M.includes("nanodet"))&&(e.models.nanodet=async function(e){if(!a2||HZ.initial){a2=await LY(e.object.modelPath);const t=Object.values(a2.modelSignature.inputs);h2=Array.isArray(t)?parseInt(t[0].tensorShape.dim[2].size):0}else e.debug&&d("cached model:",a2.modelUrl);return a2}(e.config)),e.config.segmentation.enabled&&!e.models.segmentation&&(e.models.segmentation=z2(e.config));for await(const t of Object.keys(e.models))e.models[t]&&void 0!==e.models[t]&&(e.models[t]=await e.models[t])}async function U2(e){const t=["const","placeholder","noop","pad","squeeze","add","sub","mul","div"];for(const n of Object.keys(e.models)){const r=e.models[n];if(!r)continue;const a=[],s=null==r?void 0:r.executor;if(s&&s.graph.nodes)for(const e of Object.values(s.graph.nodes)){const t=e.op.toLowerCase();a.includes(t)||a.push(t)}else!s&&e.config.debug&&d("model signature not determined:",n);const o=[];for(const n of a)t.includes(n)||e.env.kernels.includes(n)||e.env.kernels.includes(n.replace("_",""))||e.env.kernels.includes(n.replace("native",""))||e.env.kernels.includes(n.replace("v2",""))||o.push(n);e.config.debug&&o.length>0&&d("model validation failed:",n,o)}}var V2={name:"humangl",priority:999,canvas:null,gl:null,extensions:[],webGLattr:{alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!1,desynchronized:!0}};async function j2(e){var t;if("humangl"===e.config.backend&&(!(V2.name in fi().registry)||V2.gl&&V2.gl.getParameter(V2.gl.VERSION)||(d("error: humangl backend invalid context"),B2(e)),!Ii(V2.name))){try{V2.canvas=await VZ(100,100)}catch(e){return void d("error: cannot create canvas:",e)}try{V2.gl=null==(t=V2.canvas)?void 0:t.getContext("webgl2",V2.webGLattr);if(!V2.gl.getParameter(V2.gl.VERSION).includes("2.0"))return d("override: using fallback webgl backend as webgl 2.0 is not detected"),void(e.config.backend="webgl");V2.canvas&&(V2.canvas.addEventListener("webglcontextlost",(async t=>{throw d("error: humangl:",t.type),d("possible browser memory leak using webgl or conflict with multiple backend registrations"),e.emit("error"),new Error("backend error: webgl context lost")})),V2.canvas.addEventListener("webglcontextrestored",(e=>{d("error: humangl context restored:",e)})),V2.canvas.addEventListener("webglcontextcreationerror",(e=>{d("error: humangl context create:",e)})))}catch(e){return void d("error: cannot get WebGL context:",e)}try{F$(2,V2.gl)}catch(e){return void d("error: cannot set WebGL context:",e)}try{const e=new RO(V2.gl);Ei(V2.name,(()=>new $D(e)),V2.priority)}catch(e){return void d("error: cannot register WebGL backend:",e)}try{ma("webgl").forEach((e=>{Aa({...e,backendName:V2.name})}))}catch(e){return void d("error: cannot update WebGL backend registration:",e)}const n=Ni().getGPGPUContext?Ni().getGPGPUContext().gl:null;if(!n)return void d("error: no current gl context:",n,V2.gl);d(`humangl webgl version:${n.getParameter(n.VERSION)} renderer:${n.getParameter(n.RENDERER)}`);try{Ke.set("WEBGL_VERSION",2)}catch(e){return void d("error: cannot set WebGL backend flags:",e)}!function(){const e=V2.gl;e&&(V2.extensions=e.getSupportedExtensions())}(),d("backend registered:",V2.name)}}async function G2(e,t=!1){if(e.state="backend",t||HZ.initial||e.config.backend&&e.config.backend.length>0&&ki()!==e.config.backend){const t=h();if(e.config.backend&&e.config.backend.length>0){if("undefined"==typeof window&&"undefined"!=typeof WorkerGlobalScope&&e.config.debug&&e.config.debug&&d("running inside web worker"),HZ.browser&&"tensorflow"===e.config.backend&&(e.config.debug&&d("override: backend set to tensorflow while running in browser"),e.config.backend="humangl"),!HZ.node||"webgl"!==e.config.backend&&"humangl"!==e.config.backend||(e.config.debug&&d(`override: backend set to ${e.config.backend} while running in nodejs`),e.config.backend="tensorflow"),HZ.browser&&"webgpu"===e.config.backend)if("undefined"==typeof navigator||void 0===navigator.gpu)d("override: backend set to webgpu but browser does not support webgpu"),e.config.backend="humangl";else{const t=await navigator.gpu.requestAdapter();if(e.config.debug&&d("enumerated webgpu adapter:",t),t){d("webgpu adapter info:","requestAdapterInfo"in t?await t.requestAdapterInfo():void 0)}else d("override: backend set to webgpu but browser reports no available gpu"),e.config.backend="humangl"}"humangl"===e.config.backend&&await j2(e);const t=Object.keys(fi().registryFactory);if(e.config.debug&&d("available backends:",t),t.includes(e.config.backend)||(d(`error: backend ${e.config.backend} not found in registry`),e.config.backend=HZ.node?"tensorflow":"webgl",e.config.debug&&d(`override: setting backend ${e.config.backend}`)),e.config.debug&&d("setting backend:",e.config.backend),"wasm"===e.config.backend){try{qe().set("CANVAS2D_WILL_READ_FREQUENTLY",!0)}catch(e){}if(e.config.debug&&d("wasm path:",e.config.wasmPath),void 0===(null==A?void 0:A.setWasmPaths))throw new Error("backend error: attempting to use wasm backend but wasm path is not set");await LG(e.config.wasmPath,e.config.wasmPlatformFetch);const t=await qe().getAsync("WASM_HAS_SIMD_SUPPORT"),n=await qe().getAsync("WASM_HAS_MULTITHREAD_SUPPORT");e.config.debug&&d(`wasm execution: ${t?"SIMD":"no SIMD"} ${n?"multithreaded":"singlethreaded"}`),e.config.debug&&!t&&d("warning: wasm simd support is not enabled")}try{await vi(e.config.backend),await wi(),YY.tf255=fc(255,"float32"),YY.tf1=fc(1,"float32"),YY.tf2=fc(2,"float32"),YY.tf05=fc(.5,"float32"),YY.tf127=fc(127.5,"float32"),YY.rgb=yh([.2989,.587,.114],"float32")}catch(t){return d("error: cannot set backend:",e.config.backend,t),!1}}if("humangl"===ki()&&(Ke.set("CHECK_COMPUTATION_FOR_ERRORS",!1),Ke.set("WEBGL_CPU_FORWARD",!0),Ke.set("WEBGL_USE_SHAPES_UNIFORMS",!0),Ke.set("CPU_HANDOFF_SIZE_THRESHOLD",256),void 0!==e.config.deallocate&&e.config.deallocate&&(d("changing webgl: WEBGL_DELETE_TEXTURE_THRESHOLD:",!0),Ke.set("WEBGL_DELETE_TEXTURE_THRESHOLD",0)),Ni().getGPGPUContext)){const t=await Ni().getGPGPUContext().gl;e.config.debug&&d(`gl version:${t.getParameter(t.VERSION)} renderer:${t.getParameter(t.RENDERER)}`)}ki(),ui(),await wi(),e.performance.initBackend=Math.trunc(h()-t),e.config.backend=ki(),await HZ.updateBackend(),function(){HZ.kernels.includes("mod")||(Aa({kernelName:"Mod",backendName:ki(),kernelFunc:e=>gi((()=>Zc(e.inputs.a,zl(Dl(e.inputs.a,e.inputs.b),e.inputs.b))))}),HZ.kernels.push("mod"));HZ.kernels.includes("floormod")||(Aa({kernelName:"FloorMod",backendName:ki(),kernelFunc:e=>gi((()=>Ol(e.inputs.a/e.inputs.b)*e.inputs.b+Ad(e.inputs.a,e.inputs.b)))}),HZ.kernels.push("floormod"))}()}return!0}function H2(e,t){for(const n of e){Aa({kernelName:n,backendName:t.backend,kernelFunc:()=>{t.debug&&d("kernelFunc",n,t.backend)}})}HZ.kernels=ma(ki()).map((e=>e.kernelName.toLowerCase()))}var q2={};s(q2,{all:()=>y5,body:()=>d5,canvas:()=>g5,face:()=>c5,gesture:()=>f5,hand:()=>h5,object:()=>p5,options:()=>r5,person:()=>A5});var X2=e=>{if(e)if(e.getContext){const t=e.getContext("2d");if(t)return t;d("draw error: cannot get canvas context")}else d("draw error: canvas context not defined");else d("draw error: invalid canvas");return null},K2=e=>Math.round(180*e/Math.PI),Z2=(e,t)=>{if(!t.useDepth||void 0===e)return t.color;const n=Uint8ClampedArray.from([127+2*e,127-2*e,255]);return`rgba(${n[0]}, ${n[1]}, ${n[2]}, ${t.alpha})`};function Y2(e,t,n,r,a){e.fillStyle=Z2(r,a),e.beginPath(),e.arc(t,n,a.pointSize,0,2*Math.PI),e.fill()}function J2(e,t,n,r,a,s){if(e.beginPath(),e.lineWidth=s.lineWidth,s.useCurves){const s=(t+t+r)/2,o=(n+n+a)/2;e.ellipse(s,o,r/2,a/2,0,0,2*Math.PI)}else e.moveTo(t+s.roundRect,n),e.lineTo(t+r-s.roundRect,n),e.quadraticCurveTo(t+r,n,t+r,n+s.roundRect),e.lineTo(t+r,n+a-s.roundRect),e.quadraticCurveTo(t+r,n+a,t+r-s.roundRect,n+a),e.lineTo(t+s.roundRect,n+a),e.quadraticCurveTo(t,n+a,t,n+a-s.roundRect),e.lineTo(t,n+s.roundRect),e.quadraticCurveTo(t,n,t+s.roundRect,n),e.closePath();e.stroke()}function Q2(e,t,n){if(!(t.length<2)){e.beginPath(),e.moveTo(t[0][0],t[0][1]);for(const r of t)e.strokeStyle=Z2(r[2]||0,n),e.lineTo(Math.trunc(r[0]),Math.trunc(r[1]));e.stroke(),n.fillPolygons&&(e.closePath(),e.fill())}}function e5(e,t,n){if(!(t.length<2))if(e.lineWidth=n.lineWidth,!n.useCurves||t.length<=2)Q2(e,t,n);else{e.moveTo(t[0][0],t[0][1]);for(let n=0;n<t.length-2;n++){const r=(t[n][0]+t[n+1][0])/2,a=(t[n][1]+t[n+1][1])/2;e.quadraticCurveTo(t[n][0],t[n][1],r,a)}e.quadraticCurveTo(t[t.length-2][0],t[t.length-2][1],t[t.length-1][0],t[t.length-1][1]),e.stroke(),n.fillPolygons&&(e.closePath(),e.fill())}}function t5(e,t,n,r=5){let a,s,o;e.beginPath(),e.moveTo(t[0],t[1]),e.lineTo(n[0],n[1]),a=Math.atan2(n[1]-t[1],n[0]-t[0]),s=r*Math.cos(a)+n[0],o=r*Math.sin(a)+n[1],e.moveTo(s,o),a+=1/3*(2*Math.PI),s=r*Math.cos(a)+n[0],o=r*Math.sin(a)+n[1],e.lineTo(s,o),a+=1/3*(2*Math.PI),s=r*Math.cos(a)+n[0],o=r*Math.sin(a)+n[1],e.lineTo(s,o),e.closePath(),e.stroke(),e.fill()}var n5,r5={color:"rgba(173, 216, 230, 0.6)",labelColor:"rgba(173, 216, 230, 1)",shadowColor:"black",alpha:.5,font:'small-caps 16px "Segoe UI"',lineHeight:18,lineWidth:4,pointSize:2,roundRect:8,drawPoints:!1,drawLabels:!0,drawBoxes:!0,drawAttention:!0,drawGestures:!0,drawPolygons:!0,drawGaze:!0,fillPolygons:!1,useDepth:!0,useCurves:!1};function a5(e,t){if(n5.drawLabels){const n=[];if(n.push(`face: ${Math.trunc(100*e.score)}%`),e.genderScore&&n.push(`${e.gender||""} ${Math.trunc(100*e.genderScore)}%`),e.age&&n.push(`age: ${e.age||""}`),e.iris&&n.push(`distance: ${e.iris}`),e.real&&n.push(`real: ${Math.trunc(100*e.real)}%`),e.live&&n.push(`live: ${Math.trunc(100*e.live)}%`),e.emotion&&e.emotion.length>0){const t=e.emotion.map((e=>`${Math.trunc(100*e.score)}% ${e.emotion}`));t.length>3&&(t.length=3),n.push(t.join(" "))}e.rotation&&e.rotation.angle&&e.rotation.gaze&&(e.rotation.angle.roll&&n.push(`roll: ${K2(e.rotation.angle.roll)}° yaw:${K2(e.rotation.angle.yaw)}° pitch:${K2(e.rotation.angle.pitch)}°`),e.rotation.gaze.bearing&&n.push(`gaze: ${K2(e.rotation.gaze.bearing)}°`)),0===n.length&&n.push("face"),t.fillStyle=n5.color;for(let r=n.length-1;r>=0;r--){const a=Math.max(e.box[0],0),s=r*n5.lineHeight+e.box[1];n5.shadowColor&&""!==n5.shadowColor&&(t.fillStyle=n5.shadowColor,t.fillText(n[r],a+5,s+16)),t.fillStyle=n5.labelColor,t.fillText(n[r],a+4,s+15)}}}function s5(e,t){var n;if(n5.drawGaze&&(null==(n=e.rotation)?void 0:n.angle)&&"undefined"!=typeof Path2D){t.strokeStyle="pink";const n=e.box[0]+e.box[2]/2-e.box[3]*K2(e.rotation.angle.yaw)/90,r=e.box[1]+e.box[3]/2+e.box[2]*K2(e.rotation.angle.pitch)/90,a=new Path2D(`\n      M ${e.box[0]+e.box[2]/2} ${e.box[1]}\n      C\n        ${n} ${e.box[1]},\n        ${n} ${e.box[1]+e.box[3]},\n        ${e.box[0]+e.box[2]/2} ${e.box[1]+e.box[3]}\n    `),s=new Path2D(`\n      M ${e.box[0]} ${e.box[1]+e.box[3]/2}\n      C \n        ${e.box[0]} ${r},\n        ${e.box[0]+e.box[2]} ${r},\n        ${e.box[0]+e.box[2]} ${e.box[1]+e.box[3]/2}\n    `);t.stroke(s),t.stroke(a)}}function o5(e,t){var n,r,a,s;if(n5.drawGaze&&(null==(r=null==(n=e.rotation)?void 0:n.gaze)?void 0:r.strength)&&(null==(s=null==(a=e.rotation)?void 0:a.gaze)?void 0:s.bearing)&&e.annotations.leftEyeIris&&e.annotations.rightEyeIris&&e.annotations.leftEyeIris[0]&&e.annotations.rightEyeIris[0]){t.strokeStyle="pink",t.fillStyle="pink";const n=[e.annotations.leftEyeIris[0][0]+Math.sin(e.rotation.gaze.bearing)*e.rotation.gaze.strength*e.box[3],e.annotations.leftEyeIris[0][1]+Math.cos(e.rotation.gaze.bearing)*e.rotation.gaze.strength*e.box[2]];t5(t,[e.annotations.leftEyeIris[0][0],e.annotations.leftEyeIris[0][1]],[n[0],n[1]],4);const r=[e.annotations.rightEyeIris[0][0]+Math.sin(e.rotation.gaze.bearing)*e.rotation.gaze.strength*e.box[3],e.annotations.rightEyeIris[0][1]+Math.cos(e.rotation.gaze.bearing)*e.rotation.gaze.strength*e.box[2]];t5(t,[e.annotations.rightEyeIris[0][0],e.annotations.rightEyeIris[0][1]],[r[0],r[1]],4)}}function i5(e,t){if(n5.drawPolygons&&e.mesh.length>=468){t.lineWidth=1;for(let n=0;n<vJ.length/3;n++){Q2(t,[vJ[3*n+0],vJ[3*n+1],vJ[3*n+2]].map((t=>e.mesh[t])),n5)}!function(e,t){if(e.annotations&&e.annotations.leftEyeIris&&e.annotations.leftEyeIris[0]){t.strokeStyle=n5.useDepth?"rgba(255, 200, 255, 0.3)":n5.color,t.beginPath();const n=Math.abs(e.annotations.leftEyeIris[3][0]-e.annotations.leftEyeIris[1][0])/2,r=Math.abs(e.annotations.leftEyeIris[4][1]-e.annotations.leftEyeIris[2][1])/2;t.ellipse(e.annotations.leftEyeIris[0][0],e.annotations.leftEyeIris[0][1],n,r,0,0,2*Math.PI),t.stroke(),n5.fillPolygons&&(t.fillStyle=n5.useDepth?"rgba(255, 255, 200, 0.3)":n5.color,t.fill())}if(e.annotations&&e.annotations.rightEyeIris&&e.annotations.rightEyeIris[0]){t.strokeStyle=n5.useDepth?"rgba(255, 200, 255, 0.3)":n5.color,t.beginPath();const n=Math.abs(e.annotations.rightEyeIris[3][0]-e.annotations.rightEyeIris[1][0])/2,r=Math.abs(e.annotations.rightEyeIris[4][1]-e.annotations.rightEyeIris[2][1])/2;t.ellipse(e.annotations.rightEyeIris[0][0],e.annotations.rightEyeIris[0][1],n,r,0,0,2*Math.PI),t.stroke(),n5.fillPolygons&&(t.fillStyle=n5.useDepth?"rgba(255, 255, 200, 0.3)":n5.color,t.fill())}}(e,t)}}function l5(e,t){if(n5.drawPoints&&e.mesh.length>=468)for(let n=0;n<e.mesh.length;n++)Y2(t,e.mesh[n][0],e.mesh[n][1],e.mesh[n][2],n5),n5.drawAttention&&(s0.includes(n)&&Y2(t,e.mesh[n][0],e.mesh[n][1],e.mesh[n][2]+127,n5),o0.includes(n)&&Y2(t,e.mesh[n][0],e.mesh[n][1],e.mesh[n][2]-127,n5),i0.includes(n)&&Y2(t,e.mesh[n][0],e.mesh[n][1],e.mesh[n][2]-127,n5))}function u5(e,t){n5.drawBoxes&&J2(t,e.box[0],e.box[1],e.box[2],e.box[3],n5)}async function c5(e,t,n){if(n5=f(r5,n),!t||!e)return;const r=X2(e);if(r){r.font=n5.font,r.strokeStyle=n5.color,r.fillStyle=n5.color;for(const e of t)u5(e,r),a5(e,r),e.mesh&&e.mesh.length>0&&(l5(e,r),i5(e,r),s5(e,r),o5(e,r))}}async function d5(e,t,n){var r;const a=f(r5,n);if(!t||!e)return;const s=X2(e);if(s){s.lineJoin="round";for(let e=0;e<t.length;e++){if(s.strokeStyle=a.color,s.fillStyle=a.color,s.lineWidth=a.lineWidth,s.font=a.font,a.drawBoxes&&t[e].box&&4===(null==(r=t[e].box)?void 0:r.length)&&(J2(s,t[e].box[0],t[e].box[1],t[e].box[2],t[e].box[3],a),a.drawLabels&&(a.shadowColor&&""!==a.shadowColor&&(s.fillStyle=a.shadowColor,s.fillText(`body ${100*t[e].score}%`,t[e].box[0]+3,1+t[e].box[1]+a.lineHeight,t[e].box[2])),s.fillStyle=a.labelColor,s.fillText(`body ${100*t[e].score}%`,t[e].box[0]+2,0+t[e].box[1]+a.lineHeight,t[e].box[2]))),a.drawPoints&&t[e].keypoints)for(let n=0;n<t[e].keypoints.length;n++)t[e].keypoints[n].score&&0!==t[e].keypoints[n].score&&(s.fillStyle=Z2(t[e].keypoints[n].position[2],a),Y2(s,t[e].keypoints[n].position[0],t[e].keypoints[n].position[1],0,a));if(a.drawLabels&&t[e].keypoints){s.font=a.font;for(const n of t[e].keypoints)n.score&&0!==n.score&&(s.fillStyle=Z2(n.position[2],a),s.fillText(`${n.part} ${Math.trunc(100*n.score)}%`,n.position[0]+4,n.position[1]+4))}if(a.drawPolygons&&t[e].keypoints&&t[e].annotations)for(const n of Object.values(t[e].annotations))for(const e of n)e5(s,e,a)}}}async function h5(e,t,n){const r=f(r5,n);if(!t||!e)return;const a=X2(e);if(a){a.lineJoin="round",a.font=r.font;for(const e of t){if(r.drawBoxes&&(a.strokeStyle=r.color,a.fillStyle=r.color,J2(a,e.box[0],e.box[1],e.box[2],e.box[3],r),r.drawLabels&&(r.shadowColor&&""!==r.shadowColor&&(a.fillStyle=r.shadowColor,a.fillText(`hand:${Math.trunc(100*e.score)}%`,e.box[0]+3,1+e.box[1]+r.lineHeight,e.box[2])),a.fillStyle=r.labelColor,a.fillText(`hand:${Math.trunc(100*e.score)}%`,e.box[0]+2,0+e.box[1]+r.lineHeight,e.box[2])),a.stroke()),r.drawPoints&&e.keypoints&&e.keypoints.length>0)for(const t of e.keypoints)a.fillStyle=Z2(t[2],r),Y2(a,t[0],t[1],0,r);if(r.drawLabels&&e.annotations){const t=(e,t)=>{if(!e||0===e.length||!e[0])return;const n=e[e.length-1][2]||-256;a.fillStyle=Z2(n,r),a.fillText(t,e[e.length-1][0]+4,e[e.length-1][1]+4)};a.font=r.font,t(e.annotations.index,"index"),t(e.annotations.middle,"middle"),t(e.annotations.ring,"ring"),t(e.annotations.pinky,"pinky"),t(e.annotations.thumb,"thumb"),t(e.annotations.palm,"palm")}if(r.drawPolygons&&e.annotations){const t=e=>{if(e&&0!==e.length&&e[0])for(let t=0;t<e.length;t++){a.beginPath();const n=e[t][2]||0;a.strokeStyle=Z2(t*n,r),a.moveTo(e[t>0?t-1:0][0],e[t>0?t-1:0][1]),a.lineTo(e[t][0],e[t][1]),a.stroke()}};a.lineWidth=r.lineWidth,t(e.annotations.index),t(e.annotations.middle),t(e.annotations.ring),t(e.annotations.pinky),t(e.annotations.thumb)}}}}async function p5(e,t,n){const r=f(r5,n);if(!t||!e)return;const a=X2(e);if(a){a.lineJoin="round",a.font=r.font;for(const e of t)if(r.drawBoxes){if(a.strokeStyle=r.color,a.fillStyle=r.color,J2(a,e.box[0],e.box[1],e.box[2],e.box[3],r),r.drawLabels){const t=`${e.label} ${Math.round(100*e.score)}%`;r.shadowColor&&""!==r.shadowColor&&(a.fillStyle=r.shadowColor,a.fillText(t,e.box[0]+3,1+e.box[1]+r.lineHeight,e.box[2])),a.fillStyle=r.labelColor,a.fillText(t,e.box[0]+2,0+e.box[1]+r.lineHeight,e.box[2])}a.stroke()}}}async function f5(e,t,n){const r=f(r5,n);if(t&&e&&r.drawGestures){const n=X2(e);if(!n)return;n.font=r.font,n.fillStyle=r.color;let a=1;for(let e=0;e<t.length;e++){let s=[],o=[];if([s,o]=Object.entries(t[e]),o.length>1&&o[1].length>0){const e=s[1]>0?`#${s[1]}`:"",t=`${s[0]} ${e}: ${o[1]}`;r.shadowColor&&""!==r.shadowColor&&(n.fillStyle=r.shadowColor,n.fillText(t,8,2+a*r.lineHeight)),n.fillStyle=r.labelColor,n.fillText(t,6,0+a*r.lineHeight),a+=1}}}}var m5=0;async function A5(e,t,n){const r=f(r5,n);if(!t||!e)return;const a=X2(e);if(a){a.lineJoin="round",a.font=r.font;for(let e=0;e<t.length;e++)if(r.drawBoxes){if(a.strokeStyle=r.color,a.fillStyle=r.color,J2(a,t[e].box[0],t[e].box[1],t[e].box[2],t[e].box[3],r),r.drawLabels){const n=`person #${e}`;r.shadowColor&&""!==r.shadowColor&&(a.fillStyle=r.shadowColor,a.fillText(n,t[e].box[0]+3,1+t[e].box[1]+r.lineHeight,t[e].box[2])),a.fillStyle=r.labelColor,a.fillText(n,t[e].box[0]+2,0+t[e].box[1]+r.lineHeight,t[e].box[2])}a.stroke()}}}async function g5(e,t){if(!e||!t)return;const n=X2(t);n&&n.drawImage(e,0,0)}async function y5(e,t,n){if(!(t&&t.performance&&t&&e))return null;const r=h(),a=f(r5,n),s=Promise.all([c5(e,t.face,a),d5(e,t.body,a),h5(e,t.hand,a),p5(e,t.object,a),f5(e,t.gesture,a)]);return m5=HZ.perfadd?m5+Math.round(h()-r):Math.round(h()-r),t.performance.draw=m5,s}var x5=.1;function b5(e,t,n){let r=!1,a=n.length-1;for(let s=0;s<n.length;a=s++)n[s].y>t!=n[a].y>t&&e<(n[a].x-n[s].x)*(t-n[s].y)/(n[a].y-n[s].y)+n[s].x&&(r=!r);return r}async function v5(e){if(!e.tensor)return e.tensor;if(!e.mesh||e.mesh.length<100)return e.tensor;const t=e.tensor.shape[2]||0,n=e.tensor.shape[1]||0,r=await e.tensor.buffer();let a=[];for(const t of AJ.silhouette)a.push({x:(e.mesh[t][0]-e.box[0])/e.box[2],y:(e.mesh[t][1]-e.box[1])/e.box[3]});a=a.map((e=>({x:e.x>.5?e.x+x5:e.x-x5,y:e.y>.5?e.y+x5:e.y-x5})));for(let e=0;e<t;e++)for(let s=0;s<n;s++){b5(e/t,s/t,a)||(r.set(.5*r.get(0,s,e,0),0,s,e,0),r.set(.5*r.get(0,s,e,1),0,s,e,1),r.set(.5*r.get(0,s,e,2),0,s,e,2))}const s=r.toTensor();return yi(r),s}var w5=(e,t)=>{const n=e=>{const t=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);return e[0]/=t,e[1]/=t,e[2]/=t,e},r=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]],a=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],s=e.meshRaw;if(!s||s.length<300)return{angle:{pitch:0,yaw:0,roll:0},matrix:[1,0,0,0,1,0,0,0,1],gaze:{bearing:0,strength:0}};const o=Math.max(e.boxRaw[2]*t[0],e.boxRaw[3]*t[1])/1.5,i=[s[10],s[152],s[234],s[454]].map((e=>[e[0]*t[0]/o,e[1]*t[1]/o,e[2]])),l=n(r(i[1],i[0]));let u=n(r(i[3],i[2]));const c=n(a(u,l));u=a(l,c);const d=[u[0],u[1],u[2],l[0],l[1],l[2],c[0],c[1],c[2]],h=(e=>{const[t,n,r,a,s,o,i,l,u]=e;let c,d,h;return a<1?a>-1?(h=Math.asin(a),d=Math.atan2(-i,t),c=Math.atan2(-o,s)):(h=-Math.PI/2,d=-Math.atan2(l,u),c=0):(h=Math.PI/2,d=Math.atan2(l,u),c=0),isNaN(c)&&(c=0),isNaN(d)&&(d=0),isNaN(h)&&(h=0),{pitch:2*-c,yaw:2*-d,roll:2*-h}})(d),p=478===s.length?(e=>{if(!e.annotations.rightEyeIris||!e.annotations.leftEyeIris)return{bearing:0,strength:0};const t=[0,-.1],n=(e.mesh[33][2]||0)>(e.mesh[263][2]||0),r=n?e.mesh[473]:e.mesh[468],a=n?[(e.mesh[133][0]+e.mesh[33][0])/2,(e.mesh[133][1]+e.mesh[33][1])/2]:[(e.mesh[263][0]+e.mesh[362][0])/2,(e.mesh[263][1]+e.mesh[362][1])/2],s=n?[e.mesh[133][0]-e.mesh[33][0],e.mesh[23][1]-e.mesh[27][1]]:[e.mesh[263][0]-e.mesh[362][0],e.mesh[253][1]-e.mesh[257][1]],o=[(a[0]-r[0])/s[0]-t[0],1*(r[1]-a[1])/s[1]-t[1]];let i=Math.sqrt(o[0]*o[0]+o[1]*o[1]);var l,u;return i=Math.min(i,e.boxRaw[2]/2,e.boxRaw[3]/2),{bearing:(l=[0,0],u=o,(Math.atan2(l[1]-u[1],l[0]-u[0])+Math.PI/2)%Math.PI),strength:i}})(e):{bearing:0,strength:0};return{angle:h,matrix:d,gaze:p}},k5=async(e,t)=>{var n,r,a,s,o,i,l,u,c,p,f,m,A,g,y,x,b,v,w,k,S,I;let C,E,N,T,R,_,M,$,F=h();const O=[];e.state="run:face";const D=await async function(e,t){var n,r,a,s,o,i,l,u,c,p,f;const m=((null==(n=t.face.detector)?void 0:n.skipTime)||0)>h()-u0.timestamp,A=u0.skipped<((null==(r=t.face.detector)?void 0:r.skipFrames)||0);t.skipAllowed&&m&&A&&0!==u0.boxes.length?u0.skipped++:(u0.boxes=await qJ(e,t),u0.timestamp=h(),u0.skipped=0);const g=[],y=[];let x=0;for(let n=0;n<u0.boxes.length;n++){const r=u0.boxes[n];let h,m=0;const A={id:x++,mesh:[],meshRaw:[],box:[0,0,0,0],boxRaw:[0,0,0,0],score:0,boxScore:0,faceScore:0,annotations:{}};if([m,h,A.tensor]=LJ(null==(a=t.face.detector)?void 0:a.rotation,r,e,(null==(s=t.face.mesh)?void 0:s.enabled)?d0:GJ()),null==(o=null==t?void 0:t.filter)?void 0:o.equalization){const e=await DZ(A.tensor);yi(A.tensor),A.tensor=e}if(A.boxScore=Math.round(100*r.confidence)/100,null==(i=t.face.mesh)?void 0:i.enabled)if(c0){const n=c0.execute(A.tensor),a=n.find((e=>1===e.shape[e.shape.length-1])),s=await a.data();if(A.faceScore=Math.round(100*s[0])/100,A.faceScore<((null==(l=t.face.detector)?void 0:l.minConfidence)||1)){if(r.confidence=A.faceScore,null==(u=t.face.mesh)?void 0:u.keepInvalid){A.box=IJ(r,e),A.boxRaw=CJ(r,e),A.score=A.boxScore,A.mesh=r.landmarks.map((e=>[(r.startPoint[0]+r.endPoint[0])/2+(r.endPoint[0]+r.startPoint[0])*e[0]/GJ(),(r.startPoint[1]+r.endPoint[1])/2+(r.endPoint[1]+r.startPoint[1])*e[1]/GJ()])),A.meshRaw=A.mesh.map((t=>[t[0]/(e.shape[2]||1),t[1]/(e.shape[1]||1),(t[2]||0)/d0]));for(const e of Object.keys(yJ))A.annotations[e]=[A.mesh[yJ[e]]]}}else{const a=n.find((e=>1404===e.shape[e.shape.length-1])),s=du(a,[-1,3]);let o=await s.array();yi(s),(null==(c=t.face.attention)?void 0:c.enabled)?o=await l0(o,n):(null==(p=t.face.iris)?void 0:p.enabled)&&(o=await t0(o,A.tensor,t,d0)),A.mesh=PJ(o,r,m,h,d0),A.meshRaw=A.mesh.map((t=>[t[0]/(e.shape[2]||0),t[1]/(e.shape[1]||0),(t[2]||0)/d0]));for(const e of Object.keys(AJ))A.annotations[e]=AJ[e].map((e=>A.mesh[e]));A.score=A.faceScore;const i={...WJ(A.mesh,r),confidence:r.confidence,landmarks:r.landmarks};A.box=IJ(i,e),A.boxRaw=CJ(i,e),y.push(i)}yi(n)}else t.debug&&d("face mesh detection requested, but model is not loaded");else{A.box=IJ(r,e),A.boxRaw=CJ(r,e),A.score=A.boxScore,A.mesh=r.landmarks.map((e=>[(r.startPoint[0]+r.endPoint[0])/2+(r.endPoint[0]+r.startPoint[0])*e[0]/GJ(),(r.startPoint[1]+r.endPoint[1])/2+(r.endPoint[1]+r.startPoint[1])*e[1]/GJ()])),A.meshRaw=A.mesh.map((t=>[t[0]/(e.shape[2]||0),t[1]/(e.shape[1]||0),(t[2]||0)/d0]));for(const e of Object.keys(yJ))A.annotations[e]=[A.mesh[yJ[e]]]}A.score>((null==(f=t.face.detector)?void 0:f.minConfidence)||1)?g.push(A):yi(A.tensor)}return u0.boxes=y,g}(t,e.config);if(e.performance.face=HZ.perfadd?(e.performance.face||0)+Math.trunc(h()-F):Math.trunc(h()-F),!t.shape||4!==t.shape.length)return[];if(!D)return[];for(let z=0;z<D.length;z++){if(e.analyze("Get Face"),!D[z].tensor||D[z].tensor.isDisposedInternal){d("Face object is disposed:",D[z].tensor);continue}if(null==(n=e.config.face.detector)?void 0:n.mask){const e=await v5(D[z]);yi(D[z].tensor),D[z].tensor=e}const P=D[z].mesh&&D[z].mesh.length>200?w5(D[z],[t.shape[2],t.shape[1]]):null;e.analyze("Start Emotion:"),e.config.async?T=(null==(r=e.config.face.emotion)?void 0:r.enabled)?DQ(D[z].tensor||Us([]),e.config,z,D.length):[]:(e.state="run:emotion",F=h(),T=(null==(a=e.config.face.emotion)?void 0:a.enabled)?await DQ(D[z].tensor||Us([]),e.config,z,D.length):[],e.performance.emotion=HZ.perfadd?(e.performance.emotion||0)+Math.trunc(h()-F):Math.trunc(h()-F)),e.analyze("End Emotion:"),e.analyze("Start AntiSpoof:"),e.config.async?_=(null==(s=e.config.face.antispoof)?void 0:s.enabled)?mJ(D[z].tensor||Us([]),e.config,z,D.length):0:(e.state="run:antispoof",F=h(),_=(null==(o=e.config.face.antispoof)?void 0:o.enabled)?await mJ(D[z].tensor||Us([]),e.config,z,D.length):0,e.performance.antispoof=HZ.perfadd?(e.performance.antispoof||0)+Math.trunc(h()-F):Math.trunc(h()-F)),e.analyze("End AntiSpoof:"),e.analyze("Start Liveness:"),e.config.async?M=(null==(i=e.config.face.liveness)?void 0:i.enabled)?H1(D[z].tensor||Us([]),e.config,z,D.length):0:(e.state="run:liveness",F=h(),M=(null==(l=e.config.face.liveness)?void 0:l.enabled)?await H1(D[z].tensor||Us([]),e.config,z,D.length):0,e.performance.liveness=HZ.perfadd?(e.performance.antispoof||0)+Math.trunc(h()-F):Math.trunc(h()-F)),e.analyze("End Liveness:"),e.analyze("Start GEAR:"),e.config.async?E=(null==(u=e.config.face.gear)?void 0:u.enabled)?KY(D[z].tensor||Us([]),e.config,z,D.length):null:(e.state="run:gear",F=h(),E=(null==(c=e.config.face.gear)?void 0:c.enabled)?await KY(D[z].tensor||Us([]),e.config,z,D.length):null,e.performance.gear=Math.trunc(h()-F)),e.analyze("End GEAR:"),e.analyze("Start SSRNet:"),e.config.async?(C=(null==(p=e.config.face.ssrnet)?void 0:p.enabled)?rJ(D[z].tensor||Us([]),e.config,z,D.length):null,N=(null==(f=e.config.face.ssrnet)?void 0:f.enabled)?cJ(D[z].tensor||Us([]),e.config,z,D.length):null):(e.state="run:ssrnet",F=h(),C=(null==(m=e.config.face.ssrnet)?void 0:m.enabled)?await rJ(D[z].tensor||Us([]),e.config,z,D.length):null,N=(null==(A=e.config.face.ssrnet)?void 0:A.enabled)?await cJ(D[z].tensor||Us([]),e.config,z,D.length):null,e.performance.ssrnet=Math.trunc(h()-F)),e.analyze("End SSRNet:"),e.analyze("Start MobileFaceNet:"),e.config.async?R=(null==(g=e.config.face.mobilefacenet)?void 0:g.enabled)?UQ(D[z].tensor||Us([]),e.config,z,D.length):null:(e.state="run:mobilefacenet",F=h(),R=(null==(y=e.config.face.mobilefacenet)?void 0:y.enabled)?await UQ(D[z].tensor||Us([]),e.config,z,D.length):null,e.performance.mobilefacenet=Math.trunc(h()-F)),e.analyze("End MobileFaceNet:"),e.analyze("Start Description:"),e.config.async?$=(null==(x=e.config.face.description)?void 0:x.enabled)?b0(D[z].tensor||Us([]),e.config,z,D.length):null:(e.state="run:description",F=h(),$=(null==(b=e.config.face.description)?void 0:b.enabled)?await b0(D[z].tensor||Us([]),e.config,z,D.length):null,e.performance.description=HZ.perfadd?(e.performance.description||0)+Math.trunc(h()-F):Math.trunc(h()-F)),e.analyze("End Description:"),e.config.async&&([C,N,T,R,$,E,_,M]=await Promise.all([C,N,T,R,$,E,_,M])),e.analyze("Finish Face:"),(null==(v=e.config.face.ssrnet)?void 0:v.enabled)&&C&&N&&($={...$,age:C.age,gender:N.gender,genderScore:N.genderScore}),(null==(w=e.config.face.gear)?void 0:w.enabled)&&E&&($={...$,age:E.age,gender:E.gender,genderScore:E.genderScore,race:E.race}),(null==(k=e.config.face.mobilefacenet)?void 0:k.enabled)&&R&&($.descriptor=R),null==(S=e.config.face.iris)||S.enabled;const L=D[z].annotations&&D[z].annotations.leftEyeIris&&D[z].annotations.leftEyeIris[0]&&D[z].annotations.rightEyeIris&&D[z].annotations.rightEyeIris[0]&&D[z].annotations.leftEyeIris.length>0&&D[z].annotations.rightEyeIris.length>0&&null!==D[z].annotations.leftEyeIris[0]&&null!==D[z].annotations.rightEyeIris[0]?Math.max(Math.abs(D[z].annotations.leftEyeIris[3][0]-D[z].annotations.leftEyeIris[1][0]),Math.abs(D[z].annotations.rightEyeIris[4][1]-D[z].annotations.rightEyeIris[2][1]))/t.shape[2]:0,B=(null==(I=e.config.face.detector)?void 0:I.return)?ph(D[z].tensor):null;yi(D[z].tensor),D[z].tensor&&delete D[z].tensor;const W={...D[z],id:z};(null==$?void 0:$.age)&&(W.age=$.age),(null==$?void 0:$.gender)&&(W.gender=$.gender),(null==$?void 0:$.genderScore)&&(W.genderScore=null==$?void 0:$.genderScore),(null==$?void 0:$.descriptor)&&(W.embedding=null==$?void 0:$.descriptor),(null==$?void 0:$.race)&&(W.race=null==$?void 0:$.race),T&&(W.emotion=T),_&&(W.real=_),M&&(W.live=M),L&&0!==L&&(W.iris=Math.trunc(500/L/11.7)/100),P&&(W.rotation=P),B&&(W.tensor=B),O.push(W),e.analyze("End Face")}return e.analyze("End FaceMesh:"),e.config.async&&(e.performance.face&&delete e.performance.face,e.performance.age&&delete e.performance.age,e.performance.gender&&delete e.performance.gender,e.performance.emotion&&delete e.performance.emotion),O},S5=e=>{if(!e)return[];const t=[];for(let n=0;n<e.length;n++){const r=e[n].keypoints.find((e=>"leftWrist"===e.part)),a=e[n].keypoints.find((e=>"rightWrist"===e.part)),s=e[n].keypoints.find((e=>"nose"===e.part));s&&r&&a&&r.position[1]<s.position[1]&&a.position[1]<s.position[1]?t.push({body:n,gesture:"i give up"}):s&&r&&r.position[1]<s.position[1]?t.push({body:n,gesture:"raise left hand"}):s&&a&&a.position[1]<s.position[1]&&t.push({body:n,gesture:"raise right hand"});const o=e[n].keypoints.find((e=>"leftShoulder"===e.part)),i=e[n].keypoints.find((e=>"rightShoulder"===e.part));o&&i&&Math.abs(o.positionRaw[1]-i.positionRaw[1])>.1&&t.push({body:n,gesture:"leaning "+(o.position[1]>i.position[1]?"left":"right")})}return t},I5=e=>{if(!e)return[];const t=[];for(let n=0;n<e.length;n++)if(e[n].mesh&&e[n].mesh.length>450){const r=(e[n].mesh[33][2]||0)-(e[n].mesh[263][2]||0),a=e[n].mesh[33][0]-e[n].mesh[263][0];Math.abs(r/a)<=.15?t.push({face:n,gesture:"facing center"}):t.push({face:n,gesture:"facing "+(r<0?"left":"right")});Math.abs(e[n].mesh[374][1]-e[n].mesh[386][1])/Math.abs(e[n].mesh[443][1]-e[n].mesh[450][1])<.2&&t.push({face:n,gesture:"blink left eye"});Math.abs(e[n].mesh[145][1]-e[n].mesh[159][1])/Math.abs(e[n].mesh[223][1]-e[n].mesh[230][1])<.2&&t.push({face:n,gesture:"blink right eye"});const s=Math.min(100,500*Math.abs(e[n].mesh[13][1]-e[n].mesh[14][1])/Math.abs(e[n].mesh[10][1]-e[n].mesh[152][1]));s>10&&t.push({face:n,gesture:`mouth ${Math.trunc(s)}% open`});const o=e[n].mesh[152][2]||0;Math.abs(o)>10&&t.push({face:n,gesture:"head "+(o<0?"up":"down")})}return t},C5=e=>{if(!e)return[];const t=[];for(let n=0;n<e.length;n++){if(!(e[n].annotations&&e[n].annotations.leftEyeIris&&e[n].annotations.leftEyeIris[0]&&e[n].annotations.rightEyeIris&&e[n].annotations.rightEyeIris[0]))continue;const r=e[n].annotations.leftEyeIris[3][0]-e[n].annotations.leftEyeIris[1][0],a=e[n].annotations.leftEyeIris[4][1]-e[n].annotations.leftEyeIris[2][1],s=Math.abs(r*a),o=e[n].annotations.rightEyeIris[3][0]-e[n].annotations.rightEyeIris[1][0],i=e[n].annotations.rightEyeIris[4][1]-e[n].annotations.rightEyeIris[2][1],l=Math.abs(o*i);let u=!1;Math.abs(s-l)/Math.max(s,l)<.25&&(u=!0,t.push({iris:n,gesture:"facing center"}));const c=Math.abs(e[n].mesh[263][0]-e[n].annotations.leftEyeIris[0][0])/e[n].box[2],d=Math.abs(e[n].mesh[33][0]-e[n].annotations.rightEyeIris[0][0])/e[n].box[2];(c>.06||d>.06)&&(u=!1),c>d?c>.05&&t.push({iris:n,gesture:"looking right"}):d>.05&&t.push({iris:n,gesture:"looking left"});const h=Math.abs(e[n].mesh[145][1]-e[n].annotations.rightEyeIris[0][1])/e[n].box[3],p=Math.abs(e[n].mesh[374][1]-e[n].annotations.leftEyeIris[0][1])/e[n].box[3];(p<.01||h<.01||p>.022||h>.022)&&(u=!1),(p<.01||h<.01)&&t.push({iris:n,gesture:"looking down"}),(p>.022||h>.022)&&t.push({iris:n,gesture:"looking up"}),u&&t.push({iris:n,gesture:"looking center"})}return t},E5=e=>{if(!e)return[];const t=[];for(let n=0;n<e.length;n++){const r=[];if(e[n].annotations)for(const[t,a]of Object.entries(e[n].annotations))"palmBase"!==t&&Array.isArray(a)&&a[0]&&r.push({name:t.toLowerCase(),position:a[0]});if(r&&r.length>0){const e=r.reduce(((e,t)=>(e.position[2]||0)<(t.position[2]||0)?e:t));t.push({hand:n,gesture:`${e.name} forward`});const a=r.reduce(((e,t)=>e.position[1]<t.position[1]?e:t));t.push({hand:n,gesture:`${a.name} up`})}if(e[n].keypoints){const r=k1(e[n].keypoints);for(const e of r)t.push({hand:n,gesture:e.name})}}return t},N5={face:[],body:[],hand:[],gesture:[],object:[],persons:[],performance:{},timestamp:0,error:null},T5=0;var R5={};function _5(e,t,n={order:2,multiplier:25}){let r=0;for(let a=0;a<e.length;a++){const s=n.order&&2!==n.order?Math.abs(e[a]-t[a]):e[a]-t[a];r+=n.order&&2!==n.order?s**n.order:s*s}return(n.multiplier||20)*r}s(R5,{distance:()=>_5,match:()=>F5,similarity:()=>$5});var M5=(e,t,n,r)=>{if(0===e)return 1;const a=(1-(2===t?Math.sqrt(e):e**(1/t))/100-n)/(r-n);return Math.max(Math.min(a,1),0)};function $5(e,t,n={order:2,multiplier:25,min:.2,max:.8}){const r=_5(e,t,n);return M5(r,n.order||2,n.min||0,n.max||1)}function F5(e,t,n={order:2,multiplier:25,threshold:0,min:.2,max:.8}){if(!Array.isArray(e)||!Array.isArray(t)||e.length<64||0===t.length||e.length!==t[0].length)return{index:-1,distance:Number.POSITIVE_INFINITY,similarity:0};let r=Number.MAX_SAFE_INTEGER,a=-1;for(let s=0;s<t.length;s++){const o=_5(e,t[s],n);if(o<r&&(r=o,a=s),r<(n.threshold||0))break}return{index:a,distance:r,similarity:M5(r,n.order||2,n.min||0,n.max||1)}}var O5,D5,z5,P5,L5="\n/9j/4AAQSkZJRgABAQEAYABgAAD/4QBoRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUA\nAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAARAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQu\nbmV0IDQuMi4xMwAA/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxob\nIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgo\nKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8AAEQgBAAEAAwEhAAIRAQMRAf/E\nAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAE\nEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZH\nSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1\ntre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEB\nAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXET\nIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFla\nY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG\nx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+qaKACigApGOKAML\nXp8xlF5A7V4X8RtYs7PzfNImnx8sa8Kp9z3q2tEgp6angWs62ZZ5CTGoJ6DArGNz5p+UrID6EUrF\nPUlW1EuN0XNW7PQ2L5j3JnoKXN0KijqNP0eYoqXBdgPuuo+ZPeupisWn2Jd4+0r924XgsQOCff3/\nAJ1FzRKxDqGii6m3siiQ8F1XGfXI6YNWLfRbiRQMkcZI9fpTDluT2/h6Qy8gDPbtmtG38JeY480Z\n5zSLUTZg8M28YwYxjAArXtdPt402qgHbpSaLWhma3o0Uqk7Nx9DWLaaVblgPs6qRyds2M/gRSQp9\nzZOni2iWS2hlQ+kjYz9OMGrdjq89vIPPVhj+8M/lQyDq9P1WOYBlMZz1AOD+VdDaTiReOKulK0jO\ntHmi0WDTlr0TyxRVhT8tJjIX+9SUxHXUV553BRQAVBcPhSBTSuxPY86+IGti0s5I7dsORy9fM3i6\n8e8mfDO5P90ZrWWiJicNPpZZtxV/xrW0jQt4DOv6Vk2dEEdTY6BHuB25rpbPSo0QARjP0qTRI17W\nwA/hFaMWmoQMgflQXYsDS142rU9tpqqenfNA7GgtihxkdKuRW6qMY/GkDZY8sY4Ap4hXbyB+VArk\nEtuH4wPyrk/EGkOm+a3jw3suRQLc5i38SX9hJ9nnY+XnBUdPyNdFY6pa3KkkAE9l6f8AfJ/pSJT6\nGhDmI+Zb4ZRycdv6ium0nUhKFydrelTsNnS2829RnrVgV6NKXNG55lWPLIM81Op+WrZkRMfmNNzT\nA7GivPO4KKAEY4XNYWt3vkwPg4OK0giJdjw/xrqhm87Zs8tc7pX5A+leSajf6aHYJ50kn4AZpTep\nrBWRm2Vobm4BXfyehPFdnpmnBFUY5rI2SN63tlToK0YI+KZpFF+3QdavwoKTLtoW0Toaswpk5pCb\nLCxipAhoIuP2dKevHXoaYDylRyxhlwRQI4nxVoCXWZI1GfpXGtbSWjYPGP73+NIGupt6TqMsLruZ\nih4xnP5V09mQ+JLd8gn0xSYJnVaVdkook69K34zuUGunDS3Rx4qOzHVIp4rrOMY3NJQI7GivPO8K\nKAILt9kZrz3xlebYiu8KCCWb0XvW0NFch6ysfO3jLVjfXLIn+pQkKorl7WxNxIPl71g2dUUdpo+l\npBGvHPet23iC8ihFosrxirkHQUFo0IF4FXI1O726CpKLacCrMJoJLYHAPpTwucHpSRJJ5e4AZI9x\nUqpxzVpCuOC8cUpQUMRnXttuB4rjNdsYyeVwfXpmpGmcvcQyafMCFJjPY10eg34BUg4DcZP8jUO4\nHaRq3lLNF+IHet7R7jz7c56rwa2wz9+xhiVeFy/T1PFegeaNPWigDsc0ZrzzvDNIaAM7VpNqdegr\nxL4l6kywyRhseZ19lrdfAZL4jxYg3Fw20d63tJsdrDI5rm3Z3R0R0Mce1eKnQYAplIkWrMJ45oZS\nNO3PHbNXIyfpSGWowSOasxLUiZdjFSqtNEMkUemKlAGKsRJjAppFAiORMjmsTVrNZEO4cfSoZSOD\n1eJ7WXBUzQZ+7nkfSo7e2Ei+ZaMzxntjBX2NSU1Y6/wxqojiEFzkA8KTXYaUoWRyv3W5rSjpNHPX\n+BmpSg8V6J5gUUAdhRXnneFFAGHrTfu5PpXzj8S70/aZtxzztXFbv4DKHxHI+H4GZiz9zxXXW8G3\nGBXMjvLRXAx0oPGPSmMVeOnWrMTYpFI0bcg1fh54xmgovRcD3qxETSIZcRvzp+/BpEkqsBUqsM9K\nq4Em4Gkxk0yRGXrVW6i8yFhkg+tJjRxGsWrxllkUMh9eK5uMz6bcebbnfG33kPcVkay2OntPKuo0\nnhXI67c8qa7Lw3c+adjcEDGK1paSRhVV4s6A0or0jyRRQ1AHX0V553hRQBz+vNtt5z3xXzX8Qbdm\nuic5YnOMdK3l8JnTXvlbwpYl+WySOgrp5YfLOOB9O1c62O7qQkc+9RsKChFPWp4DluOlSykaNruH\nArUgHShFNF2NT1qxGO3NBmyxGcE1N2560CFzjrUysO9JAPDDjFOVuKoQuSRTWouBkazbCa3cd8cV\nwF7IISQccHBzUSWpV9C3o1x5b5GAjdQD1rs9DjC3kckbEhqKfxIzn8LOupRXqnkPccBSkUAzraK8\n87wooA5rxMSI3HqK8B8bQl9Q8sffY5b/AAraXwkUviNrw9pH2W1ViMMRTdRjw4HpWNtDti9TPc4P\nFQs2M5qdyyMHLcfjV63HTAoBGtap0wK0YxigpsuRDtVhVYd6GQydVwwIqdRnqKCR23I5pCMUW6gD\nYNKuetAEise9KTxQBWuFyhrznxNZkXjFeN3I+tTIZg2OqmzmxNF0PO3vXp/g2+hukVl4zyPanTXv\nJmVR+60dpThXpnlPceopWFAbnV0V553hSGgRynjC5FujOey14Ssp1HxNmTnc+a3kvcIpv37HoEYQ\nQmMdVHSsnVbYJF5jVk0dsNzlruVIsl2wKxbjWrVHILjg1CRbZJb+ILHPzyhfStODWLQgFJFYd+el\nUJM27HUIXxhga1Y5lLVLKLkMnoauxnPPrSEx7ShF+Y/n2qrc6xBbhizDAqkK1zJuvG9nbg8ZA681\nly/Ei052RO3uKAsZlx8QGd8xxvt9Aa1NH8dK7AXMcip64zigdkdrZX8F7EJLdwwNXMkrz1qRMRly\nCK4TxmpidWI49felPYSOMmi80NIoOV6qRzXYeA5SskYPfirpfEjGr8LPWVHyD6U4CvQPL3ZItOYc\nUDOoNFeed4Uhpks4H4iE/Z5MeleMeGULeLgjds10S+BGdL+Jc9OSBU2Huc5Nc74yvUtrcDBrJnZF\n63PJdXvLy/lKWw46bvQVz82jXhkLO5Y+9ZlsYthcRnbIjY9R3q3awTRkEM3WmJI6C0ea3dGRsr1x\nXY6TqW9FLHnjrUs0izpLK5DDjofSta3ckH09KRUkZuuTvFGdvPauE1Y3U6Mqbssf/rUxHPTaJPK2\nZmJPbBqzY6DCZh5xJC9s9aBJHU6dpemJjfEmfetJtI0+VPkUr/unFOxdiextHs33W07YHQHk11mk\nXb3KbZ1xIvcd6LEyWho4Nct41sTPYb16ipexCPPZN+wYGCvH1rrPAEJmvkPoc1VL4kZVvgZ6yFwK\ncBXoHkkqinFaVyzo80GuE7WJRQSziPiGdthK5HQV4x4J/wBI8WPIewNdEvgRNL42emO/yj1UHNef\neNpRczbC+I17DvWT2OqJxc0sMK4TCisy41q0hfEkqj8aixdwTXNOlwvmqD9anS9tXH7uVG+hosO4\n/wC0oOhrR0+6G4YNIEzsNEuCxAPNdjZruA4xxUmjINSjURksOlcbqFykbnjFA1sYGoassaknCqO5\nrl7rxhGm7yBnBxuJq0rkSlYpw+NLlsfd5P8AerVsvHEqSBHwPVgcgVpyMyVXU3rXxcHYETAk+hru\n/DWti6ZSTyOKzZqndHaxvvUGq2rQ+dYyqR24qWI8dvbr7LqDxyDAzXpvw6FvIxePGSM06Xxoyr/A\nzviKFHNegeX1J41zUhXioGbuaSuM6wpCaBHG/EcA6HN/exxXjXw2jL67cv8A3Qa6H8CFR+NnoWpO\nI4XI44rxLxrqjQzSEsQM1gdSPM9U1uR1YbmWIdXHf2rmpIb67YS28UrRlsLI3c/jW0VZGUpO5pW1\njfLNOjahawzwReYI5cjzMkDavHJ5/SrVv9uhtPtVxCPLBwzxnlT9KGghLU3tKvvPjHzbl7EGuisJ\nGRxWLOg7nRXJEbDjmvSNK+aFSfSoZr0KutRkphc4NcRrdkVjL9aVio7Hk3iqS8ubhrWzUlsZY9kG\ncZNc5D4aee5MclzJIFTzHAO0MfatqSOWu7bFS1srDUZEis0vIZoUxPvfcC+4/dx2xjr712XiTwXb\nWmlQ6hol3cRhoFd4rlg3zY5wR0GelavQwjq7GD4etdVvSnk2wAB+9v8A8mvcfA2kXiRo0/UdcDis\nZnTTulqeoWqbUAJqWUb42X1FZlnjfjSwlGrr5S/eNdD4RkvLAAQ4yRyaUZcruVKl7TQ9I0G+mnzH\nckFwM8VuIK7ac3KF2eXiKapz5UWYxipNtMyNejNch0jSar3cjR27uoyQCRVRWom9DxTx54gu5fMi\nlbKdMVjfCZPNlv5v9rFbVHpYqjGzbOn8SzFI9o715L4u0r7arYzk+lYdTqSujy7U/C0u4vHk+WwO\nxuh9q3J9dgvbdVukMV1EwbDDgn04rZMwlHoZ+orZ6hfQ3RWVnQYCgZAq+8U0ln5NtBsV2yxYcfgK\nJtW0CnB31LlroVwJ1nQLGDjeP7w+lb0dsFxjrWB0tHS6NuWPJ6A16ToUm63T3Gallr4S7cxiTjrX\nPaxaF7dlVeSMUhxZ5jd+H7qCa4eF3DSE5x3zXN3Wk6jbyeaiFWUY6ZyPStYS5SalPmVipFbX0E4c\nW0alvmPHJrag0rVvEE6LdljGpG2NRtQD+tW5XMI0uU9M8NeFo9PiQhecDIIrtrOMIoG3H4VlJm9t\nC6CB06VPGM1IHLeItGS6uw+ORT7e3jsbQvj7gzUNam0JaWE+HN7NqOqX80n3FO1RXo8YzXdS+BHk\n4z+KyzGPapcU2YIv7qQtiuaxvcaWqG4O6FwfSrS1JbPnrxoxkv7qIfejcitj4V2f2exumI+8+aKn\nxHTT+G5d8Txlm4rjLxMsQwzWT3OiK0Mm6sEkVsAcjFc1d+FEmlGwEDPQVopaEuOpr6f4ZWNAu3tW\nvHpAj5ZQcUFIWaDjGMVUMQ3cVDBmvbhY7QAV2nh+T/R1yeKhlrY31+b61FcQK6nIoJMi401WblRi\nqr6PCw5UYq9y+YgOgWzNkRrx3xWjp+nx2v3FQcelAbmko9anQ4GBUNisPHWr1qMrQhS2K11HvmYV\nhamcxSRZ5xRIqluS/DKAQQXZxyXrvo2FdlL4EeZjH+/ZbjNSZpswLNBrE1Gt7VE4ODVIlnh/j61F\nj4lmeTGyUbq6LwdEqWbeX0YbhSqfEddP4Bddj4JIrhL5d8h7VjI6oLQqKNzelWre3yc4/ClFjaL6\nwqBxxUUxwCKu5BmXRA6c+9ZjP83FSBoQuPs4BrsNBlUW659KmRrDY6G1lyQtW3Hy0lqQ1qVJnAbm\noy3b9KYJCqRj3o4zRctIlhjLHmpSuOBRbQOpLGpPFaES7UqkZzKN1KsEc87/AHUUmvPLTVGv72aQ\nk7WJwKmRrQ3ud74Ltilgz4++2a6iNDXdS0gjyMU71my7GpqTbxSbMki3SViajTTHqkSeR/GeyZmg\nnQHkEE1S+F+oPPavBL96I4/Cia1udVF+4dVrkW+Fq8+v4tjMDWUkdVJ6WM0cNV+F+MVmjUcZgqnP\n1qpNNnkcVRLiZtxIS1UzzIF7mghlxUZpVQdq6nTVdAoAOKzkbQWhvwM6gMM1twOJYx3NOJE11Kt1\nH1/pVVlwBkk+9NocXoOQ45FPj+fkUJFF2NSB700v/hTEty5ZpkjvVyUgcCq6GM9zC14/8Se6GcZQ\n1574Xs5WkI2HBPHFQ1dm1KSSZ7Rotn9l0+KPHIHNacae1dy0Vjxaj5ptlhVp+2s2CJ9ppCKzuWNx\nzSFc1SYrHNeNdIGpaYw25ZeRXmvheyk0jVpEdcLJ0q3ZxNKTa0O3vQHg/DNcHrsJDmsmjspnNzNt\nfFIJ24GazOhC+azDmgZIOOKBsp3J2qSaZodubq58yQ4QAnmhGT3NO18pb7BORmu205LfYpyKVkWp\nOxr5gKYWoIZWgfGfloFq1qTPLubnGO1RPtxg4P0oBAkY/hBz6VNDDkZ6AU0W2WSdqkdKr9ZOaGSj\nVtcLHmnOcgmmYvcz7mBLy3MbdD1q9ouiRK6bUAVeelOC1InPlidSsWMDFOCEdq3uefykqrinYqGy\nrFvApMVka2DAowKAsMkRXQqwyDXn/iWyitNQ3qPl6itIvRoF8RXinW4tQ6HI6GuW8SIVBPalc6qe\n5x9x97r3qruwTjrWZ0ksZ9TUmcDNAmZ9/wAoao63rR0+w22MLPtAzt6mghmfofiB76LdJBJBIp5D\nd/oa7bSdWLIPnpDi9TM8TeKdas51XTbIyxd3J/pXS+E/EFxqNoFu7do5OmD60maHWrnZyDRkn/69\nMlEyOR0xntVoNx+FUgYjPxg4FLCuWDZyKQr2RoRnP0qO+nEFpJITgAUzLqZnhu6+0rknOTXpOmwJ\nFbrt5yMmnHYyr6Oxb2ijaKLnPYMClwKQWK3n0hn+lachHOJ9pNNN0apQFzsY10a4v4hXQh0xpieQ\nMA1XLZNjhK80cT8OdV+3Wl3A7ZZJCw+hrR1qLcjZ/CsbnfHRnFXseHJArOYYbrUs1uPhYbuatqFP\nByfSkMq3UIINYkto+87Tx6GkSxfsDbflGD7CtTw/pk4nzITtPIFMFudsukh4Rxz71paTpKwP5jcn\n0qTRy0NORMDgVCqewoJTJgAoxjntTiTu7fWmFxAcnn1q3EPl+X8KZMi4gKqB1Peob/Tv7Us5bfeU\nyOoq4R5nYxqT5I8xieH9J1DTbvyJELRg8ODwa9Ms5mSFV9BWiptbnNVrKdmif7Q1KLg96XIZc5Is\npNL5pqeUrmMtZs0jzV08phchaY00zH1p2ZNxjS1g+LdJOt6U9ssmxjyGp2urDjLlaZzng/wUPDqz\nTSTmWeTrjpVjVk3Rvjr2rnqQ5dDvo1XUd2cTqSNk9OKxXGCeKxZ1DAxHTr2q5C/y8GokUhsz54qu\nuCxzSQjQ0+FZblR2ro4bZYiMVQ0dBb7Qi5x0qzuG5QOh71LYErDufpSeWrHnimIXbjkUjLkH1Hem\ngGxryc+tXI19KYmWegq9YLiLJ7mtqS945cS7QsWehqxA9dEjz4krPSxyZqbFFhGxUm6smjRM55Lk\nHvSvNxXTY57kLT+9MNwKdhXGm5FIbkU7Bca1wMEVhaiuQcVhXWiZ14R6tHGanGBI2OtYkqEHjgVy\ns9ErEeo6UBsHipKEZs5qpPdRxcbhx70NCSuybTNWihc5brW9Fq6vjMnFSdEIdDRi8RRKygZbHFbu\nm6nb3RA3gMegNJhOm0jbXGOoxTuCc1Rz3FyoGKawz9KaAVcZqeMgCmIkB4FaUTbYwB6V00Fuzixb\n0SFMuDU8Mlbs4UPeXHeiOXkUrDuXYnyKk3cVk0ap6HMxxketSMhrcwRC0dMMZFMQ3yzSeVQAeUaz\n9Vj8uPd271nVV4m+GdpnHX67pCeKyLtBtNcR6xlk9RVeWTb3qRnO6trgttyIfm71z7ai8j7/AJmN\nDNqUVa5Yi1AnjynHuBV+11YJhWWXcP8AZNSzqgmaEerSsf3NtIQP4mGKtRavdRgMIpVI9KjU0a7n\nR6T43uYQI7qN2Tpkqciu503VVuQGAYZHQjFVc4alPlZrpKGAznpTwxOc9+lWjIlUACnM4XApiLNk\nnmvnsK0NvpXZRVonmYqV52GsmanhXitTmFkSiJTSAvwrxUxXIrJ7miOfjf1pzNWxkRlqYWpgJupu\n6gQbuahvIxPA6eo4pNXVioS5WmefakGhndH4INZs5DJXA10PaTurmLO21uKpSZqGMoXGnRzBiyjd\n9Kx5rcQS428fSkjanLoaOliHGZFB56VswW+mtPufcBsGOAfmxz+tFkd8HpoaUx09FAtFY8DO71qb\nSms/Nb7RbecG6AEjFLS5c78t+p0djpVs9wsyQiJAdyr1rW+zqjErzSe559Sbk9S3C+MA1bjbgE1S\nMSXzMVG0vNUI2tPKrAuCMnrVzNd0PhR49W/O2xrHmp4TxVMzQshpIzzQBehqesnuaI5VGzT2bitz\nFEbNTC1ADS1JupgG6l3UAc14s04yR/aYRll+8BXCtLncDXFWjys9TCz5oW7GddH5qqNzWDOgQnC8\nVSuo1kHzAGkPYopEY2+RWxV23Vzj5G/Kg3jWaNazhZuqNXS6TaKhB2c0jR1nJWOlhOxRxU4YkCgx\nY0OQatQyDbyaaFYe8uF4NY3iC9ltbVGj43NTIL3h7WzMihjzXVQXYYDdW9Cf2WcOJpfaRZ3g9KsQ\nmupnCLIabGeaAL0LcVY3cVmzRHIxtUhetzEjZqjLUAIWpN1ArhupwagAfDKQ3Q1594v0c2bm6tx+\n5Y8j+6ayrR5onThp8s7dzkZjuqAAmuBnqC7c0iwgtzSA0rWzjfGRW3ZadDu4AoNYo2rfS4v7orSh\n05UA2r0pDbsTm29KRottBNyJ0wpJ9KhD7f6U0ikNWffIFBz60zVUW52ow4UcUN6EPcx44WsbgOmd\nua7TT5Bd24KHnFKnLlZFSN4koluLdueRWvp14swweG9DXoxldHlTjYtzGoo25qzEvwtUxas2jRPQ\n5CNqkLVsYoYzUzdQA3dSFqBBmnqaBhuqhriCXTpVIzxUz+Fl03aSPI9QTypW2/dz0qKNw3SvOPZR\nMqin8VLKRcs3O4Cuk0w/MDjt1NBtHY6O2IIHY1pxgFaETIRwMkjtVSUEk4570MlFW5bap6dKzWm8\n1tqH8aY+hp2FvGoGayNevVt7/ap4xzUvYjqTLtvLPcvJxSaVcyWsxTnFZlnT2t15xHmCtOBYwQy4\nB9q7cPO+jPPxFO2qLEj5HWo42+aus4HpoX4W4FTF+KlotbHII9SFuK0MUNZqiLUDE3UbqBBupwag\nBc1DefPbyD/ZND2KjujyPWlKzuPesRZjHJXms9lMuw3StjnmphKDSLTJ7OfE3JrpbO4GQc9qlnRA\n3LO82k5NbFvdADkjBoCSHyXIIIzgVQvdRigT7wzjgUzO1jHknlvG7qnp61etYFQDIpCZoqVijzXn\n3iC8EmsOuaCGb/heR/s0ijkVv6fbxy3QMg5xmsnuX0Ldzut3+UYTPWk+2GJSe+M1pFtamcldalmx\n1eO4XaThhWnC+TXqR2PHqL3maUJ4qRjxSEjj42qXdxVmaGs1MJoATfSbqBAG5p6mgAzTJTmNvpQU\ntzzHXY83D/U1zF5FhjgV5r3Pa6FMsV5HWnLe7RhqBRdmTwagN2d2K2rPU1C5LAnPrUs6Iysbdrq6\nf3gK0BrUKj/WClY05iM6xLOcQAj3NT29uznfKSzHuadzNu7NSBFjHNSm5VO9IRnajqoWMhTzXFtA\nbvUfMduSeg702Qz0rS7FbTToQFwzjJqaGTFyfK5PQViyzUuFmuIdgGABya5u/vTaN5cnUHFUmLoZ\nzyskwlgJweSK6zQdUEwVJeGr0aUrxPLxEfe0OrhPAqVjxWhznGRtUwatDK4jNxURbmkAm6jNABup\n6tQAFqhupNtu59qUnZFwV5JHnWsHdIx96w5lz15rzT2uhRmt85xWbcxMnUGmZlB0bdxmrNvFIcfM\n350mWjbs7YkDJY/jW5ZWW4jikWkdNp9mqYJFaJdEHHakUULu/VB1rLn1Ld/FgetMGYd/qWSQmSa0\n/AemS32pfa7piLeLkg9z6UmQtz0W7uQ2cZx0A9BVzR7cAea6j2rPqX0L99KRat5A6Dk1wOoKZ52a\nYfMORTYRLujiGWEq6/NWza2yKQVHNdOHerRy4laJo6TTnbbtb8KuM3Fdh5z3OJjbmpt3FaMxAtUZ\nagBN1GaQBzTwaAAms3VbjERUGsa07RsdeFpuUuY4jUjljWTKK4j02RE4IpJYFk6imQkVl0xWarsO\nmAEcUi0bNnZBR0rWtoguMCkUi21wI161mXuocEKaYXMS4u+pY/hVCSWSY4HT0pEmlouiSahdpEBl\nmOceleiwWcNjClvHgJH97Hc1EmVFFi3Czy7mwIl/WtJbjP7uLgd/apQ2VNVvtsBhiPzdK5S4nAuR\nnqOCaTGi9pcytPlU+XpmumtWII44rah8ZjiNIXRuWeNvvViQ/LXpJWPJbu7nCRvVkNxVsxBmqJmo\nEPiXca0YLMuOlJsuKuPlsSi5IrNuG8s4HWs5VEkbwoOTKsk+FJY4rC1K53k1xTk5O7PSpwVNWRzt\n4cms+WpKICtSLTETQj5q0YeBSGiys23pUguGxQMq3E59ayrm4x3yaAKiRtO2WPHcmhruKFxFajzZ\nScA44qRHoXhuMaLpxaUg6hcDLMf4F9KlhuDeXGASIl+8azZslYma68y48m1+7nFW5rtbRNhb5z1p\niMKbUg0zuW4A4rPgb7VdKXOMmpA7HRbMS7nUYiUda0lkQOBngVrS+JGdbWLRt2bAx5BqeQ/LXpnj\nPQ4GJ+ashuK0MhWaoWcA0AaOmASMK7jRNPWYBmHyiuepO2x10qfcv6vYxCzYqoGK4HVYVTJrmb5l\nc6oaM5TUJ8EgGsG4kLNUHT0M64OaqMMikSRsuKbnFMRLG3zVehOaGNE445NNlnVFpDMu6uie9Vo1\n8z5mOAOST2pDK91cNN+5tsrH3PrW54a06KxT7fdrlh/q1Pc+tJ6IUdZGvHPLezMcnBOWbsPap5r3\nylFtbdT1xUWNWzU0/Zbwlgfmx8zGsHWtRHmMqE59aAMyNifvHPc1f0gtPdqkY5JosJHeNci2tktY\neuPnNY+oXWZEVJNrZ9aun8SIq/CzodHuriIokhDIR1ronbKZr0o6o8ipoz//2Q==",B5="\n/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsICAoIBwsKCQoNDAsNERwSEQ8PESIZGhQcKSQrKigk\nJyctMkA3LTA9MCcnOEw5PUNFSElIKzZPVU5GVEBHSEX/2wBDAQwNDREPESESEiFFLicuRUVFRUVF\nRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUX/wAARCASwBLADASIA\nAhEBAxEB/8QAGwABAAIDAQEAAAAAAAAAAAAAAAEDAgQFBgf/xABDEAEAAgECBAMECQIDBgUFAQAA\nAQIDBBEFEiExE0FRBiJhcRQjMkJSgZGhsWLBJDNyFSVTY3OSNEPR4fAHFjWCokT/xAAYAQEAAwEA\nAAAAAAAAAAAAAAAAAQIDBP/EACARAQEBAQADAQEBAQEBAAAAAAABAhEDITFBEjJRIhP/2gAMAwEA\nAhEDEQA/APqYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAKNTq8OkxzfNkisQC8eb1XtRNbzXT4q7eU2nu0MntRq/D8StMccvW29ZmdvgjsTyvZjxOLj\n+s8WLxn8TFPXs6Oj9oct7c14rkxz22nrB2I49KOdTjelmszfmpMeUxv/AA28OqwZ4icWWtt/SUi4\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmdo3nsPNe0Pt\nFh09Z0+DNWL7+9O/7A3eJcZppsV5raI27esvH6jX5ddM25p79Ilo59VbUZOe2Tm/PeGvfPfT2iKR\nPLv1+DO678XmW/a97U6TtOyzTbTF538/T9WjTNecm9a7126tqk3rSYxY5ta1plRZqZNXGjyZcPXl\nmZmsx+qjBrsuO16xM7eXRt04JrdTltk5OWJnfaWf0a2lty5MdZnfzSn+WOHiOutFpjHa9e8bQ2fp\n+alYy462pk7zXbuxjPesbRS0f6ZZV1ET1tErzXFLHo+A+1ddZf6NrI8PJHa1vN6iJi0bxMTHwfOa\nzhzd61v1846utwniM6DUdb3nBaNrVmd9vjC/ZVePYirBqMWppz4rxaPgtEAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItaK1m09ojcHnvarjM8P0vh49+a/eY8ng9D\nh1fGM1rxjtGPfvbzdbjuTJxHX48cTPNltM/KsS9Dw7S49Jp6UpHaGe2vjz1y9J7LYK13vHWe7bj2\nex1tvM80ekuxW3RnW3Vm6P5jRx8H0+OYmMcb+bapo8GKPdpC6bQwtdHU8JpWkdJ/JweL6e23iU67\nd4dubSqyVi9Zi0bwIs68XGp36TtEq7ZJmZmevzdbifCKWtbJinkt6eTgZPFw32t+sRurbWVzxs1y\nRv6T8V1NZNPtfq0seTm+Kevr+SZuxXjvaPiV8N4viycto9HseG6+uu08W6Rkj7UPmFck1tE1nlmP\nLd3eA8V8HVVi1pjq6Ma/pnqce/ERMTETHaUrKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAADW19+TQ5p/p2bLS4v04Zmt5VjeQeJ4bjnLqsupv+Ka1+ERLv4reTmcNxcuC\nvy3l0qdI2hlr66sT02ot0ZV7qqrInruzrVZLGSZ37JjqgYTG0K5lbaFVhDT1Ub456RPweY4hixWi\neSdpjvD1eWejz3FNHWYtkpvFo9EIseb3tS3SerOms22rfpPqZKzvvHSYUz70TExG6Gdbs2rljeJ/\nMx5L0vEzPaelnOi98c9J2bFNTFpit47+a+PVUvx9T9nOIfT+GV5p3yY/ds67wvsXqpxau+G09Lx+\nr3TqrEAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADV4ljnLw3U0jvO\nO0fs2lWqyUw6XLkyfYrWZkHldBEV09eveG3Fq1mI3jd4vPrOIaid8G9MP3Y38k6fNrt/rMk9Ou8s\ntfXXn49rGWInuy8SO/k5Gl1E3rG/fzbOe94wTy99mbRvTrMOOvNfJWsesywniukrG/jU6fF43WYN\nTmtEeJtEQ06aSmK2+bNtEd+qfSO17unF9Hmvy1y13XWyVmN4tExLxVK8PmNq5NrT58zawam+m/yc\n0Xj8NpRYSvQZ7xEOdqI3rPozxayNRXe0ct/ON03jmrKB5nV4q1yTO20Obmv4c+cx8HoeI6WZpNoj\nq83niYmYscU0r8aJ6T1n49zeJ+Meqm1drb9J+Kd5p136StGVem9l9TbHxLDFp7W7+sS+q1nesT6w\n+PcAzVjiGHftzQ+v4f8AJpv6On8jH9ZgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAABp8VrW/C9TW0ztOO3b5Nxp8VmI4bn37TWYB8f1HFtTfUfR9FWJmsdZ9I7MtJxDX5s\nd8ta1y0xzteaR2277rcuhycP12SceLxMeWNpjttHwlu8I0mfQ1y+D7k5YmJmY36T36Ka43z/AF1t\ncI1ds+qxVj7/AEej19PCw9HJ4NoK4OIU5Y35YmZdzVTGebVZabx5jJS+Tmns81rNLm1Wrzc9rVw4\nYibbem72mXTTS0w0M3BvEta1bWrM95ie5EanY87wXgNOL6XPfxraXLhra/W28bR/dzYzarBqJxRe\nbzE7Rt5vWU9n8mPHOGmS0Ypnea1naJb+k9ncNLR7u2y/WcxXO4TOoyUrN6zD0FaW5Y3hu49FiwUi\nKxCvLMR0hlW0jn6ukWw3iXjOJzbDlneOj3GaN6zDzfFOH+LE7SRGo83XNSZ2lbG2/WfdlvaT2cy6\nrNFInlrv1mfJ37cK4PwTTxOoidRm2+/2/KFuyMp47XB4LivXiunrH2b2iH2qn2K/J8x4fGDNxTSZ\n9Nh8OviRvTyfT6xtWI+DeXs9MNZubypASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAOZx6/LoOWPvWiHTcf2hiZ0e8fc2mf1E5+vP/AEeuSd7RC2uKtI6QjHfeINTfwtPf\nJvty9WPfbt/lucP03gxfJf7d/wBoReYpm97zaNeLb4Ims9Nt94auDjem1Wo5PFi1onylS+1o7l8V\nbxvtupjDMdNkYtXS1+Stt+m63xImEJ4xjHER2ZxMUjeUTO3VRmydBbjLJqPi08mbeVOXJPq1sl5Q\nVbkz9+rRy35rxHqzmZlVEe/Ez5LRlW5iyfR6zffaIjq1OSNZps2a21rZInafSPJhxGMl9LStLRWM\nlorM/A4dkrWbYfLZC2W/7K6eubX6b4RzT+W76K8b7G6X62cu3Sten59nsm3j+OXz3/0ANGIAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0OIYfpOHPijvNNo+fdvtXJO18k/\n/OwPFYbz2ls3jx8VqW6xMdWPEdP9D4lkx/dt79flLLHbkxTPwY6nt2512ORTRzE2x4/dpE7cvkme\nE4IrW3hRMxO8THRtU1FKWtvtvK2upx22rzRCtXkqzh2jtF7ZbT122b01ndnpuWuP3Z3+Ky20qDVv\nfauzVy3mejZzNK8dVjqi87KLRLYtXruqvXzkQp7Qoid88R6rcl+WGlW0/Sa22mfhCZOq2x082ix6\njkm822pO8VrPdr4dNObVeDo8XW3uzMbzK+mvxT7szE27cvnu9j7PcNjSaXx8mOIzZevbrEeic5tN\n+SZnpt8J4fHD9HXHO3PPW0x/DeBtJxx29vaAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAKNRim9Z5e89Nl4DzXtVh5babURHrSf7f3ec1+qnDorWrvvt5Pccb0n0zhmWk\nRvevv1+cPE2rGTFNZU26PFfxwa5dVkjelI2772nZnX6bbrEUq3o0d678u8wmuDL2ittvVjXdneeK\ncGv4jpJ6U56+kS7+j118+GLXpakzHaWlp9NNY3tv+bbiYiNoQy1y30uyZJlrWmZnuym6q1iIJnop\nyW2Te8bdWnnypQqzZOadokiIpSZntWN5lrxki19vNRxrUeBwnNNd+fJEY6/OejXLn3Xe/wDp9wyn\nE8uo4lqqxblv7lJ26T6vpD5X7G8QycKzeBMbzMRM1/FH/wA/h9QwZ6ajDXLitvWzRgsAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeL45w+dDrZvWv1OWd4+E+j2jX\n12jx67TWw5Y6T2nzifU+rZ1y9eHwzDYxxEy18+DJodXfT5o96vafWPVbjyxDn1OOzHudbM0rt2UW\niI69mVtRXZq5tREb9VUoy2iIlRbJ0UX1VZ6btTLrI7V6yk62M2oisT1c7JmtkttVMUyZp6x0beDS\nRWOvdKijDimvWd3G9pNRMfRcNfvZOb9Hpb0itJeP47k/3hgjaZnbaP1XxWW3T0movbNS0W645nbf\n0nrMPpXs3xamoxdJiLbe/X1n8Uf3fKsOTw4jbaXo+EarJhtGTHMxeJ6xH7Sti9Zaj6x3HM4NxXFx\nDS1mtoi8dJrv2l011QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAGjxLhODieOIye7kr9m8d4eM4to9RwjPXFa0ZIvG9bR0fQXmPbDFvTTZPOJmEWS/V8bs9R43NxLL\nG8eFbePg1bajU5/s0l1ceKLx1hbjwRE9mOpx0y2uRTSZsm3PMw2aaKtIjo6kYo9EXpET0hVLXxYK\nxC6MZvyx1lFs0RHfaPiCnU12pLyHGNDbUajBekWma2npWN3p8+opa20e9LSyZLxExTlpM+vdOdcZ\na9tPS8MyUvFrzWlI6727u1pYxYrbVmb7x+TQx6au3Nqcl7/0rcmW9axGnwZJj1novmxnZXV0fFp4\nZxLBPgTGK8xzXr5fOH0bFlpmxVyY7Rato3iYfNuG2x56Wrqa8s2jz+7Lu8O12bS6jkwzN6THNNI6\ntvrN68Y4rxlx1vHa0bskAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAA4XtTTm0OKfTJ/aXdcL2pyRGjwU362yb7fkJz9eTxxyZJjyltRXzUZK7TFtl9Lbwy06YzrHwa+\nfJFd/wCVt8m0bQ0eS2qzcm+1K/an+zNZFL5M1pjFXeI72ky48eGnPkvNp27+TPU6nHpMfLXaIjpE\nerk5dRMxOfN1mPeisfshW1ne1a1577Y6x5R3U0zze31FOWI6ze0byU098kRlzbxM9qrMlPDpyRMR\nMd5Vt/Ihp5898mWZm1pjftE91uCt7fCI7dWeHDEW3t723l6rslqxWZnasR+SYhFbzhnfxJ2jyeq9\nlcGXWZcmW0zWKxHLaI7794eJx5fpfEKabT8t8l5isddo3l9S4VjrwrRUwzSJt3tav3pdOL6Y6dXD\nj8HFWm+/KsU4NRXPvtWazHquWVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAa+fXYNP9u8b+kdZBsDkZOO135cWOZn4y5Wu4xqctbe9y19Kp4njt6vi+PDm8DFMWybbzPlV\n5PiGtz67UxbNbeKTtWIjaIXYpnwuaftT5tXJT3vmi1pMsrU5qIrG1V1a+5DCa7b9GFbRr5J6Wnbt\nCu+Wmk0m8956z8ZWZNorbfzcbX5rZslazPux3hUt41NTntktObJ13+zX1bek01r4/HzVm0bxPXy/\n+bNfDgjVa2uOY92kdfg6ufJOKvLXtttVVSqbcta2vM7zXtHpLQy5ZtMd+vWd+7Zy3mdJHXra3f0c\nvUarw7zFY5rT2hH1Lavnrgx81p3U49Pk4nE5L35MO/StfNRXR5tXnrS8W67WvfyiPSPi7uLHFK1p\njrtSsbR5Lc4RzsXBaYreP4l45esRD2HD9fnw6evvWvO3Tfr0aGk0U55ra0TFInv6uzgrXFXlx0i0\n77RPlC83Yj+JW7oddqr6vHzTTw9/f6dod+L1t9m0T8pcbFSmPHER3892W0zPuz+jSbVvidkcqmfP\nSel7bekrI4n4dZnPWIrHeYnZee2Wpy8dEaml4npNZblw5qzb8M9JbYgAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAABEzFYmZnaI7yCXL1XGa0jJXT0571nbee27DiXEprp8nhbxG20W8\n5cbD0ikfnKO+urTPvjoZdXqctdsmTaPSvRpWmsdZ6yztfaGplvv3lWW1tyRlz1x0vkn7Vo5atTNe\nY0+1o79V2KsZsvX7Ne5mwxnyTNvsx2iGneM/rCdRSuOsTasTt5kRFtpjqmOH4t4nk7estiMNa97R\nHwhna0iuKTEdmGWa4672nZtRele1N59Zlq6vLOSsYorEc07qcW65euzRvtXvPZy52naZ7ujr6fXV\nrWdukREK8+njHgmZmPc67bq6ivVWhxxgxZLztNrT1mZ/SP4VZs0zaOvfp84WUtNsXLvtv3699+rU\nz7+Jtt5qURqMnPpctaR1rMSw4ZoK57eNk6xHaJRh97Ltt7lo5Z+L1HAPZvVauZ2nFTSzMTzeJEz8\nto6xPfvsZntPZ9rXxabmxzefdrv0j1dXh/BcmstW1qxTHHasR3+b0GPhGl+kWmd64dNEVjf73T7X\ny8vy+Ddx6O3iRakxTH5RXrMw1/lX+3Itw2MFIraN48qRHdZi0cUjmmPen9noox1iO0fNzdXEYrTt\nstcmd9aX0bJ+HePmiKTitO8TMLZ1cVjrMfqpz6ys4pjfrPRWZ9rXXptUit6zO+23VyaRHEc05L1/\nw9J9ys/en1ljqdVbwYw452tlnl3jyjzbmmiMeKtYjpEbLeTXPUU8ee/+qjJpsV5rbkrFqzE1tEbT\nDpYNbW21Mnu29fKWna0KbqTdjXXjld0cvQ63ltGHNPSfs2n+HUbS9c2s2UASqAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAOVxPWe99HpP8ArmP4b+r1EabT3yT3iOkesvMVtN7za07zad5l\nXV5GmM9vVfEstvDx0jtaVVMlq+UJ18b5cMRvPeSuK87bUt+i2Z3PtG7zXpjkzXt6R+TXyTMzvM7t\nydHqZ+zhv1+Cv/ZuqvPTHMfOYaTMil1a1K2vHSLTELq2v+KWzThGo84rH5rq8JzedqR+ZeI7WnOS\n34pYTafWXR/2Pln/AMyrKOCWnvmiPyR6O1y9585lhWJvl557Q6eo4T4dYiMvW3b3UanhldHpJtGX\ne09unmjsT7eb1l4trI2t0hsZfrdNO0bzy+nzU20/+NmkzO9esz+TZxWis9dttvPv+Tn21jjaW8zn\n26bTG3mp1M/Wzv3t0jyWXiKZJmsTERaZhXXDbNl8WaztWenxZLstPp5pau8frDtVrNMM5cfTfpMf\n3aunxxbes9d/R09Dp8ebJi09ptFr3jtt2WyrW9wy1Jx132mK+Xq9PotT0iIU19ntLtExa3T47T+q\n6nBaYvsZstZ+cT/LeMnUi0TXffo1s2m8Ws2/OIMWk5Jib5L328rS2t94Sh5TV4ppklpW6PT6rh+P\nNbebTHyas8E081mZy5P2W6OFhjxNTE/hr/LoRO0Kvo9dPqctKzMxEx1la5t3tdnjnMs4noievcrO\nyZjeFF1OSnNV0OG62cn1GWffj7Mz5w05joovzY7xes7TE7w0xrjPeex6Ua+j1UarBFu1o6Wj0lsN\n3JfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrU5o0+nvlt92P3BxuM6nxNRGCs+7Tv8\n2hToxm1r3m9utrTvMsonqyt7XTmcja0u3O6FMfi5t/u0/lzdJM81p9O3zdvHTwsUR5+bfPqOfX1h\ndqV+3O7bs1+T31oqmI3TEM4rvCdkDGIIhlFd2daboS0NXG2bD6bufxXU1vlmu/u4us/N0+L1tTSx\nkr9qk7w89j1FNZMV3jxLzvaJ8mer+LSOZqK2xZotbvljfr/89U453rXt9lse081xZtNjx7TGKu0t\nDHlrevSevaN5Y6+tJ8c7VRNMt63n3ub+6/R54rERMztDYy4a5omclYmfxKcenrjtHLvtPrCnVmdb\neFe3JXmjy6eS/DrMuLVYsta9Mdt++6qLxO+0dEc8UmInr18iUfReHcXrqccb9Z27Q61Lb13eJ9nc\n1Z35rTvE9avY4bTkpG8xEfB05vYxqybc07R281naGMREdoT5JQqy9mply7Q3bV3iXG1eXw7TWSka\nc258t7+tpT5/BjT7MfHqndz12Z+M4lMMKyziUJJiN1WSu9fku23RaOgKNJqbaTU1t9yelo+D0cTE\nxEx1iXmM1Nt3W4PqvFweDaffx9vjDbGvxz+TP66QDRiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAOJxzU73rp6z296zsZMkYsdr2naKxvLyObNOfNfJbvad1dXkaeOdpvsc2yuZVzfbfqybutwu\ns5s8R92J3dvJb3tnO4HSMegtmt3nfZvYp8SZl0z45NfSK7onH1bNcfRFqnUKJr0Y7dVtq7prjEsK\n0XVpEM6028mW20IHK41aPo3J6zs4ODhdcvPnvExFevNXpMOrxi/PlrTee7PLX6Pwa09uaNlKtHg9\ndM3z5d7ReOu02nu0JzZMfblrv5R5uvrcdImZ26T1mYhxs1Os7RH93PZ7axuafNfLitvbaYU3yZYt\nPXs9NwHhui1HBa5LVicsb81onrEuVqNNSuS8Y67dZ6xPZa59Il9uX41vEitImZme3q2Kxbxora0T\nMd/ROSa4Ztkj7c9OafL5LuGYubmyX3iu/TfbdSfVnpvZLT/XZK233+Mbbva1xRXyiPk8pwbH4N6T\nadq5a71n0tD1WDL4tPe6Xr0tDpz8YVnJHWEXYxbqlBedoef4tW0XraO09HdyztSZcbUz43C+ee9b\nSVMaeOfqq7+jGckQ1Yz7+7v2RN/WXPXZPjci2+2yyJaVMuy+uSJlA2d+pNoVRbeDcSxyTE+TDDlt\npdRXLTynrHrDOyiyZeVFnY9TjvXJjres71tG8MnJ4Nqt4tp7T1jrV1nRL1x2cvABKAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAHJ49qfD09cNZ97JPX5PPw2uI6j6Vrsl/ux7tfk1mWr7dOM8iLdm\nvfebREefRsWldw7SxqNbWbR7lPesrn3Vteo7dYjDpMGCvfbeXQ0uLlxRLRxROfUc34p6fCHYrXlr\nEejqrjY8uzCYW7MZjdVKqK9VlaxCYrsnYExBMRMJRPZA8/xPHtmpP9W2xx76vhWOInvt/C7ike7N\nvwzE9kcapGfhlevTaFbFo8RqJ5vy8/RoW09ek0msxHfp3dzNoLzp4zUmZpMbT8HJyYJi20X2n0lh\nZY1li/RaidBF4w2mK3jrHaFGp1lN+tptPp5IjBkid5mIp16TKu0abBPv33vPlM7z+iPdFNcWXU5I\ntkrNce/b1W5db1nTaf3ax9q0fxDW1ebNk2phty1mOu09VOm8W19orEz23j1TwfSeERFuEYMddptW\nd43dvBn21eKJ75KbW+cf/JcTgMxXTb3nbljz+TpcPmc2uyZO1KRtVtGVdi0bx07qJnllsRO6rNTe\nN4XVamsy8mnvPwc3R2jPwe8TPbdlxXNOPSZfhWWpwO85OFzv57qrODkzeHntSe8Sn6Rv0a3EZ218\n8nXekfr1a0ZLVnqx19dWb6demXybOO7lYMvNMdW9S/VVLo0us7tPHdtUtEwJiZU3jq2Jhham8CVG\nPNODNTJXvWd3qcWSubFXJWd4tG8PK3pPd1OB6veLaa89Y61/u2xfxh5c/rsgNHOAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAANLimq+i6O0xPv392rdeZ4rq/pOqnlnelOkIt5F8Z7Wj27I2I6sb25YY\nV1ImY3dbQ08LRc23vZp2j5OJG+XJWle9p2h6HHtbJXFT7OOIpX+7TxT31j5rycdTh+Dpz+XaG/sw\nw18PHWseULN2trBE9UcrJKBhFU7JAQi0dEomegNDUYovM7x3jb5tO1ZvpbaTLtzRExWfWPJ08kbT\nEx5NXWYYyV5omYtHWJieyeDzuizfRs19Jn6TM7Ru1uMcJxZqTkw+5f4ebqa7SV1MR4tdrx2vEfy1\naxqsNOTLjnLXytVXi3Xj8+nmsxTLM16d5npPyUzpekTtSK+U7vS6vQ/SYmK1vWPS1HOn2dvvvvE/\ntDO5XlcO+LbfHSd/W3o6/BdDOXPTnj3Kz38rS6Wm4FNrRyRzTH3p6RH/AKvR8L4dXSzE3jmtHn5I\nmbfqLV+m4dbLSsZInHjr3iI6zLpYaxS01rHuxHRHiT9mv6s67Vj1aqL6326MrWiYa+/Q54BxPaGe\nXRZpj8MquB4+Xg8zPnB7SX30to379GxpK1xcHiKz5IS8xr8PLPixH2bftLTy05o6dHYyVjLhy0t1\nizjZa3pMVv3iO/qz1G2L+NbSajbNyW7xLsY8kTDz+fJXFqKZN4iZnafi6WHL0iYlStI7OO+7axW2\ncrFl7dW9jvE9ULN+J3ZbdFGOy+AYWpEqN7afNXLj+1Wd23KrJVMvCzseh0+auow1yU7WhY4fCdV4\nOadPefcvPuz6S7jol649Tl4AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV581NPhtkvO0R+4NPi2\nr8DB4dJ9+/7Q83Po2NTqLanNbLfvPaPSFDHV66sZ5ET0hRknyW2lTtMyouz0c8usx2n7s7vScKwx\nzc1vu/y85p+maJh6Th+SOWeveXR4/wDLm8v+nX5mUWa9bbrInolmu5jdTNkxYFk2Isr3TuCzeGMz\n+THdEyDDJO9Ja823rt2XWnya946pGvktDXta0ztWu/ybvLE9dkcoOf4GbJPWK1j49VmLh9JtE33v\nMevb9G7WsW8l1ccREISophiJ2jpDYpijbaOjOuOJ8ujOdqxsgVcsUjaETYvbaFFrgu5lVsm0yUtu\nryg43H5m+GIj1XcJzePoL4pnrWGtxmfchr8JvfHS1622if3QljzTTLes+qrNjrkiYtCzPMxnm095\nYZJ6boS5teB49Tqscza97VtvWvlv8V/FOF34RrIxTM2xXjelp/eHoeA6XnzReY3ivX/0dfivDcfE\n9HbDbaLx1pb0lOs+jO7K8Lis3cN+0NKcd9PmthzV5clJ2mF9J9GHHVL108dm1SznYr/Ft0tuhLb8\nmNohFbMhLWy0mJ3rPXvDvcO1karBG8/WV6Wj+7kWrvDDBlvpdRGSnbzj1hpjX4z8mOx6UYYstc2O\nuSk71tG7Ns5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeXneJ62dVl5KT9VTt8Z9W9xbWclPo+O\nfft9qfSHEU1pv48ftYST23ZTDC/p0YtlVuvVjMbM5+LCZjYGWGdrTPxiHY4ffaf3cjTxz1v6xMS6\nOlty2iXVj/Dk8n+ndrkhnGRo1v8AFdW3RCrZ5uiYsqrboncSu508yjmZRYQt50TfowYTbYGVrKrT\nuTZjvukQnYhMIGVY2ZxPVWyrHVCWzXpVXkt3TE7Va+W4K7X3jv1auTNy3jdba0RZpamfroQN7Hk3\n6wr1GTaN2OOJiu6Mu98NvgDi8Wy74d/yZ8PiPAiO2zU4nb6qIn1bugjfFE/ASp1ke9u15mbbRDZ1\nMb823kx0Ontn1OOkedoJCvT8I03gaKsz9q/WW+isRWsVjtHRKyrhe0XCfpWL6Vgr9fjjrEfeh5fF\nfeH0V5Dj3DPoOo+k4a/U5J6xH3ZZ7z3228evytOk7NvFbo0cdols47bSybt7HbddHVqUs2aW3Qnq\nxVeu8LILR3SlZw3V/R8nhXn6u0/pLuPMXjeHT4Zruf6jLPvR9mZ8/g1xrvpz+TH7HUAaMAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAABRq9VXSYJyW79qx6yvmdo3l5viGs+maqYrO+OnSvx+KLeLZz2te1rZL2v\ned7WneZYWnZl5K72YV1xEyxmeqJljzIEWlVkszvbZp5soN3h2SJz3pP3odCnuWmPRxuERfJrZmtZ\nmtY96fR28kbX3dXj/wAuTyf6bmK+9YX1s0cNtm3Sd4LFY2K23W1s16StiUJW7bp22RW3RluBuruz\nmWEgrmCGWyNkoExKE1QlPmsqRDKeyBjaejWy2W3ttDUyz1QKslvehVqKTNosyyTvELabXptIJpaP\nB39Ia2mz+JGpr51jdZefDx2hzuHZObNq58poJaGtjxJ2+LoaKP8ADRPo5+T3skx5OhpOmC0fBNQ0\n5yTbn+bt8A0u9raiY6RHLVwY62mI6zMvaaHBGn0mPHt1iN5+aYVsACBXqMFNTgviyxvW0bSsAeE1\nmkvw7V2w5Ote9besJx2er4rw2nEdNNekZa9aW9JeQjnxZLYskTW9Z2mJY7zz26fHrrdpbZsY7NGt\nmxjvso1b9NmUwpx33XRO4K7VUTE1nmrvEx1bVo2VWiJE/XY4frY1WPlt0y17x6/FuPM0m+HJGTHO\n1qu9pNVXVYt46Xj7VfRtnXXL5MfzexsALsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHM4jxOMFJphmJv529Dq\nZLfjDjPEIx450+K3v2+1MeUOHSOWFc3nJkmZnf4yujpVlqunOeFpV2nctLCZUXRM7MJtsWlRkv3Q\nky5NmpWt9RnrixVm17TtEQnJabXisRMzPSIew9n+CRoccajURvqLx5/chfOest642OGcIpoOG2w7\nROW9d72+LQvXevyejcPUU5M+SvpLeOataraw2a0dLbLqTtK1G3Es4lVWWUSoldFtmcXUbpidgXzK\nGEW3TuCUSncnsDFMMLSms9EC6J6FpVzbZE5ALy0809ZbFr9GtfrEoFMzuuwz0Ueey3HbaBLDXe7i\ntMOfwWnP9I+NZbuttvhs1uBRtXPb4SDm3iIvf57N7Dbl0VrS5+XrltEd+Z1Jx7cNms9N4TURRw3T\n+PrcO3WszEvZOD7P6aYiMlvu16S7y1QAIAABxOPcLnUY/pWCv1tI96I+9DtgmXl68Biy7/NtUu3+\nO8HnFa2s0tfd75KR5fFyMWTdhrPHVnX9R0cd21S3Rzsdm1iuqs256wrmGcT0RYSx5d047X02SMmO\nesd49YRE9WcdSXhZ2O1p89NRji9J+cei1xMc3wXi+KZj1j1dTTaqmor06WjvWW+ddcu8XK8BZmAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAMMmWmKu952UZ9XFZmuP3revlDTtzWnmvO8q3XGmfHb9ZanV3yxtWeWn7y4es\nvPNtDqZJ6Ts5mppvdl/XXRMyfGvSNlu/RVvtOzLfoipLT1VTKbSpvfogRkvtDVyZOhkyvQcA4Dzz\nXV6yvTvTHMfvK+c9U3rkW+zvA/D21urr789cdZ8vi9KDb45rejl8Rry6iJ/FV1HP4vXbBTJEfYt1\n+UpiHM295bXsqrO9l8QkZ0lZEqqLeyBZHZLGvZkhIndADKJ3TMoqWQMZ6pjsxll2jsCLSrmU2lFY\n36gieyu0LJk3jbsga0wdqzK20QpyztQGprL/AFMrOE05NLkt6qdVWZxNrSe5o9vWBLiUjnzXn0vL\nq555dHt8HOwV928/1z/LpzXxbYccRvzTB+jucOwxh0dI22mY3ltIrHLWIjyjZKyoAAAAACJiJjaY\n3iXleM8InR5J1GniZw2n3oj7s/8Ao9Wi9a3rNbRE1mNpifNFnVs65XhcWTdt47bnFuF24dm8TFEz\np7T0/pn0a+HJux1OOrOux08d1ndqY7tillVkzExLOk7yd4YxGwluViJhE45raL0na0dtlWO0+bZr\n1TKi+2zptZGTamT3b/tLacvJjiY3XaTWdYxZZ6/dtPm1zrv1z78fPcbwC7EAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhkyV\nxUm152iAZWtFazNp2iGhm1Vss8uP3aevnKrNntqLdelI7VRHRnrX/HRjx/tZREVjZXeybW6KbWZt\npCZ6S08tN7Nmbb7zCrJtyoS5145bSx5mWafelr3tsKmS/o08uXyhlly7RPV2+AcBnPNdZrK+53pS\nfP4ytnPVda4y4BwHxOXV6uvu96Unz+MvVxG0bQRG0bR2G0nHLb2gCUDX12LxtFmpHeazt82wT1gH\nmMN4tWs+rcr2aEV8DU5sM/cvO3yb+O0csLUTSdrLphRE8tlkZI7Atr2ZMazDJVKTYSCawi7Ksq7z\n1QERvLK3ZGPrKbyCrbdnMcsbeaa18/RhvvM7oGEwTG0JmYYTIML22a2e28xELM19oURPNO4lOem+\nn3ZY5+prVnMc2GYU4/L4A0a15cNf6rz/AC6fC6+NxCPOuOu/5tHJTbHj+F5/l1+BYumXJMd9o3/d\nMRXYASgAAAAAAABhlxUz4rY8lYtS0bTEvH8R4ffhmo6bzhtPu29Pg9mq1Gnx6rDbFmrzVsizq2df\nzXkMWTeIbNL7tbXaHLwzUctvexWn3bmPL8WFnHVL326VZ91MfFVjvvVlz79kLrcf2m7j7bNHH3bl\nJ2SirLQoy4t1++7G0dBC/RanxI8PJPv18/WG241+alovSdrV6w6mDNGfFF4/OPSW2b1zeTPL1aAs\nzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAVZ9RXBTe3WZ7R6iZOpzZq4ac1p+UermZMl89+a/byj0Ra9815ted59PQ32hlrXXRjH\nDpCLX6ML5NlNsm/ZRqstfdXzbsZt06sLZNvNB1Za8RDWyZdo7q8udq5Mu/mIMt4md2lmy7JzZuWJ\ndHgfBL8RvGo1MTXTxPSPx/8AstJ1XWpIs4BwSdbeNVqq/URPu0n73/s9hEREbRG0QUpWlYrWIisR\ntER5JbSccur2gCUAAAAPM8Sry8Uyz67fwuxbzVPGsE49XGbvF42V4M0TEL33ERnktsxpk3sumK2j\nadmFdPFZ33VS2Mdui2J3UU6LYlFSsN2O5NkCyJ6K7T1TEsbAsxdpReerKkTFGMxvYEz0rsqtbbpC\nb2VT1QEzuwtbaGUxspuJU3neWdKoiu8rq12gCI92YatLcublnzbEz1aOptyZqTuDHLfxN6R0+t5X\nqdJhjBp6UiPLeXl9NSMnEKxHa1+bb8nrlvxUAAAAAAAAAAABTqtNj1eC2LLXeto/R43VabJw/VTh\nydY+7b1h7ho8V4dXiGlmvbJXrS3xRZ1fGv5rzeHN02bEW3cys3xZJx5ImtqztMS3MeTeGFjqlb2O\n8btql3NpbZtYsnSBLeiWfdTjtutid+ghherHS5p0+f3vsX6T8Fkw181d4lMvEWdnHaGnw/UeNh5L\nT7+PpPxbjdyWcvAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAo1Oprgr63ntAmTqdRqK4K9etp7Q5d7Wy2m953lNrWyWm953mVd77R0\nZa1104xxlN9lV8qnJl2a9s3xUXX2ybsJyRDWtl3YWydEC+2VRkzeW6q+T4tbJm+KRdfK1cmWZnlr\nvNp7RC/R6HU8SycmCk7ed57Q9ZwvgOn4fEXtHi5/O9o7fJaZ6z1uRyOEezVstq6jiEbV71xevzer\nrWtKxWsRFY6REeSRrJxz22gCUAAAAAANbX6aNVpL0npMRvWfSXlKamsRMVvXm+EvZXjmpaPWHzfL\noNRjzXicfWJ8phfPxFejx72x7xMzK+sXiNoiXlq+Pi6fWV/VfTNqfLJl/WTg9Pji8R70LqvMV1Gq\nj/zcv6yz+lanzzZP1lWpelTET6S81Gp1P/Gyf90s412rjtnyfqql6asREdWM9+jz9eJ6yP8Az7uh\nodZqMt458tpB1JvEViI3/RhzRt13/R1MNaziiZiJn5K9ZNceKZiIiQcu/WekT+iYrWI3lzdTrs+8\n8uW0fJzcur1Np/zsn6g79phVaIeetqNR/wAXJ/3SwnUaj/i5P+6UD0ldonum161h5mNRqP8Ai5P1\nlNtRqJjacuT9Qd22WN5aGeZyZd/KHJy59RHbLf8AVq31Gp/4uT9ZEvS8Lr/vSs2npzRtL1z53wK+\noza/HW2XJNd99pmX0Rb8VAAAAAAAAAAAAAAcHj/C5yV+l4I9+v24jzj1cLFk8nu5jeNpeW41wmdL\nknU6ev1Vp96sfdn/ANFdTrXG+eq1q5F2LLtbZoY8m8d11bbSydErsYsm+zZrO/zcnBm226uhiyRK\nEtrvCrJDOJTeu8A1MWX6Lqq5N/dnpb5O5ExMbx2cPNTeJb/DM/iYPDtPvY+nzhri/jDy5/W6AuwA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAa2p1UYo5adbz+xbxMlvqJ1OqjDHLXree0ejmzNrWm953tPmTPWbWneZ7yoy5YhjrXXTjH8s75N\nmtkyxt0VZM2/m175N1V03yTKubMLXVXybeYLLX2VXy7eam+b0bOg4VquJW+rry4/O9uyZOq3UjVm\n9r25axMzPaIdvhns1kzbZddM0p5Y47z8/R2+HcF03Doi1a8+Xzvbv+TotJnjDXkt+K8ODHp8cY8N\nIpSO0RCwF2YAAAAAAAAACvUZYw6fJkntWN3k8dfHz2vLucdz8mkjFE9bz1+UOZosX1UzPm0nqI/W\nMYo9FlcPNklfFGeH/NshLGun+Cz6PtHZtVZWlRLS+jxPkRpIn7rdoupHTdA5s6SI+7H6Mfo+32Y2\n+To3neSIiZ7A0IjPXpXLePlMotGW3272t85datKzHZjbTVnsDj+FG/2Y/RlGP4R+jo20u7H6N1Ql\no+H8I/REY957R+jpfReiK6eOYHLtj2tttH6KrY/6Y/R2c+kjeJiFVtLG24hxpw7/AHY/RRkw9O37\nO99Hrt1YX0tfOBLjcGp4XF8c+u8fs9c4dcVcGemSI61nd3IneN1orQAAAAAAAAAAAAABFqxes1tE\nTE9JiUgPKcX4RbRXnNgiZwWnrH4XPi28PdXpW9JraImsxtMS8pxXhF9DecuGJtgmf+1TWW2N/la1\nL7N7T5e3Vy6W3hsYcvLbqzbO9jvvCzvDR0+XeO7crO6FmGSvRThy/RtVXJ92elvk2rRvDUzU7pl4\nizsd2J3jeBpcNz+Lg5LT7+Pp+Xk3W7js5eAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs0NTrN96Yp6edkW8Wzm6+LNTq4pvTHO9vOfRoWtt\n1mes95YWvs1s2fZldddOczLPLn2ju0MmebT3YZc2/mpm3qqllN1drsbZIhr3yzvtHf4AsvlYYseb\nV5Yx4KTe0+UQ6nDvZ3UazbJqd8OKeu33peq0eh0+hxcmnxxWPOfOfm0mP+steT/ji8N9mKY9suum\nL37+HHaPm9DSlaVitKxWsdohI0Y22gAgAAAAAAAAAABXnyRhw3yT92Nwef4xm8bVzET0rPJH5d12\nCvLhho3rN9RWs9Z23n5y6O21YhrVYbdGOCfrrLPJRpv863zVS6FS09SvZj3lVZZRdPSqmnSWdrIE\nebOkK4ldTsgW1WKqd1oMZhEVZyRAImOjGI6rJ7IiATNd46qL02bHkiaxaoNGY2n4ImPgtyV2n0Vo\nGvlx7x2beiyTk08RPevSVUxux00+Fn2n7N+n5rRFb4AAAAAAAAAAAAAAACLVres1tETWekxKQHlu\nL8InR2nPp43wz3j8P/s5dLveWrFqzW0bxPeJeV4xwmdFec+CJnDM9Y/CrY1xv8qvTZ+WYdbDk5oh\n5zHk283U0eo3jaZZ2N5XYjrCnLSJhOK+8d1kxvCqzSwZvousrb7k9LfJ3nB1OLeJdLhufx9LEWn3\n6e7LXN9Ofy5/W4AuxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAETaKxMzO0Qi9646Ta07RDmZ9VbPbaOlI7Qi3i+c3TPUaqcu9adKfy0722ZXvFa9\nXO1OrjrESxt66ZJmcjPUanlidmhkzTZVfLN5VWvsC2b7R3U3yqrZZtO1esz2h2+F+zWTUcuXXTNM\nfeKR3n5+iZLVbqRzNJo9TxHLyaekz62ntD1fDOA6fQbZL7Zc/wCKY6R8odLBgxabFGPDSKUjyiFj\nSZkYa3aALKAAAAAAAAAAAAAADQ4pl2pTFH3p3n5Q33E12Tn1eSfKscsLZ+orS00eJqbW+Lfnu1tF\nXaJnZsz3WpCfsyp00fWSvmPdVYOmSUDd8kR3InoQosy7JmUX7MdwZ17ro7KKT1XRPRAsrO0rYndr\n79V1ZBaQiJ6JgCSIJASwrO07MpV2nqBlrv1a1o2bf2qtfLXaQUTO0sb05o3jv3ZXhjS20xEphW5h\nyeJjjf7UdJWNKLziyRePsz0lux1SgAQAAAAAAAAAAAAAADG9K5KTS8Rato2mJZAPIcU4ZbQZuekT\nOC3afT4NXFkmlntc2GmoxWx5K71tG0vHa/RX0GpmlutJ61t6wrY2xr8dXS5uesN+tt4ef0eaa223\n2dnHk3juyreM81OaFGiy/RtZET9jJ7s/2bdutd2jqKeic3iNTsd8a2h1H0jTVtP2o6W+bZbOO+gA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABje9cdJt\nadohGTLXFTmvO0fy52bJfU23t0pHaqLeL5xdK9Rnvqb+cUjtCi94xxvK3JetKuHrdZvaa1ljb10y\ncnIs1Wt3naJc++TmVWvMz1YWybfMGdsm3eWek0mo4jm8PT0mfW3lDf4V7P5tdMZdRviwfvZ6/TaX\nDpMMYsFIpWPTzXmf+steT8jn8L4Dp+HxF77Zc/4pjpHydYGjC3oAAAAAAAAAAAAAAAAADG9opS1p\n7RG7zszN6WtPe0zLua+3Joss/wBOzhzG2OsL5+IrY09dsSyYRijbHEMvOChb7KjF0yS2LQ169Mso\nS24noyrPVXWejNVKbTuw3T3REdQWU6LYlVvsyiUDPfqupPRr79VuOQX1lZEqoZxIMksd0gT2VT0l\nbPZVbuCaW8i8bwr32WxbcGnkjaZa9p2ndv5qbw5+aNugLItF6TEtvTX5sMb969HMpfazc0d9stqe\nvVZDdAQAAAAAAAAAAAAAAAADV1+iprtPOO/2u9bektoB4TJTJpNRbHkja1Z6uto8viVht+0HDvpG\nH6Tjj6zHHvbecONw7Ltfkmeqmo6Ma69DXbbZTkr1mGWO3RneOaGbZRoM30fVzSelMnT83aef1FZ7\nx3h1tBqfpGnjmn369LNc3sc3kzy9bQCzIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAa+q1dNNXr7157VhGp1Xh70x+9f9ocy283m1p5rz3mVbrjXHjt91lz\n5c9+fJ1nyjyhdM8lZlOOIiqrUXikd+kMreunnI5XEdX4dZiZcG+XmtNl/F83PeeWWHDOGanieSKY\nq+5H2rz2hMzWd1Iqx1yajJXHhrNrW6REeb1nCPZumn2z62Ivl7xTyr/6uhwzhGn4Zj2xxzZJ+1kn\nvLoNJnjHW7TbbsAszAAAAAAAAAAAAAAAAAAAAaPFrbaSK/itEOXt0rDf4xb/ACa/GZacRvaF58Q2\nIjasQnzPIhCU92tMbZGzHmotG10C6nZkwpPRmipIllEbMIZIE7solgmJBnCyk9VMM6z1BtVllEqK\nz0WRILYlluriWcSDJVbusV27gwInaSWM9ECyZ3hqamnSWxFmOSOaqRx725bNnSZNs9J+OynVY+WZ\nYYr7TE+nVaIr0Ais81Yn1hKAAAAAAAAAAAAAAAAAABExvG09peU4nov9n66L0j6q/WPg9Y1OJaON\nZpL0+9HWs/EWzeVz9PbmrEtnyc3h9reHy26TWdnSr2YX6657ijLXpLX0+onSamL/AHJ6W+Tbv2aW\nekTv16JzeI1Ox6KJiYiY7Slz+E6jxdN4dp3vj6fl5Og2clnKACAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeQRMxEbzO0Q08uqtkma4ulfO3r8lefUePMxWf\ncjy9WvlzVxV6T1Z61/x0Y8f7Wc7Ur1lqVy+LqOWJ2hp6rXddon5rOF1tfmz5OkT0qzb8dWbxjp1c\nbiuuilJ5Z6r+IcQrixzEy8zl1E6rNt1tMztFY81sztU1eRucN4ffi2p5esRM72n0h7rS6XFo8FcO\nCkVpX082nwXh3+z9FWLxHi36328vg6TZyW9ABAAAAAAAAAAAAAAAAAAAAAADj8Unm1tK/hqppHvw\ny1k8/EMk+m0GOPeafiFpCZYwolnXspvHvLa9mF46gmnZmwozRUiUCBKYYsoBLOFbKAX0llEqqyzi\nQXRLOJVRLOOwLIljZMEgrlhKyYYTAK5nZPN0RZjugUanHzVlz6xtLq361c+9eXItPpXX0dubTU+E\nbL2lw2++O1fSW6m/VYAISAAAAAAAAAAAAAAAAAp1GbwcfTreelYEydcuMcRrM/L9nnlsV6wqpi2r\ntv133mfWVkRyRtEdGFva7MzkYZNoamWN4bV4mYa9qztKIujhVppxGI8r1mJegeZpknBqKZY+7L0t\nLRekWrO8TG8Ns/HJ5ZypAWZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAADS12fp4VJ6z9qVuq1HgUiI+3bpDl589cOKZmevqprXPTbx477rDJlrhr1nq4+s182tMRP\nRqaziXiZJrWekNG17ZbxWJ336M5LXRbI3dLTJrs07RMY6fan1dHLrowY+X7MVjt6N3R6Kul0EbWm\ns7bz8Z+LnabQX43r7Y53php/mXj+Dnv0f1JO1x/8ZxbUzj02O15mfLtD13AvZqnDds+pmMmo26el\nXX0Wh0/D8EYtNjilY7+s/NstpOOTW7QBKgAAAAAAAAAAAAAAAAAAAAAADG88tLW9I3BwJtz6nNf1\nvK/DHVqYJ3pzT5y3MPZeojOWMQylEKpTVjZnDCwkqzYQyRRICATCITAJZQxhMAshnEq4ZQC2srKq\nqrIBZCWNZZgwswmFloVyCu0dFcx1WyrtCBhv5NTPHXds2U5o3hIz4ffbPt+KHUcTSW5c9Jme0u2v\nVYAKpAAAAAAAAAAAAAAAAYZctcVOa35R6tLrltN795/YvknNqrfhpPLH92V5isd9mWq6fHjk6rn0\nZxG8KK5Jm/wbVZiYZtqrmkqL023bkxvCiY3lJHNyRG81mHS4Rn5sNsNp64+3yaWaNrzOzHBl+i6q\nmT7s9J+S+ay8mex6EIneN47SNXKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAImYiJme0JafEs3h6fkidrZOn5eaLeJk7eOdm1Hi2vmtPTry/CHmOJcUvmvOPF1n09Pm\n6HF9ZGm01qxO3R5vSY7XwzmzTy47zzTEd7en5Mfvt2/PURWdo3tvPrPlKymbktFqTtMTvHzbOLDG\nf63JXbFX7FdnoODcDprZpq9TjiMMTvSn4vj8l5fxnrk91saPSa7i2hpOfbTVt5x1m0fLydzR6PDo\ndPGHBXasd585n1lsRERG0dIF5OOe6tAEqgAAAAAAAAAAAAAAAAAAAAAAADX11+TRZrf0y2Gjxe22\ngtH4piP3TPpXKwxtjhuYo9xq442iIblI2pC1RET2ILd9kxCqRjZmwlCSEohIJAQAAJZISDKGUd2M\nMoBnVbVVCyAWVWeSuqyOwIlXZZKue4MJV2WWYT2QKbKL9YlfdRdIo35b7/Hd3KTzUrPrDh27uxpb\nc2mpPwX/ABX9XAKpAAAAAAAAAAAAAACekTIp1eTwtJmv+GkyJn1oafeazbfpMzLR4jq/o8b823zX\n6XNF8ERCvTcNpxLV5LauvPhx9Irv3lhztdtv8TtaWLicXrt03jzjzb2k1nid56ty3s/w+a7Uwzjn\n1raejlarhmbhl/FpbxMO/fzj5p/ixSeXOvTtRfeI280ZI26tfDm3pWe63LaZx7qtGvniJ6tPLvOK\nfOa9WzbJvTbza02jl3n5SSljscK1MajSxWZ96nSW88xw/VfQ9XMT9nfa3yemid43jtLeXsce88qQ\nEqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADia3UTm1l4j7OP3Y/u\n7Vp2rM+kPJW1PhYcmS0+9MzKm/jbwz31weMzbV8UppazPL9q0/BF4rk1GLDSNqxPWPhCnHmnNrtT\nqPKteWPm6U6OdHaZvO+SaRNvhv12Ub/q3FhtrNVj0uKOt56z6R5y9zix1w4qY6RtWsREOJ7L6OKa\nS2rvX6zNM7T6Vh3mmZyOfya7eACzIAAAAAAAAAAAAAAAAAAAAAAAAAAczjVvqMVfW/8AZ03I41bf\nLp6/OVs/UVrY47NyOzUxd4bUJpEbb3Z7IiOrKIVSjZhMLJYyhKIgmGUQSDESIEbJEgQmCITEAmGU\nIiGUAyhZVhDOoM4Wx2VQtqBKuyyWEgqlhKyyuyBVaGtkbNmvk7A15l1eH2300R6TMORPSXT4ZO+O\n8fFefEX63gEAAAAAAAAAAAAAAAq1WPxdLlp+Kkx+y1Fvsz8gjhaDauGK8sx07y3OE3m1tT6RaP4c\nvU6yMNKUx73zT0ilY3l2eF6a+m0kRl/zbzz3+Ez5M8z26fJruW6wzYq5sV8d43raNpZjRzPPaTmx\n5b6bJ9rHO3zb2WJ8GWPEscY9bgzxH2t62n19GWW0eHOzHU5XbjXZ1x8WTnz2iZ7S2M1IjH2+LX0V\nKTqs8zO9ot0j8nUthi1J3UaOFMTfLFo6xMbS9BwHWTqdHOO8+/hnln5eTjYMFo1WTH5VnePzXcIm\n2k4zlpPSmXy/hfF5eMfJns69OA2cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAADG/2LfJ874rW845mubliY7bPoto5qzHrDz0+yePNF41OotaJ7RWNtpV1OtfHqZ715fhu\nj8adNpcVfeyzE2/vLuanhOu1nEctIxTTFa/+ZPbZ3eHcF0vDbTfFE2yzG03t32+DokynXl9+leDB\nTTYKYccbUpWIhYCzEAAAAAAAAAAAAAAAAAAAAAAAAAAAAcXjE/4zDH9M/wAu04XF5/3jj/0f3Wz9\nRUYmzDWxS2I7FSyjuzY1ZKpRKEygEwiWUIkGIk2QJNhKQhMIhkCYZQxhlAMoZwwZwgWQshVCyATL\nCWc9ldpBhZXLOVdpQK7NfJPRdaWvknoDVvPvOnwuel4+TlXn3nS4VPvXj4QtEV0wAAAAAAAAAAAA\nAAAAAVV02CmTxK4qRf8AFFeq0AAAanEsfPpZmO9Ji0NDLfkwdOsulrumiyzHlVzJrz4Ovoy26vB8\ncTBa9NffLtMY77Rv8Yegx5ImkKdJoY1HC81Y+3OSbVn0mGGkmbY45u6tnrrTOu2xGO0RxCd+nNVj\nqKxTV1vH2pjaGtnyzXXYdo96ZmGXEMk15b7/AGZiVerWPTYckZcNbx5wzc7hGbnxXxzPWk7x8pdF\n0S9jh1OXgAlUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAcPjEf4/FP9H93ccXjMf4vDP9Mx+62fqKrx+S+GvibEFSsqyYwlVK\nZYsmIMoRKYJQIPIEiQ2ATCUQygCGUIhMAyhnDCGUIFkLIV1ZxIMpVWWSrsCuyqyyyq09ECq8tfJK\n66jJ2Bp5J6upwn7dv9Lk5J951uE/av8AJaIrqAAAAAAAAAAAAAAAAAAAAAAq1Mc2myxPnWf4cmtu\nXT9fR0tffk0WSe28bfq5Wbamm3326MtunwfK6PCv/AxPraZ/dz9PO97/AOqf5dHhdZrw7Dv3mOb9\nXOxRFM+avpe38mvkPHf/AFWlrKba7Tzt99ZxKkfR7euyNXMTrtPHfa0z+zPiM/UR8Zj+Wbdu8HpN\nM2bfzrV13M4dO2pyR61dNvj44/J/oAWZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADj8bj63BPzdhyeNx0wz8ZWz9RWri7Nmv\nVrYu0NmqaRZHZlDGGSiwxZSgCEkCBCQSCQBMJRCYgEsoYx3Z17AlMIhlCBnDOGEM4AlhZZKq4KrK\n7LLKrIFN2vdfZReAaObu6/CO9vk5OePR1uEd7fJeIrqAIAAAAAAAAAAAAAAAAAAAAGtxCk5NFliI\n3mI32+XVyNTyZOHTee946PQKPoeDffw4777eW/yVs60xv+ZxOnr4Okx1t05KRv8Ao41Z5q3yed5m\nXY1szXRZ5jvFJ/hxItP0aOSN9q7yrtr4f2tHFM5+KT16Yq/vK/iGSbXw4vO14UcPx5MGfNbPG18m\n1oj4THRsTw7VanPXVYpi3gzMcnrvCnG11JOupwuN8+a3pEQ6jT4divjxWnJExa09pbjbM5HHu90A\nJUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAHM41H1GOf6nTc/jEf4Ws+lls/UX45uGekNujTwdm5RNIthKIZKLDFlsiQIShIC\nEgCUJ7AmGTGO7IDzZQhMSDJMMYZQgZwzhhDOATuqssmVdgVWVWWyqtCBTeVF19lF+wNLNG7q8I+9\n8nLyupwnt+S8RXUAQAAAAAAAAAAAAAAAAAAAAAAItWL1mto3iY2lyrcLyUxzix2ia2nvPeK+jrCL\nOrTVnxpanhuPPemSs8l6RtE7dJj0ldpNP9GwRSZ3neZmV4cR/Vs4AJQAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHi1d9H\nM+kt5ra+vPoskfDdOfqK4mn7Q3aNHBPZu0W0RdDOGFWcKLCJZeTGQQlCQSgASBsCYZQxhlAJTAmA\nTsmAgGcM4YQyjsgRLC3VnaVcgwsrt3Z2V2QK7tbJ1bN5a9waeWO7p8Knt8nNyebpcK8vkvlFdQBA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK9RXmwZI+ErEWjesx6wQeZwejeo0cccuW8\nelpblJaaRGxVnCuss4ZrMvJEgCAASISCQIBlCYYpieoM0wx8k7gzIRueYM4Z79FcSy3QEsLJmWFp\nBjaVVpZWlXMoGNmvkXXlr3kGtknu6XCf7OXkl1OEdl8orqgIAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAHmskcmtzV/rls0U62OXiWX4zErcc9GmkRfWVkSqqziWayxCPIANwBIhIJSxS\nCRG6dwZwlhEs4BluMdzfqgZxLLdXuy3AmVdpZTKuZBjaVVpWWV2QlhZRdfZRcGpl7urwfrzfJy8r\nrcH61vPyWitdMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHA4nHLxKZ9awnH2ZcY\njbW459aq8fZpfiI2IZwrqzhmsz3Ebm4JN0AMhCQSIASndiAziWUSriWcAyRujc80DM3RCfIETLCW\nUsZEsJYSslXZAwlTddPZTkBp5e7r8Gj6rJPxhx8k9Xa4PG2C8/FaK10QAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAcfjcbZMFvnDWx9m5x2PqcNvS+zSxT7sNPxH62YZQwqzhRZO6UCB\nKUAJTux3SDIRuAncQAmJZRLBMSgZ7iIAZRKd2DICUSlAljLCYWMLIFVukNfI2bNbIDTyT7zu8Ijb\nSz/qcG/2nf4T/wCE/wD2WnxWt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHL9oL\n+Hw2cm28VvEuPptfgyVj6yIn0no7/FtJfW8NzYMe3PaPd39d3iMug1WktNc2C9dvPbeP1aZ9xF+v\nT471tHu2iflK2HkqWmvaZj5Surqc9Ps5bx+alTHqYHm68S1Vf/NmfnC2vGNTXvyT84Ql6A3cSvHM\nsfaxVn5Ssrxyv3sM/lKB1xza8bwT3pePyWV4tpZ+/MfOEjfGrXiGlt2zV/PotrqcN/s5aT/+wLRj\nFontMSlAlKEgndO6IAZQljDIEgeQljLCzOVdkCu/SGrkbF56NPNeKxMzMRHxENe0+89DwuNtHHzl\n5PJr8NcnLW3Pbf7r1nCZm2gpae8zMrz4i/W6AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAETETG0xukB4HVaeMHEtRi26RedvkyjBSfX9W77QYvC4xz7dMlYlrU7M929dWJLFc6aPK0q\n7YLxPS0S22FlP6q38Zac0yR92s/KVc3tHfFf8tpbcsLRvB/dR/8ALLVnU0r9uL1+dZI1mnmdvGpv\n6TOy6ym+Oto2tWJ+cJ/tW+KLK5KW+zes/KU7tG+h01p64qx8Y6NXNo6Y+uPJlp8rLf0rfG7MXtHa\n0x8pZxqs9e2a8f8A7Oj7HaTHn0+f6RWM23LETfr6vRW4PoL99NT8ui7F4+vEdXXtnt+fVbXjGsr/\nAOZE/OsPS29nuH27YrV+VpeV9pdPXhOtw49NG9Mld55+vXcTPd42I47qo7xSfyWV9oM8d8VJ/VxM\nd8l46xWF9cV7en6o/qLfxp2I9ob+eCv/AHMo9op89P8A/wBORGmyT5R+qfo2X8P7n9Q/jTsx7RR5\n6ef+4/8AuHftg/8A6cWcOSO9J/WEbWr3pY7Efzp2Lcfv5YK/9zWy8d1E/ZpSv5Oba1/+Hb9lc+LP\nbFt87I7E/wAabWbiurvEx4nL/pjZzc2bJkn372t85ZXx55/BX85lucC0vPxnTxlnnjm32mOiZqUu\nLJ2p4TwnVavNWaYbRTfre0bQ99pcH0bT0xb78vmtiIiNojaErMwAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAHnfarF7umzRHaZrLjYrdIen9ocPi8JyTt1xzF4eUw23rCm3R4r6bMy\nwt6kdTaWLdjswmNoZontsCm0K5XWjopnuDC0dGpqG5bs08/daKV672MjbSaif6oh6Z5f2LtvptRX\n0tEvUN3Jfo8f7cYve0eX4zV7B5z20xc/C8eSPuZIRficfXlcPaG7ino08HWIbePpLF2NuiyOyrHK\n3fZFSwuovHVfaVF4QK5YWTM9UT0EKry6Ps1Tn4zjn8NZn9nOtLseydObiWW34cf918fWfk+PYANn\nKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq1WKM+ly4p+/WYeBxTNd6zG0xO0\nvobw3FcP0bi2em20Tbmj5Srr418V9sa2Z7qKyzi07MXUylhaU7yjqhLCeiq3ddaFNxFYW7NLNG8t\nzya+WO6Va9J7FW66mvwidnrXiPY3Ny8RyUn71Jj9Ht3RPjk19HK9pMHj8D1ER3rHN+jqqtTjjNps\nuOe16zAifXzfTz7kNyndpYazS9qT0mszDdoxrsi6m8LazMq6zDOsq1ZEyrt1WWlXaUCqyq0rbKbi\nFdp6PReyFd8uqv8ACsfy83aXrPZHHto89/xX2/SP/dpj6y8vx6EBq5gAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAB5n2q03LfDqqx39y39npmlxbS/TOG5se29tuavzgWzeV4mtui2\nO3RRSY2hdVhqO2MvI36iu9lUsrSrvDHn6spnmSiq5jooyV6tq1VV69RC32byTh43h8otMx+r6I+Z\naK/g8TwX7bXh9Mid4iW+fjl8n1ICWb57xLBOm4zqse20Tbmj8+qKdnS9q8PhcTw5tumSm0/OHMxz\n0Za+uzx3sX1t0Zxurr1ZxvspWiZYWZbsbT0QK7KLrZVZJFaqt5vbezNOTg9J/FaZeJns93wCvLwb\nT/GJn92uGHldIBowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADuAPA67F9H4l\nqMW20VvO3yRWW97T4fC4rXJHSMtI/WGhVlue3b473K2KzMML4+62tujG9pnozXaOSOVFMnVbmq1t\ntrJRW5E7wwvUxTvCyY6CHOt7moxz6Wh9PxTzYaT61h8x1MbZK/OH0zTf+Fxf6I/htj45vL9WgLMn\nmvbPFvocGWO9L7fq85p5maw9d7VYvE4JkmPu2if3eW0+PasdFNOnxfF1Y2hlykRsmY+LJ0MZjZXa\neq2eyi8oQTO0KLdZWzPRjWu6VaqtHR73g0bcI0sf0Q8Nkq93wqNuFaWP+XDTDDytwBowAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAef9q8HNpcGaI60vtPyl56k9Iew49j8ThGe\nPwxFv0l4zH2U26fDfTYiyJljvsjf4sm6vJ1hrXjq2MkqLdZEVbgbMx0auGdmzNt6iHN1Ub5af6of\nTdPG2nxx6Vj+HzaaTm1+nx/iyVj930ysbViPRrj45vL9SAuyc7j1efguqj+jd4/T33rD3HEcPj8O\n1GP8WOY/Z4TTT7sKadHhbcsZnaCJ3TPZk6VdrKbTutmP0U2nqgrGOsr8deiuI2X09EqKM1dt3uuG\nf/jdN/06/wAPE546S9rwud+Gaaf+XH8NMMPK2wGjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAABrcRp4nDtRWPPHP8PCYusPoWSvNjtX1iYfPuWaXtX8MzCuvjfw32siu8ptXoxi\n0wy5t4YulReqmazu2skbquURWFInddM7VYRGyL291KFnCcfj8e0le/Lbmn8n0N4b2Ur4nHLWmPsY\n5e5a5+OXyXugBZmiY3iY9Xz7NjnTa3Ph/BeYj5PoTxftFg8Hjk2iOmWkW/Psrr418V5WrWd2faFc\nV2jdnEMXWxntupmN7NiYU27iWML6dVMVnddjgVqMsdHr+CW5uE6f4Rt+7yuSsTDv+zWXn0WTHP3L\n/tK+GHl+O0A1c4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8Dn93W56/wDM\nt/L3z59qp24jn+OS38lnpr4r7ZxHQ2TEstt3PXUrt27K57rr1VT0BjKnJPRbMqMs7QlV2fYvHvrd\nVknyrEfu9m8f7FZI8fVU85iJewbT45NfQBKo817W4eulzxHaZrL0rje09ItwqbfhtBVs3leai8RD\nKLw1sduesL606dWFdsZT1jdhNeq6K9DlhCVUU6s4jZnt1YzAhnM71dH2bycmszY/K1d/0c6OzY4R\nfwuK4p8rTstn6z8k7HrwGzkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHz3\nVxvr80/8y38voTwGpj/F5/8AqT/JfjTx/WVeyY6FPspc9dZPVXaOq2WEwIUTVRmjo2rNfLHRI3vZ\nDJycXtX8dZh7t879nsnhcbwz23tt+r6I2nxyb+gCVBzuPY/E4PqI9K7ui19fTxNBnp60n+Aj5/pJ\n3jZu1aOnnltMNussdfXbm+l3ZM9URHREdZVXTuT1Nk7boQiOkJw28PU47/htEp5eivJPLMTCZ9Vv\nx7mJ3iJ9UqNHk8XR4b+tIXuhxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD\nweqjbWZ4/wCZP8vePCaz/wDIaiP+Zb+UX408f0r9lOxWOifJhXWjfyYWllPRXYQxnrCrJHRd3YZI\n6A1NJecHEsN/S0T+76bE7xE+r5dk93LW3pL6ZpMni6PDf8VIn9m2fjm8s9rgFmQxvHNS0esbMiew\nPnHLyai9fS0w2aNfUTtrs3+uf5bGPqy068fF227KtSsdFlKqNGMV6myyY6sbdIQI8tlOWOi6Jhhk\nj3RD0vA8nicMx9etZmHRcT2Zyb6XNT8N9/2dt0T449T2AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAHhdfG3E9TH9cvdPEcXjk4zqI/q3L8aeP6xr2TsxpLOekMK6mFo6qpXSrm\nOqBixvHSVmzC4OfqK7S9/wAByeLwbTW9K7fo8Fqo6Paeyl+fglI/Da0NcMPK7QC7AAB8313TiOf/\nAKk/y2MHWrX4jG3E9R/1Lfyv0/aFNOrHxuU7LI7MMayGTVlHWUXhNe6Z6wIUsb9d1m20q7dkDpez\nN9tRqKT5xEvRvKez9+Xis1/FSYerb5+OTyf6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAB43j9eXjN/jWJ/Z7J5L2mry8Upb8VIF8f6aGOey2eynHvOy7bowrrYSxZSwQJ2YXZ\n92N4BoanrEvVexmTm4blr+HJ/aHltRHSXofYm/1Wrp5RaJaYY+X49WA0c4AD51xONuKan/qW/lbp\n+0MOLRtxbU/9SU4J7KadWPjep2WQrr2WRPRk1TvsndXMpiRCb9FNu0rbTuqvKBscCjfi9PhWZeue\nV9n434rafTHL1TfPxy+T/QAszAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHmv\navHtfTZfnV6VxPajHzcNrf8ABeJFs/XnMcr4no18c+6vr2YadkY2YM57sEDLyY37Mo7MMnYGlqO0\nvQ+xNfqNVb1tEfs87qZ2rL0/sVX/AHdnt65P7Q0wx8vx6UBo5wAHz/jUbcX1PT78qtO2vaCnJxjP\n8Zif2amnnspp04+OjWejKJ6MKdmcMmyJn4m5ZHzEVPMwtJv0VZLbQDqezcb8RzT6Y/7vUPM+ytZt\nn1OTyiIh6Ztn45N/6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABocbxeLw\nnUR5xXm/Rvq8+OMuDJjntaswEeBxT0bNZ6NatZpNqz3rO0rqsdO3PxlaWEMpY+aqWXkryT0ZT2V3\n7A0dVPuy9f7G124NM/iyT/Z4zWT7sw957MYfB4Fp4/FE2/WWmGHldcBowAAeM9qKcvFeb8VIly9P\n0nq7ntbTbVYL+tJj93CwT76unR4/jo0nozhhTsy3Y1sWljM9Ce7HyQIm3RRlttVbaWrnt0Sh6n2U\nx8vD8mSfv3/h3XN4Bi8Lg2nj8Uc36y6TeOPXugCUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAPD8RxeBxXUU26Tbmj8+quro+02Lw+I4ssdslNvzhzazvDPbq8d7GW7Dfqz2VzG\n0s2qd+iu/Zn5Ksk9BVztX1mI8930zh2LwOHabH+HHWP2fNYp4+vwYvxXiP3fUqxtWIjyjZtj45/L\nfaQFmQADzftfj3w6fJ6WmHmsP23rvaqnNwqLfhvEvIYZ+sV038bo0noy36MK9oZQxrdMyrlnMbMZ\nQKrS1M07zEestq/RRjr4utwY/wAV4j91p9V18fQdJj8LR4ccfdpEfsuREbREJbuMAAAAAAAAAAAA\nBAJAAAAEAJEAJQAJQAJEAJQAJQAJEACUJAQlAJEAJQAJQJAAAEAJEAJBAAAJAABAJEJAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwvanDzaPFmjvjv8A\ntLztJ3h7HjGHx+FainnFeaPnHV4vFbeIU038VbHeGF+kso7Mb9mTdhKnLK3dRm7SIrHhGPxeP6Sv\n9cT/AHfSnz72Zx+J7Q45/BWZ/Z9BbZ+OXyfQBZQABzeP4/E4NqI9Ii36S8Ng/wAx9C4jTxOH6ivr\njn+Hz3B/mQi/GvjdCnWNlsdI2V07LIlg6USrt2ZzZXMoFV+zPhGLxeOaavpbm/RVltEN72Yx+Jxm\nb7dKUmf7L5+s9/HtRA2cqRACRACRACRACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCQQCRACRACRCQBCQBCQB\nACRACRACRACRACL1i9LVntMbPATTwdRkxT3pea/u+gPE8Xx+DxrPHlaYt+qNfGvjvtXXsi0dOrKk\ndEXjZg6VMtbP2bMtXUdpEV0/Y2nNxbNf8OP+727xvsXH+N1U/wBEfy9k3nxyb+gCVQAGOWvNivX1\nrMPnGGOXNNfOJ2fSZ6w+dZKeHxDPX8N7R+6L8a+L63KdoZ7q6zvEMpnowdKJ6ywmWUyqvIKM0vQ+\nx+D6rU55+9aKx+TzWa36vbezmDwODYenW+95/Nphj5L6dQBo5wAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAEiAAAEoA\nAAAAAAAAAAAAAEAkEAkRuAkQbgkQAkQAkQAkQAl5T2nx8nEMOT8dNv0l6pwfarHvpcGWPu32/WCr\nYvK4mOem6b9mGKd4Z3idmFdka0y1c892zfpMtLPaNpEV6D2Kj/Eauf6YeweQ9ieuTVz8K/3evbT4\n5NfQBKoAA8FxCvJxrUx/XMvevD8Zry8fz/Haf2RfjTx/6RSOnRMyypHu9kXjowrqVSrvPRnZVl6V\nkK0775MsUjvadn0nT4ow6bFijtSsVfPuFYvpPGtNTy54mfy6vorXDm8l9pEC7JIgBIgBIgBIgBIg\nBIgBIhIAgBIhIAgBIgBIIBIAAhIAhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAA\nAAAAAAAAABAJQkAEAAAAAAAAAAjc3BIjdG4Mkbo5kcwMjdhzHMDPc3V8xzAs3N1fMjmBZubq+Y5g\nWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmTzAz3N2HMnmBlu5ftFTx\nOEZJ/DMW/d0t2rxKni8N1FPWkiZ9eS08e7Cy8dGGn6UhZaJljXZGnmc3UT3dPP2cnUT78xCIV6j2\nH/8A9c/6f7vXPI+w8bU1U+vL/d63du5NfUiDcVSIAS8b7RV5eOb/AIqRL2TyXtNX/e2KfXH/AHlF\n+NPH/pr4+2xcxx0hFpY11K7R16KM32ZWz3UaidqSgrc9kcPicWyZJjfw6T+727y3sXh2xarN+K0V\nh6lvPjj3e0ASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQAAAAAkQAkQAkAAAAAAAAAAAAAAA\nEgAAAAAAAAAAAAAAAAAAAAAgAAABKDcAN0bgkY8xzAyRux5kcwM9zdXNkTcFm6OZXzMeYFvMibKu\nZHMC2bo51U2RuC2bom6rc3BZzom6sBZzI52ADPnOdggFnMc6skFnMc6rc3BbznOp3RzAv50c6nml\nHMC/nOf4qOY5wX85zqOc5wbHOc7X5znBsc6edr85zg2ec52vzpi4NjmY5bROG+/bllVzsNTk5dLl\nn0pP8BHmMHWNmzt0aum8obm08vVjfrtnxztR0mXHzTvaZdjVRMTLkZo6yiFen9iZ2pqY/wBP93rN\n3kPY+/LfPX1rE/u9XzN3HfqzdO6vmTuIZ7m7Hc3Bnu8t7TR/vHBP9E/y9Pu837SV31umn+if5Rfi\n/j/01MMb1hjkrtKzBG0bMsmOZY11tOYamr6Und0LUc7XT7u3rJPqL8er9lcPhcFpbzyWm39v7O00\n+FYvA4Zpsc94xxu227jv1IAgAAAAAAAAABKAAAASgASgBIgBIgBIgBIhIAAAAAAAAAAAAAAAAAAC\nUACUJAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAg3AEbomQZbo3YzLGbAz3RNlc3YzcFs2YzdVN2\nM2Bdzom6nmNwW86JurTAMuY3REJ2BB1ZRVMVBhsbSsiqeUFXLucq3lTygp5TlXcpygp5TlXcpygp\n5TlXcqOUFXKjlXcrGYBXysdlswiYBVMdUTCyY6sZBWxlnMMZgGLGZZSwkDdHMiWO4MuY5mEyjcFn\nN1OdVzHMC3nTzqeY5gX85zqOZPMC+Lqdbk20eb/RKOZr8QybaK/XvtH7iZ9aGlp2luzT3fg19NHS\nOjbmPcYX67XH1XSZ9XIzRvMuzrK7zLkZYmYnciunb9lZ5dTk+OP+71cXeP8AZnJ/ip2nf3J/l6iL\n/Fu5L9bMWZczXi6YuIbEWTzKIuyiwLt3nuO25uI4a/hx7/rLuczg8TicvFLbfdpEK6+NPH/phhjo\nstLGkctUWnoxrrU3j1cnWTzZq1jzl1clo5Zcu8c+txR63iP3Tn6pv4+g4o5cVI9IiGe7CJ2iE7t3\nGyN2O6dwSINwSISAlAAlACRAAlAAlACRACRCQAAAAAAAAAASgASISAAAAAAAAAAAAACQAAAAAAAA\nAAAAAASAAAAAAAAAAAAAAAAIAAAQCAJljuljsCJlhMs9mOwMJYys5TkBVsjZdyHICrZPKt5E8oK4\nqmKrOVOwMIqyirPY2Bjyp2ZbAI2NmSARsbMgEbI2ZAMdjZICNkbMkSCNmOzJEgx2YyzljMAwlhKy\nWEwCuWErJhhMArlhLOWEgxljMpljIImWMyTKJA3N0IBO5vux3NwZbnMx3NwZczT4jf3MdPW27a3a\nfJOq1XNP2KdIRfi+J2trSYfcjeF+Wm1OicVeWIiN9kai8xjY12ORqultnI1Ecsujq79XP1FovWYI\nrTgeq+j8QrWZ+3Mx+r2UXeC0WG2Ti2kiN5mL807eUREvbzbaejefHJv62Iv8WUXa0WTFhVtRdlF2\nrz9WUXBtc7jR9dqc2T1ttHyhvZMvJitb0jdq6XHNcNenWVN3028U99WRj6Kb02be3Tq18/SN2Lpc\n3UdN9nOmZrqKX/DaJ/d0svvTLRzV3jomK6+Pd1vvWJj0ZczT0mXxNJht60hfFnQ4qu3N1cWTEgs3\nTur5k7gz3N2O5uDM3Y7m4MtxBuCQASIASIASAAAAAAACRCQAAAAAAAAEoSAAAAAAAAAAAlAAlCQA\nAAAAAAAAAAASAAAAAAAAAAAAIASgAAAEJAQJQCNkbMgGOyOVnsAw5TlZ7GwMOVPKy2NgY7GzIBGx\nskA2AAAAAAAAAAQkBAEghEskAxYzDPZGwK5hjMLJhjMAqmGEwumrCagomFcw2JqqtUFEsLLrV82F\no7gqljKyYYTGwMZRKUSCAQAboJnaN5Bjkneu0d5W4ccViIiOzHFWbTzNumP1Zarr8eeRMbxDW1Mx\nNO67NbkhzNVnmInqzaOZrL93JyZeV0M1++7S02jvxDWxhxx033tPpC8Z6rrezWjmZyazJG2/u03h\n2vFibTHoqvamiwVwY+nLGzV0+SZ1Mx8G0/45tOhzJ5lXMc3UVXRdlF1HP+iYsDPLPPy49/tz1+Te\npSIr0ho6ak5Ms5J8o2q6NImOrHV7XX488ypzTtHXo0s9t6zG7c1G1qz6ubeZiZ3UatXJG3yauSO7\ncvMTEx5tPLb3prPRMVr0HB8vicNxf0+7+kt+LOJwTJyY/Bnz3tH93X36N58cWvq6LSyiyndMSlC7\nmZcymLJiwLosmJVRLKLAtiU7q4lMSCzc3YxJuDMRuAlKAEgAAAlAkAAAAAABKAEgAAAAAJAAAAAA\nAAAAAAAEgAAAAAAAAAAAAAkAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAhIAAACAAAASgAAAAAAEAAAA\nhGzJAImGMwzQDDZjNVuyNgUTVhNGxysZqDVmiu1G5NN2M4waM0+DCaN2cbGcQNGaMZq3JxMJxA1J\nqx2bU4kU09slorWNwa20z02RXHbJbl26QvtFovbHWkxEdJt5y2MOHlr2U1W3jx+1hiw8vSO63lmI\nXRTaEWmtY6snRHO1VpmJ+DjavpSZl2s8b7y4HFcnh0n0gha5ebJN55KRM2mdoiPN6fh+kpwXh0Wy\nRHj5Otp/s5Ps1p62y31+em9aTMYt/OfVfxTiPjZ52naI7fBrI5t66xz5+a1rW7yx0eSL6iZjtEOX\nqNbSletom3lENjh2fbHzbbWt3iVozruc+5ztWubf4M4ybpQ2Oboyrva0Vjza8WdDR4OkXt3n9ldX\nkaePP9VtYqctYhdvt5oivTeCZ2YOxXk6ubqMfV0b9mrljfqlFcq88k7z2U5axeItDa1OPessuC8P\nya7XRWYnwqdbT/ZMilvIu4dpslNdixXja8Y5tt85djZdbDWnGOesRtXFtuw6T27No5Kx2OrKYQlC\nExKJgBnEpiyvdlEgsizKLKollFgWxLKJVRLKJBbEp3VxLKJBnuMWQJEbpBIAAAJAAAABIAAAAAAA\nlAJAAAAAAAAAAAAAASAAAAAAAAAAAAAJAAAABAJABAlAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAA\nAAABAJQAAAAgAABAAI2EoBGyJhkgGPKxmqxAKpownHC+YRMdN5BrTj67R3bOn01o7p01Iv71u89o\nb9a7LfBTfS1vWI2jf12VfQPSW8KX2mas+NC2iv6xMNfJpMnLtEbuuxtMRCtzF55NR5rPps1N/ctP\ny6uHreE6nXZ4pak48X3rT06fB7fNeI33cbX6mI32R/MWu7XF116aDSRhxbRERs8f499bkyZeeKae\nkzE2mdon81/tfxDLGOunwbzlzbx08oaHBvZHJlx48mrvaa94pu04y617576rNGLRRM0397JEd/lu\n9Dw/S3x4qxffo6mm4NjwUiKY4iI9Ib1dHFY6QIaNabbrYrLfrpJtaK1rMzPZb/s+05IpP59OyLeJ\nk7eNfRaOc1ue32I7fGXYpi5Y77M8OGMeOKxHSFsU3Y29deZMzirl6dlVvhLatCjJHeYQv1rXnps1\n8k9/VsW6qLVmZIi1rzitlvFKRvaZ2h6TSaenC9FFY+3brM+sqeG8Prp4+kZ+lvuxPkr1mqm95nfp\nDXM459676a2q1dsV7XietvNno78+CJn1cjX6mOeIm0bR33dfRU5NJjidt9t5afjG/V6JZ7I2QMNh\nnyo2BhsMuVG3wAhMSbbQRAMolnE+iuGUSCyJZRKuGUSCyJZK4llEgyZMYTuCUsYSCQASISAAAlCQ\nAAAAAAEoASCASAAAAAAAAAAAAlACRACQAAAAAAAAAEgCEoASCAAAAAAAAAAAAAAAAAAAAAAABAAA\nAAAAAAAISAIAAAAAAQAAACASgAAAQJAQAAhIDHZhln3do7z0WS18mWsajHjmes7pg3dNi5aRMNqO\nyvDHTpPRaigHZhN4hHRlaVN59JY3zRENLUavaO+yq0iNVlitJ6vNcR1MVi0zO0era1/Ea0rPvbz5\nPM5MWp45qvo2GZrhmfrsnpHpHzTCseEcM/2vrr8Q1Eb4qzy44nziPN63HpYiIiI7LNHoqabBTFii\nIpSNohuVxrKtWMEejPwY9G1FFmHB4mWJn7MdfnIM9JpIx15to5pbUaas/a6rqViI7MxPxqX0UT1r\nO3wVzpbR2hviP5i03Y5s6a879FNtHljydhExCv8AMTPJXBnRZbz0iG5ptFjwe/l96zctMVamTJtE\nyTMibu1VrdTzRMR0j0ed4lr64MVpm0RERvMz5NvX62uOJ69XhOKX1HH9bHDtFvNYnfJeOy0Z2ojX\n6jjnEq6fRUmccTvN/J9H0eKcOnx45neaxEbubwHgOHg+milI3vP2resu3Wu0JQmITsmISDHZHKz2\nJgFc1RMLJhGwK9iIZ7MZgEdgmAEwyiWCdwWRLKJVxKYsC2JTuriWUSDNlEsIlMAySx3SCRCQSIAS\nAAACRACQAAAAAAASIASAAAAAAAAAAAAAAACRACRACQASIAAAAAAAAAAAAAAAAAAAAAAAAQCUAAAA\nAAAAAAIAAAAAAAAQAAAAAACBICBICAAEJAQJQCJcLjuS2ny6fPG/LWdpd1o8T0X07SXx/e7wCdJx\nWa0jmneHQpxPDMdZmJfNtZm49weZrh0/j4o7VtSZ2+Uw0/8A7o49k92vBLc/ntFohFW9PqGXimOI\n6Tu1L8T3eCx6r2t1O3JwvHjifO99v7t/Bwf2l1PXU6rS6eJ8qUm8x+so5TsekzcSjbvs4mt4rzW5\nK2mbT0itesy2cHsvbvqtbmyz5xERWP2jd1tJwrTaONsOKtZ8585+cnDrzmn4Rq+IZObUROHD32n7\nVv8A0ej0uhxaXFGPFSK1j0bkY4jyZRVZVXFGUVWbGwKsk8mObekNrSW3pWf1a2aYjHbm7bNnQ1id\nPW0TvuDdhJEbQABMsLW2R0ZTMQrvfbz2YWzVhpanUxEd0dWkW5c8R5uXxDX1w4pnfr5Q19XxKuOJ\n2neXltVqtVxbV/RdJ715+1bypANfiOu1HENV9C0MTfNeesx2rD1PAeBYuE6aKx72W3W9/WVnBuB4\neF4dqRzZbdb5J72l160WVK02ZxCYhOwI23TsnY2BGxsnYBjsiYZsZBjMMZZSgGEolMsQDdG6NwZ7\npiVe6YkFsSziVMWZRILolMSriWUSCyJTuwhMSDMRCQSI3SAlACRCQAAEoAEoASAAAAAAAAACUACR\nACQAAAAAAAAAAAAASAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAABAAAAAAAAAAAAACBKAAAAAAAQ\nJQAAAhICEbJAYTWJ7wx8KvpC0BV4ceieWGewDHlNmWwCNjZICNhIDmcZredBecdpiY69FXCOLW+i\nUiZidukulmxxlx2paN4mNng+K4+I8Hy2yaTfl37TXetoCPfRxfp1qi3F48ofKMvtvxak8s6LDv61\nrZji9rPaLUf5PC+bfttS0q8q3p9W/wBrRMdpUZuKdN99nzvFqPbTVz7nD8OKs+do2/mW3h4D7Xaq\nZnPrtNpqz35aRaYOHY9Zk4pNt9rR+rl6zi+OnS+WN57Rv1lXp/YrNaYtruL6zNPnGO3hxP6O5w/2\nf0HDuun09Yv55Le9afznqcOvO4tBreMTHu30unnva0bWt8on+70nDuE4OHYYx4Kbesz3tPrMuhGO\nIjpDOKrK9YVpsyiGUQnYGOyUgI2SlAIEmwMWMs9kTAMJYzDOYRMArmGErZhhMArlHmzmGMwDE3Ts\nbAbs4swj5pgFkSziVcM4BZEsolXDKAZwyhjCYBkACQhIAAAAAAAJAAAAAAAAAAAAAAAAAAAShIAA\nAAAAAAJAAAAAAAAAAAAAABAJEAAAAAAAAAAAAAAAIEoBKAAAAAAAAAAAAAAABAlAAAAAAAIAAAAA\nBAkBAkBAkBAlACEgMZjdjbFW8bWrEx8YWANb6Fp+bfwab+vLDKMFK9qxH5L0bAr8OPRPKz2AY7J2\nSbAjYZAI2E7AIEgIEgIEgMdkSy2NgY7MdlmyNoBXsxmFuyNgVTVjNV3KjlBRNTlXTVHKCrlIqt5T\nlBhEMohlFerLlBjEMohMVTEARDKCITsAk2AEgAAAkAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAD/\n2Q==";async function W5(e){let t;return t="function"==typeof createImageBitmap?await async function(e){const t=(e,t="application/octet-stream")=>fetch(`data:${t};base64,${e}`).then((e=>e.blob()));let n,r;switch(e.config.warmup){case"face":n=await t(L5);break;case"body":case"full":n=await t(B5);break;default:n=null}if(n){const t=await createImageBitmap(n);r=await e.detect(t,e.config),t.close()}return r}(e):"undefined"!=typeof Image||void 0!==HZ.Canvas?await async function(e){return new Promise((t=>{let n,r;switch(e.config.warmup){case"face":n="data:image/jpeg;base64,"+L5;break;case"full":case"body":n="data:image/jpeg;base64,"+B5;break;default:n=null}if("undefined"!=typeof Image)r=new Image;else{if(!HZ.Image)return;r=new HZ.Image}r.onload=async()=>{const n=VZ(r.naturalWidth,r.naturalHeight);if(n){const a=n.getContext("2d");a&&a.drawImage(r,0,0);const s=await e.image(n),o=await e.detect(s.tensor,e.config);t(o)}else d("Warmup: Canvas not found"),t(void 0)},n?r.src=n:t(void 0)}))}(e):await async function(e){const t=e=>Buffer.from(e,"base64");let n,r;if(n="face"===e.config.warmup?t(L5):t(B5),"node"in A){const t=(void 0).decodeJpeg(n),a=t.expandDims(0);e.tf.dispose(t),r=await e.detect(a,e.config),e.tf.dispose(a)}else e.config.debug&&d("Warmup tfjs-node not loaded");return r}(e),t}async function U5(e,t){const n=h();return e.state="warmup",t&&(e.config=f(e.config,t)),e.config.warmup&&0!==e.config.warmup.length&&"none"!==e.config.warmup?new Promise((async t=>{await async function(e){const t=ki(),n=Ni();if("webgl"!==t&&"humangl"!==t||!n||!n.checkCompileCompletion)return;qe().set("ENGINE_COMPILE_ONLY",!0);const r=fi().state.numTensors,a=[];for(const[t,n]of Object.entries(e).filter((([e,t])=>null!==e&&null!==t))){const e=n.inputs&&n.inputs[0]&&n.inputs[0].shape?[...n.inputs[0].shape]:[1,64,64,3],r=n.inputs&&n.inputs[0]&&n.inputs[0].dtype?n.inputs[0].dtype:"float32";for(let t=0;t<e.length;t++)-1===e[t]&&(e[t]=0===t?1:64);const s=dd(e,r);try{const e=n.execute(s);a.push(t),Array.isArray(e)?e.forEach((e=>yi(e))):yi(e)}catch(e){d("compile fail model:",t)}yi(s)}const s=await n.checkCompileCompletionAsync();n.getUniformLocations(),d("compile pass models:",a),d("compile pass kernels:",s.length),qe().set("ENGINE_COMPILE_ONLY",!1);const o=fi().state.numTensors;o-r>0&&d("tensor leak:",o-r)}(e.models);const r=await W5(e),a=h();e.config.debug&&d("warmup",e.config.warmup,Math.round(a-n),"ms"),e.emit("warmup"),t(r)})):{face:[],body:[],hand:[],gesture:[],object:[],performance:e.performance,timestamp:h(),persons:[],error:null}}var V5=class{constructor(e){var t;o(this,"version"),o(this,"config"),o(this,"result"),o(this,"state"),o(this,"process"),o(this,"tf"),o(this,"env"),o(this,"draw"),o(this,"models"),o(this,"events"),o(this,"faceTriangulation"),o(this,"faceUVMap"),o(this,"performance"),u(this,O5,void 0),u(this,D5,void 0),u(this,z5,void 0),o(this,"gl"),o(this,"analyze",((...e)=>{if(!l(this,D5))return;const t=this.tf.engine().state.numTensors,n=l(this,O5);c(this,O5,t);const r=t-n;0!==r&&d(...e,r)})),u(this,P5,(e=>{if(!l(this,z5))return null;if(!e)return"input is not defined";if(this.env.node&&!(e instanceof Qa))return"input must be a tensor";try{this.tf.getBackend()}catch(e){return"backend not loaded"}return null})),o(this,"similarity",$5),o(this,"distance",_5),o(this,"match",F5),o(this,"emit",(e=>{var t;this.events&&this.events.dispatchEvent&&(null==(t=this.events)||t.dispatchEvent(new Event(e)))})),this.env=HZ;const n=((null==(t=$Z)?void 0:t.tfjs)||$l).replace(/-(.*)/,"");var r;m.wasmPath=`https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${n}/dist/`,m.modelBasePath=HZ.browser?"../models/":"file://models/",m.backend=HZ.browser?"humangl":"tensorflow",this.version=WY,Object.defineProperty(this,"version",{value:WY}),this.config=JSON.parse(JSON.stringify(m)),Object.seal(this.config),this.config.cacheModels="undefined"!=typeof indexedDB,e&&(this.config=f(this.config,e)),r=this.config,zY.cacheModels=r.cacheModels,zY.verbose=r.debug,zY.modelBasePath=r.modelBasePath,this.tf=A,this.state="idle",c(this,O5,0),c(this,D5,!1),c(this,z5,!1),this.performance={},this.events="undefined"!=typeof EventTarget?new EventTarget:void 0,this.models=new P2,this.draw={options:r5,canvas:(e,t)=>g5(e,t),face:(e,t,n)=>c5(e,t,n),body:(e,t,n)=>d5(e,t,n),hand:(e,t,n)=>h5(e,t,n),gesture:(e,t,n)=>f5(e,t,n),object:(e,t,n)=>p5(e,t,n),person:(e,t,n)=>A5(e,t,n),all:(e,t,n)=>y5(e,t,n)},this.result={face:[],body:[],hand:[],gesture:[],object:[],performance:{},timestamp:0,persons:[],error:null},this.process={tensor:null,canvas:null},this.faceTriangulation=p0,this.faceUVMap=f0,this.gl=V2,this.emit("create")}reset(){const e=this.config.backend;this.config=JSON.parse(JSON.stringify(m)),this.config.backend=e}validate(e){return p(m,e||this.config)}now(){return h()}image(e,t=!0){return GZ(e,this.config,t)}async segmentation(e,t){return async function(e,t,n){var r,a;if(D2)return{data:[],canvas:null,alpha:null};D2=!0,C2||await z2(n);const s=await GZ(e,n),o=(null==(r=s.tensor)?void 0:r.shape[2])||0,i=(null==(a=s.tensor)?void 0:a.shape[1])||0;if(!s.tensor)return{data:[],canvas:null,alpha:null};const l={};l.resize=Zp.resizeBilinear(s.tensor,[C2.inputs[0].shape?C2.inputs[0].shape[1]:0,C2.inputs[0].shape?C2.inputs[0].shape[2]:0],!1),yi(s.tensor),l.norm=Dl(l.resize,YY.tf255),l.res=C2.execute(l.norm),l.squeeze=ph(l.res,0),2===l.squeeze.shape[2]?(l.softmax=oh(l.squeeze),[l.bg,l.fg]=Eh(l.softmax,2),l.expand=wc(l.fg,2),l.pad=wc(l.expand,0),l.crop=Zp.cropAndResize(l.pad,[[0,0,.5,.5]],[0],[o,i]),l.data=ph(l.crop,0)):l.data=Zp.resizeBilinear(l.squeeze,[i,o]);const u=Array.from(await l.data.data());if(HZ.node&&!HZ.Canvas&&"undefined"==typeof ImageData)return n.debug&&d("canvas support missing"),Object.keys(l).forEach((e=>yi(l[e]))),{data:u,canvas:null,alpha:null};const c=VZ(o,i);Bi&&await Bi.toPixels(l.data,c);const h=c.getContext("2d");n.segmentation.blur&&n.segmentation.blur>0&&(h.filter=`blur(${n.segmentation.blur}px)`);const p=h.getImageData(0,0,o,i),f=VZ(o,i),m=f.getContext("2d");s.canvas&&m.drawImage(s.canvas,0,0),m.globalCompositeOperation="darken",n.segmentation.blur&&n.segmentation.blur>0&&(m.filter=`blur(${n.segmentation.blur}px)`),m.drawImage(c,0,0),m.globalCompositeOperation="source-over",m.filter="none";const A=m.getImageData(0,0,o,i);for(let e=0;e<o*i;e++)A.data[4*e+3]=p.data[4*e+0];m.putImageData(A,0,0);let g=null;if(t&&f){g=VZ(o,i);const e=await GZ(t,n);yi(e.tensor);const r=g.getContext("2d");r.drawImage(e.canvas,0,0,g.width,g.height),r.drawImage(f,0,0)}return Object.keys(l).forEach((e=>yi(l[e]))),D2=!1,{data:u,canvas:f,alpha:c}}(e,t,this.config)}enhance(e){return x0(e)}compare(e,t){return async function(e,t,n){const r={};if(!t||!n||4!==t.shape.length||t.shape.length!==n.shape.length)return e.debug||d("invalid input tensor or tensor shapes do not match:",t.shape,n.shape),0;if(1!==t.shape[0]||1!==n.shape[0]||3!==t.shape[3]||3!==n.shape[3])return e.debug||d("input tensors must be of shape [1, height, width, 3]:",t.shape,n.shape),0;r.input1=Po(t),r.input2=t.shape[1]!==n.shape[1]||t.shape[2]!==n.shape[2]?Zp.resizeBilinear(n,[t.shape[1],t.shape[2]]):Po(n),r.diff=Zc(r.input1,r.input2),r.squared=zl(r.diff,r.diff),r.sum=gc(r.squared);const a=(await r.sum.data())[0]/(t.shape[1]||1)/(t.shape[2]||1)/255/3;return yi([r.input1,r.input2,r.diff,r.squared,r.sum]),a}(this.config,e,t)}async init(){await G2(this,!0),await this.tf.ready()}async load(e){this.state="load";const t=h(),n=Object.values(this.models).filter((e=>e)).length;e&&(this.config=f(this.config,e)),this.env.initial&&(this.config.debug&&d(`version: ${this.version}`),this.config.debug&&d(`tfjs version: ${this.tf.version["tfjs-core"]}`),await G2(this)||d("error: backend check failed"),await wi(),this.env.browser&&(this.config.debug&&d("configuration:",this.config),this.config.debug&&d("environment:",this.env),this.config.debug&&d("tf flags:",this.tf.ENV.flags))),await W2(this),this.env.initial&&this.config.debug&&d("tf engine state:",this.tf.engine().state.numBytes,"bytes",this.tf.engine().state.numTensors,"tensors"),this.env.initial=!1;Object.values(this.models).filter((e=>e)).length!==n&&(await U2(this),this.emit("load"));const r=Math.trunc(h()-t);r>(this.performance.loadModels||0)&&(this.performance.loadModels=this.env.perfadd?(this.performance.loadModels||0)+r:r)}next(e=this.result){return function(e,t){var n,r,a,s,o,i,l,u,c,d,p,f,m,A,g,y,x,b,v,w,k,S,I,C,E,N,T;const R=h();if(!e)return{face:[],body:[],hand:[],gesture:[],object:[],persons:[],performance:{},timestamp:0,error:null};const _=Date.now()-e.timestamp,M=_<1e3?8-Math.log(_+1):1;if(e.canvas&&(N5.canvas=e.canvas),e.error&&(N5.error=e.error),N5.body&&e.body.length===N5.body.length)for(let l=0;l<e.body.length;l++){const u=e.body[l].box.map(((e,t)=>((M-1)*N5.body[l].box[t]+e)/M)),c=e.body[l].boxRaw.map(((e,t)=>((M-1)*N5.body[l].boxRaw[t]+e)/M)),d=e.body[l].keypoints.map(((e,t)=>{var n,r,a,s,o,i,u,c,d;return{score:e.score,part:e.part,position:[N5.body[l].keypoints[t]?((M-1)*(N5.body[l].keypoints[t].position[0]||0)+(e.position[0]||0))/M:e.position[0],N5.body[l].keypoints[t]?((M-1)*(N5.body[l].keypoints[t].position[1]||0)+(e.position[1]||0))/M:e.position[1],N5.body[l].keypoints[t]?((M-1)*(N5.body[l].keypoints[t].position[2]||0)+(e.position[2]||0))/M:e.position[2]],positionRaw:[N5.body[l].keypoints[t]?((M-1)*(N5.body[l].keypoints[t].positionRaw[0]||0)+(e.positionRaw[0]||0))/M:e.positionRaw[0],N5.body[l].keypoints[t]?((M-1)*(N5.body[l].keypoints[t].positionRaw[1]||0)+(e.positionRaw[1]||0))/M:e.positionRaw[1],N5.body[l].keypoints[t]?((M-1)*(N5.body[l].keypoints[t].positionRaw[2]||0)+(e.positionRaw[2]||0))/M:e.positionRaw[2]],distance:[N5.body[l].keypoints[t]?((M-1)*((null==(n=N5.body[l].keypoints[t].distance)?void 0:n[0])||0)+((null==(r=e.distance)?void 0:r[0])||0))/M:null==(a=e.distance)?void 0:a[0],N5.body[l].keypoints[t]?((M-1)*((null==(s=N5.body[l].keypoints[t].distance)?void 0:s[1])||0)+((null==(o=e.distance)?void 0:o[1])||0))/M:null==(i=e.distance)?void 0:i[1],N5.body[l].keypoints[t]?((M-1)*((null==(u=N5.body[l].keypoints[t].distance)?void 0:u[2])||0)+((null==(c=e.distance)?void 0:c[2])||0))/M:null==(d=e.distance)?void 0:d[2]]}})),h={};let p={connected:{}};(null==(r=null==(n=t.body)?void 0:n.modelPath)?void 0:r.includes("efficientpose"))?p=bQ:(null==(s=null==(a=t.body)?void 0:a.modelPath)?void 0:s.includes("blazepose"))?p=XJ:(null==(i=null==(o=t.body)?void 0:o.modelPath)?void 0:i.includes("movenet"))&&(p=q1);for(const[e,t]of Object.entries(p.connected)){const n=[];for(let e=0;e<t.length-1;e++){const r=d.find((n=>n.part===t[e])),a=d.find((n=>n.part===t[e+1]));r&&a&&n.push([r.position,a.position])}h[e]=n}N5.body[l]={...e.body[l],box:u,boxRaw:c,keypoints:d,annotations:h}}else N5.body=JSON.parse(JSON.stringify(e.body));if(N5.hand&&e.hand.length===N5.hand.length)for(let t=0;t<e.hand.length;t++){const n=e.hand[t].box.map(((e,n)=>((M-1)*N5.hand[t].box[n]+e)/M)),r=e.hand[t].boxRaw.map(((e,n)=>((M-1)*N5.hand[t].boxRaw[n]+e)/M));N5.hand[t].keypoints.length!==e.hand[t].keypoints.length&&(N5.hand[t].keypoints=e.hand[t].keypoints);const a=e.hand[t].keypoints&&e.hand[t].keypoints.length>0?e.hand[t].keypoints.map(((e,n)=>e.map(((e,r)=>((M-1)*(N5.hand[t].keypoints[n][r]||1)+(e||0))/M)))):[];let s={};if(Object.keys(N5.hand[t].annotations).length!==Object.keys(e.hand[t].annotations).length)N5.hand[t].annotations=e.hand[t].annotations,s=N5.hand[t].annotations;else if(e.hand[t].annotations)for(const n of Object.keys(e.hand[t].annotations))s[n]=e.hand[t].annotations[n]&&e.hand[t].annotations[n][0]?e.hand[t].annotations[n].map(((e,r)=>e.map(((e,a)=>((M-1)*N5.hand[t].annotations[n][r][a]+e)/M)))):null;N5.hand[t]={...e.hand[t],box:n,boxRaw:r,keypoints:a,annotations:s}}else N5.hand=JSON.parse(JSON.stringify(e.hand));if(N5.face&&e.face.length===N5.face.length)for(let t=0;t<e.face.length;t++){const n=e.face[t].box.map(((e,n)=>((M-1)*N5.face[t].box[n]+e)/M)),r=e.face[t].boxRaw.map(((e,n)=>((M-1)*N5.face[t].boxRaw[n]+e)/M));if(e.face[t].rotation){const a={matrix:[0,0,0,0,0,0,0,0,0],angle:{roll:0,yaw:0,pitch:0},gaze:{bearing:0,strength:0}};a.matrix=null==(l=e.face[t].rotation)?void 0:l.matrix,a.angle={roll:((M-1)*((null==(c=null==(u=N5.face[t].rotation)?void 0:u.angle)?void 0:c.roll)||0)+((null==(p=null==(d=e.face[t].rotation)?void 0:d.angle)?void 0:p.roll)||0))/M,yaw:((M-1)*((null==(m=null==(f=N5.face[t].rotation)?void 0:f.angle)?void 0:m.yaw)||0)+((null==(g=null==(A=e.face[t].rotation)?void 0:A.angle)?void 0:g.yaw)||0))/M,pitch:((M-1)*((null==(x=null==(y=N5.face[t].rotation)?void 0:y.angle)?void 0:x.pitch)||0)+((null==(v=null==(b=e.face[t].rotation)?void 0:b.angle)?void 0:v.pitch)||0))/M},a.gaze={bearing:((M-1)*((null==(k=null==(w=N5.face[t].rotation)?void 0:w.gaze)?void 0:k.bearing)||0)+((null==(I=null==(S=e.face[t].rotation)?void 0:S.gaze)?void 0:I.bearing)||0))/M,strength:((M-1)*((null==(E=null==(C=N5.face[t].rotation)?void 0:C.gaze)?void 0:E.strength)||0)+((null==(T=null==(N=e.face[t].rotation)?void 0:N.gaze)?void 0:T.strength)||0))/M},N5.face[t]={...e.face[t],rotation:a,box:n,boxRaw:r}}N5.face[t]={...e.face[t],box:n,boxRaw:r}}else N5.face=JSON.parse(JSON.stringify(e.face));if(N5.object&&e.object.length===N5.object.length)for(let t=0;t<e.object.length;t++){const n=e.object[t].box.map(((e,n)=>((M-1)*N5.object[t].box[n]+e)/M)),r=e.object[t].boxRaw.map(((e,n)=>((M-1)*N5.object[t].boxRaw[n]+e)/M));N5.object[t]={...e.object[t],box:n,boxRaw:r}}else N5.object=JSON.parse(JSON.stringify(e.object));if(e.persons){const t=e.persons;if(N5.persons&&t.length===N5.persons.length)for(let e=0;e<t.length;e++)N5.persons[e].box=t[e].box.map(((t,n)=>((M-1)*N5.persons[e].box[n]+t)/M));else N5.persons=JSON.parse(JSON.stringify(t))}e.gesture&&(N5.gesture=e.gesture);const $=h();return T5=HZ.perfadd?T5+Math.round($-R):Math.round($-R),e.performance&&(N5.performance={...e.performance,interpolate:T5}),N5}(e,this.config)}getModelStats(){return L2(this)}async warmup(e){const t=h(),n=await U5(this,e),r=h();return this.performance.warmup=Math.trunc(r-t),n}async profile(e,t){const n=await this.tf.profile((()=>this.detect(e,t))),r={};for(const e of n.kernels)r[e.name]?r[e.name]+=e.kernelTimeMs:r[e.name]=e.kernelTimeMs;const a=[];Object.entries(r).forEach((e=>a.push({name:e[0],ms:e[1]}))),a.sort(((e,t)=>t.ms-e.ms)),a.length=20;const s={};for(const e of a)s[e.name]=e.ms;return s}async detect(e,t){return this.state="detect",new Promise((async n=>{var r,a,s,o,i,u,c,p,m,A,g,y,x,b,v,w,k,S,I,C,E,N;let T;this.state="config",this.config=f(this.config,t),this.state="check";const R=l(this,P5).call(this,e);R&&(d(R,e),this.emit("error"),n({face:[],body:[],hand:[],gesture:[],object:[],performance:this.performance,timestamp:h(),persons:[],error:R}));const _=h();await G2(this),await this.load(),T=h(),this.state="image";const M=await GZ(e,this.config);if(this.process=M,this.performance.inputProcess=this.env.perfadd?(this.performance.inputProcess||0)+Math.trunc(h()-T):Math.trunc(h()-T),this.analyze("Get Image:"),!M.tensor)return this.config.debug&&d("could not convert input to tensor"),this.emit("error"),void n({face:[],body:[],hand:[],gesture:[],object:[],performance:this.performance,timestamp:h(),persons:[],error:"could not convert input to tensor"});this.emit("image"),T=h(),this.config.skipAllowed=await async function(e,t){let n=!1;if(0===e.cacheSensitivity||!t.shape||4!==t.shape.length||t.shape[1]>2048||t.shape[2]>2048)return n;if(UZ.inputTensor)if(UZ.inputTensor.shape[1]!==t.shape[1]||UZ.inputTensor.shape[2]!==t.shape[2])yi(UZ.inputTensor),UZ.inputTensor=Po(t);else{const r={};r.diff=Zc(t,UZ.inputTensor),r.squared=zl(r.diff,r.diff),r.sum=gc(r.squared);const a=(await r.sum.data())[0]/(t.shape[1]||1)/(t.shape[2]||1)/255/3;yi([UZ.inputTensor,r.diff,r.squared,r.sum]),UZ.inputTensor=Po(t),n=a<=(e.cacheSensitivity||0)}else UZ.inputTensor=Po(t);return n}(this.config,M.tensor),this.performance.totalFrames||(this.performance.totalFrames=0),this.performance.cachedFrames||(this.performance.cachedFrames=0),this.performance.totalFrames++,this.config.skipAllowed&&this.performance.cachedFrames++,this.performance.cacheCheck=this.env.perfadd?(this.performance.cacheCheck||0)+Math.trunc(h()-T):Math.trunc(h()-T),this.analyze("Check Changed:");let $=[],F=[],O=[],D=[];this.state="detect:face",this.config.async?($=this.config.face.enabled?k5(this,M.tensor):[],this.performance.face&&delete this.performance.face):(T=h(),$=this.config.face.enabled?await k5(this,M.tensor):[],this.performance.face=this.env.perfadd?(this.performance.face||0)+Math.trunc(h()-T):Math.trunc(h()-T)),!this.config.async||-1!==this.config.body.maxDetected&&-1!==this.config.hand.maxDetected||($=await $),this.analyze("Start Body:"),this.state="detect:body";const z=-1===this.config.body.maxDetected?f(this.config,{body:{maxDetected:this.config.face.enabled?1*$.length:1}}):this.config;this.config.async?((null==(r=this.config.body.modelPath)?void 0:r.includes("posenet"))?F=this.config.body.enabled?O2(M.tensor,z):[]:(null==(a=this.config.body.modelPath)?void 0:a.includes("blazepose"))?F=this.config.body.enabled?hQ(M.tensor,z):[]:(null==(s=this.config.body.modelPath)?void 0:s.includes("efficientpose"))?F=this.config.body.enabled?NQ(M.tensor,z):[]:(null==(o=this.config.body.modelPath)?void 0:o.includes("movenet"))&&(F=this.config.body.enabled?l2(M.tensor,z):[]),this.performance.body&&delete this.performance.body):(T=h(),(null==(i=this.config.body.modelPath)?void 0:i.includes("posenet"))?F=this.config.body.enabled?await O2(M.tensor,z):[]:(null==(u=this.config.body.modelPath)?void 0:u.includes("blazepose"))?F=this.config.body.enabled?await hQ(M.tensor,z):[]:(null==(c=this.config.body.modelPath)?void 0:c.includes("efficientpose"))?F=this.config.body.enabled?await NQ(M.tensor,z):[]:(null==(p=this.config.body.modelPath)?void 0:p.includes("movenet"))&&(F=this.config.body.enabled?await l2(M.tensor,z):[]),this.performance.body=this.env.perfadd?(this.performance.body||0)+Math.trunc(h()-T):Math.trunc(h()-T)),this.analyze("End Body:"),this.analyze("Start Hand:"),this.state="detect:hand";const P=-1===this.config.hand.maxDetected?f(this.config,{hand:{maxDetected:this.config.face.enabled?2*$.length:1}}):this.config;this.config.async?((null==(A=null==(m=this.config.hand.detector)?void 0:m.modelPath)?void 0:A.includes("handdetect"))?O=this.config.hand.enabled?N1(M.tensor,P):[]:(null==(y=null==(g=this.config.hand.detector)?void 0:g.modelPath)?void 0:y.includes("handtrack"))&&(O=this.config.hand.enabled?W1(M.tensor,P):[]),this.performance.hand&&delete this.performance.hand):(T=h(),(null==(b=null==(x=this.config.hand.detector)?void 0:x.modelPath)?void 0:b.includes("handdetect"))?O=this.config.hand.enabled?await N1(M.tensor,P):[]:(null==(w=null==(v=this.config.hand.detector)?void 0:v.modelPath)?void 0:w.includes("handtrack"))&&(O=this.config.hand.enabled?await W1(M.tensor,P):[]),this.performance.hand=this.env.perfadd?(this.performance.hand||0)+Math.trunc(h()-T):Math.trunc(h()-T)),this.analyze("End Hand:"),this.analyze("Start Object:"),this.state="detect:object",this.config.async?((null==(k=this.config.object.modelPath)?void 0:k.includes("nanodet"))?D=this.config.object.enabled?f2(M.tensor,this.config):[]:(null==(S=this.config.object.modelPath)?void 0:S.includes("centernet"))&&(D=this.config.object.enabled?xQ(M.tensor,this.config):[]),this.performance.object&&delete this.performance.object):(T=h(),(null==(I=this.config.object.modelPath)?void 0:I.includes("nanodet"))?D=this.config.object.enabled?await f2(M.tensor,this.config):[]:(null==(C=this.config.object.modelPath)?void 0:C.includes("centernet"))&&(D=this.config.object.enabled?await xQ(M.tensor,this.config):[]),this.performance.object=this.env.perfadd?(this.performance.object||0)+Math.trunc(h()-T):Math.trunc(h()-T)),this.analyze("End Object:"),this.state="detect:await",this.config.async&&([$,F,O,D]=await Promise.all([$,F,O,D])),this.state="detect:gesture";let L=[];this.config.gesture.enabled&&(T=h(),L=[...I5($),...S5(F),...E5(O),...C5($)],this.config.async?this.performance.gesture&&delete this.performance.gesture:this.performance.gesture=this.env.perfadd?(this.performance.gesture||0)+Math.trunc(h()-T):Math.trunc(h()-T)),this.performance.total=this.env.perfadd?(this.performance.total||0)+Math.trunc(h()-_):Math.trunc(h()-_);const B=(null==(N=null==(E=this.process)?void 0:E.tensor)?void 0:N.shape)||[];this.result={face:$,body:F,hand:O,gesture:L,object:D,performance:this.performance,canvas:this.process.canvas,timestamp:Date.now(),error:null,get persons(){return function(e,t,n,r,a){var s,o,i,l,u,c,d,h,p,f,m,A,g,y,x,b;let v=0;const w=[];for(const k of e){const e={id:v++,face:k,body:null,hands:{left:null,right:null},gestures:[],box:[0,0,0,0]};for(const n of t)k.box[0]>n.box[0]&&k.box[0]<n.box[0]+n.box[2]&&k.box[1]+k.box[3]>n.box[1]&&k.box[1]+k.box[3]<n.box[1]+n.box[3]&&(e.body=n);if(e.body)for(const t of n)t.box[0]+t.box[2]>e.body.box[0]&&t.box[0]+t.box[2]<e.body.box[0]+e.body.box[2]&&t.box[1]+t.box[3]>e.body.box[1]&&t.box[1]+t.box[3]<e.body.box[1]+e.body.box[3]&&e.hands&&(e.hands.left=t),t.box[0]<e.body.box[0]+e.body.box[2]&&t.box[0]>e.body.box[0]&&t.box[1]+t.box[3]>e.body.box[1]&&t.box[1]+t.box[3]<e.body.box[1]+e.body.box[3]&&e.hands&&(e.hands.right=t);for(const t of r)void 0!==t.face&&t.face===k.id?null==(s=e.gestures)||s.push(t):void 0!==t.iris&&t.iris===k.id?null==(o=e.gestures)||o.push(t):void 0!==t.body&&t.body===(null==(i=e.body)?void 0:i.id)?null==(l=e.gestures)||l.push(t):void 0!==t.hand&&t.hand===(null==(c=null==(u=e.hands)?void 0:u.left)?void 0:c.id)?null==(d=e.gestures)||d.push(t):void 0!==t.hand&&t.hand===(null==(p=null==(h=e.hands)?void 0:h.right)?void 0:p.id)&&(null==(f=e.gestures)||f.push(t));const S=[],I=[],C=e=>{e&&4===e.length&&(S.push(e[0],e[0]+e[2]),I.push(e[1],e[1]+e[3]))};C(null==(m=e.face)?void 0:m.box),C(null==(A=e.body)?void 0:A.box),C(null==(y=null==(g=e.hands)?void 0:g.left)?void 0:y.box),C(null==(b=null==(x=e.hands)?void 0:x.right)?void 0:b.box);const E=Math.min(...S),N=Math.min(...I);e.box=[E,N,Math.max(...S)-E,Math.max(...I)-N],a&&a[1]&&a[2]&&(e.boxRaw=[e.box[0]/a[2],e.box[1]/a[1],e.box[2]/a[2],e.box[3]/a[1]]),w.push(e)}return w}($,F,O,L,B)}},yi(M.tensor),this.emit("detect"),this.state="idle",n(this.result)}))}};O5=new WeakMap,D5=new WeakMap,z5=new WeakMap,P5=new WeakMap}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * Human main module
 * @default Human Library
 * @summary <https://github.com/vladmandic/human>
 * @author <https://github.com/vladmandic>
 * @copyright <https://github.com/vladmandic>
 * @license MIT
 */
/** @license See the LICENSE file. */,"./src/components/ActiveVideoCapture/index.tsx":
/*!*****************************************************!*\
  !*** ./src/components/ActiveVideoCapture/index.tsx ***!
  \*****************************************************/(e,t,n)=>{n.r(t),n.d(t,{ActiveVideoCapture:()=>u});var r=n(/*! preact/hooks */"preact/hooks"),a=n(/*! ./style.module.scss */"./src/components/ActiveVideoCapture/style.module.scss"),s=n(/*! ../VideoFeedback */"./src/components/VideoFeedback/index.tsx"),o=n(/*! react/jsx-runtime */"./node_modules/preact/compat/jsx-runtime.mjs");function i(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==n)return;var r,a,s=[],o=!0,i=!1;try{for(n=n.call(e);!(o=(r=n.next()).done)&&(s.push(r.value),!t||s.length!==t);o=!0);}catch(e){i=!0,a=e}finally{try{o||null==n.return||n.return()}finally{if(i)throw a}}return s}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return l(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return l(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function l(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}var u=function(e){var t=e.onError,n=e.onSuccess,l=e.onUserMedia,u=e.debug,c=void 0!==u&&u,d=e.translate,h=e.hasGrantedPermission,p=e.track,f=e.navigationBar,m=i((0,r.useState)(),2),A=m[0],g=m[1];return(0,r.useEffect)((function(){A&&(null==n||n({videoPayload:A}))}),[A,n]),(0,o.jsxs)("div",{className:a.default.wrapper,children:[f&&(0,o.jsx)("div",{className:a.default.navigationBar,children:f}),(0,o.jsx)(s.VideoFeedback,{debug:c,translate:d,hasGrantedPermission:h,onUserMedia:l,setVideoPayload:g,onError:t,track:p})]})}},"./src/components/Alert/index.tsx":
/*!****************************************!*\
  !*** ./src/components/Alert/index.tsx ***!
  \****************************************/(e,t,n)=>{n.r(t),n.d(t,{Alert:()=>o});var r=n(/*! ./style.module.scss */"./src/components/Alert/style.module.scss"),a=n(/*! ../Button */"./src/components/Button/index.tsx"),s=n(/*! react/jsx-runtime */"./node_modules/preact/compat/jsx-runtime.mjs"),o=function(e){var t=e.title,n=e.message,o=e.visible,i=e.buttonLabel,l=e.onConfirm;return(0,s.jsx)("div",{className:"".concat(r.default.alert," ").concat(o?r.default.visible:""),children:(0,s.jsxs)("div",{className:r.default.container,children:[(0,s.jsx)("h3",{className:r.default.title,children:t}),(0,s.jsx)("p",{className:r.default.message,children:n}),(0,s.jsx)(a.Button,{onClick:function(){return l()},children:i})]})})}},"./src/components/Button/index.tsx":
/*!*****************************************!*\
  !*** ./src/components/Button/index.tsx ***!
  \*****************************************/(e,t,n)=>{n.r(t),n.d(t,{Button:()=>s});var r=n(/*! ./style.module.scss */"./src/components/Button/style.module.scss"),a=n(/*! react/jsx-runtime */"./node_modules/preact/compat/jsx-runtime.mjs"),s=function(e){var t=e.onClick,n=e.children;return(0,a.jsx)("button",{onClick:t,className:r.default.button,children:n})}},"./src/components/DebugFrame/index.tsx":
/*!*********************************************!*\
  !*** ./src/components/DebugFrame/index.tsx ***!
  \*********************************************/(e,t,n)=>{n.r(t),n.d(t,{DebugFrame:()=>s});var r=n(/*! ./style.module.scss */"./src/components/DebugFrame/style.module.scss"),a=n(/*! react/jsx-runtime */"./node_modules/preact/compat/jsx-runtime.mjs"),s=function(e){var t=e.centerBounds,n=e.faceBounds,s=e.videoWidth,o=e.warningMessage;return(0,a.jsxs)("div",{className:r.default.portraitDebugging,style:{width:s},children:[t.width?(0,a.jsx)("div",{className:r.default.centerBounds,style:{right:"".concat(t.left,"px"),top:"".concat(t.top,"px"),width:"".concat(t.width,"px"),height:"".concat(t.height,"px")}}):null,n.width?(0,a.jsx)("div",{className:r.default.faceBounds,style:{borderColor:"".concat(o?"red":"green"),color:"".concat(o?"red":"green"),right:"".concat(null==n?void 0:n.left,"px"),top:"".concat(null==n?void 0:n.top,"px"),width:"".concat(null==n?void 0:n.width,"px"),height:"".concat(null==n?void 0:n.height,"px")}}):null]})}},"./src/components/DebugStats/index.tsx":
/*!*********************************************!*\
  !*** ./src/components/DebugStats/index.tsx ***!
  \*********************************************/(e,t,n)=>{n.r(t),n.d(t,{DebugStats:()=>s});var r=n(/*! ./style.module.scss */"./src/components/DebugStats/style.module.scss"),a=n(/*! react/jsx-runtime */"./node_modules/preact/compat/jsx-runtime.mjs"),s=function(e){var t=e.faceRotation,n=e.real,s=e.elapsedTime,o=e.videoWidth,i=e.videoHeight;return(0,a.jsxs)("div",{className:r.default.debug,style:{left:0},children:[(0,a.jsxs)("div",{children:["Elapsed: ",(null==s?void 0:s.toFixed(2))||null]}),(0,a.jsxs)("div",{children:["Yaw: ",null==t?void 0:t.yaw.toFixed(3)]}),(0,a.jsxs)("div",{children:["Pitch: ",null==t?void 0:t.pitch.toFixed(3)]}),(0,a.jsxs)("div",{children:["Roll: ",null==t?void 0:t.roll.toFixed(3)]}),(0,a.jsxs)("div",{children:["Real: ",n]}),(0,a.jsxs)("div",{children:["Width: ",o]}),(0,a.jsxs)("div",{children:["Height: ",i]})]})}},"./src/components/FaceDetection/index.ts":
/*!***********************************************!*\
  !*** ./src/components/FaceDetection/index.ts ***!
  \***********************************************/(e,t,n)=>{n.r(t),n.d(t,{faceDetection:()=>c,loadHuman:()=>u});var r,a=n(/*! @vladmandic/human */"./node_modules/@vladmandic/human/dist/human.esm.js");function s(e){return s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s(e)}function o(){/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */o=function(){return e};var e={},t=Object.prototype,n=t.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},a=r.iterator||"@@iterator",i=r.asyncIterator||"@@asyncIterator",l=r.toStringTag||"@@toStringTag";function u(e,t,n){return Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{u({},"")}catch(e){u=function(e,t,n){return e[t]=n}}function c(e,t,n,r){var a=t&&t.prototype instanceof p?t:p,s=Object.create(a.prototype),o=new I(r||[]);return s._invoke=function(e,t,n){var r="suspendedStart";return function(a,s){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===a)throw s;return E()}for(n.method=a,n.arg=s;;){var o=n.delegate;if(o){var i=w(o,n);if(i){if(i===h)continue;return i}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if("suspendedStart"===r)throw r="completed",n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);r="executing";var l=d(e,t,n);if("normal"===l.type){if(r=n.done?"completed":"suspendedYield",l.arg===h)continue;return{value:l.arg,done:n.done}}"throw"===l.type&&(r="completed",n.method="throw",n.arg=l.arg)}}}(e,n,o),s}function d(e,t,n){try{return{type:"normal",arg:e.call(t,n)}}catch(e){return{type:"throw",arg:e}}}e.wrap=c;var h={};function p(){}function f(){}function m(){}var A={};u(A,a,(function(){return this}));var g=Object.getPrototypeOf,y=g&&g(g(C([])));y&&y!==t&&n.call(y,a)&&(A=y);var x=m.prototype=p.prototype=Object.create(A);function b(e){["next","throw","return"].forEach((function(t){u(e,t,(function(e){return this._invoke(t,e)}))}))}function v(e,t){function r(a,o,i,l){var u=d(e[a],e,o);if("throw"!==u.type){var c=u.arg,h=c.value;return h&&"object"==s(h)&&n.call(h,"__await")?t.resolve(h.__await).then((function(e){r("next",e,i,l)}),(function(e){r("throw",e,i,l)})):t.resolve(h).then((function(e){c.value=e,i(c)}),(function(e){return r("throw",e,i,l)}))}l(u.arg)}var a;this._invoke=function(e,n){function s(){return new t((function(t,a){r(e,n,t,a)}))}return a=a?a.then(s,s):s()}}function w(e,t){var n=e.iterator[t.method];if(void 0===n){if(t.delegate=null,"throw"===t.method){if(e.iterator.return&&(t.method="return",t.arg=void 0,w(e,t),"throw"===t.method))return h;t.method="throw",t.arg=new TypeError("The iterator does not provide a 'throw' method")}return h}var r=d(n,e.iterator,t.arg);if("throw"===r.type)return t.method="throw",t.arg=r.arg,t.delegate=null,h;var a=r.arg;return a?a.done?(t[e.resultName]=a.value,t.next=e.nextLoc,"return"!==t.method&&(t.method="next",t.arg=void 0),t.delegate=null,h):a:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,h)}function k(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function S(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function I(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(k,this),this.reset(!0)}function C(e){if(e){var t=e[a];if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var r=-1,s=function t(){for(;++r<e.length;)if(n.call(e,r))return t.value=e[r],t.done=!1,t;return t.value=void 0,t.done=!0,t};return s.next=s}}return{next:E}}function E(){return{value:void 0,done:!0}}return f.prototype=m,u(x,"constructor",m),u(m,"constructor",f),f.displayName=u(m,l,"GeneratorFunction"),e.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===f||"GeneratorFunction"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,m):(e.__proto__=m,u(e,l,"GeneratorFunction")),e.prototype=Object.create(x),e},e.awrap=function(e){return{__await:e}},b(v.prototype),u(v.prototype,i,(function(){return this})),e.AsyncIterator=v,e.async=function(t,n,r,a,s){void 0===s&&(s=Promise);var o=new v(c(t,n,r,a),s);return e.isGeneratorFunction(n)?o:o.next().then((function(e){return e.done?e.value:o.next()}))},b(x),u(x,l,"Generator"),u(x,a,(function(){return this})),u(x,"toString",(function(){return"[object Generator]"})),e.keys=function(e){var t=[];for(var n in e)t.push(n);return t.reverse(),function n(){for(;t.length;){var r=t.pop();if(r in e)return n.value=r,n.done=!1,n}return n.done=!0,n}},e.values=C,I.prototype={constructor:I,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(S),!e)for(var t in this)"t"===t.charAt(0)&&n.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=void 0)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var t=this;function r(n,r){return o.type="throw",o.arg=e,t.next=n,r&&(t.method="next",t.arg=void 0),!!r}for(var a=this.tryEntries.length-1;a>=0;--a){var s=this.tryEntries[a],o=s.completion;if("root"===s.tryLoc)return r("end");if(s.tryLoc<=this.prev){var i=n.call(s,"catchLoc"),l=n.call(s,"finallyLoc");if(i&&l){if(this.prev<s.catchLoc)return r(s.catchLoc,!0);if(this.prev<s.finallyLoc)return r(s.finallyLoc)}else if(i){if(this.prev<s.catchLoc)return r(s.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return r(s.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r];if(a.tryLoc<=this.prev&&n.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var s=a;break}}s&&("break"===e||"continue"===e)&&s.tryLoc<=t&&t<=s.finallyLoc&&(s=null);var o=s?s.completion:{};return o.type=e,o.arg=t,s?(this.method="next",this.next=s.finallyLoc,h):this.complete(o)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),h},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.finallyLoc===e)return this.complete(n.completion,n.afterLoc),S(n),h}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.tryLoc===e){var r=n.completion;if("throw"===r.type){var a=r.arg;S(n)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(e,t,n){return this.delegate={iterator:C(e),resultName:t,nextLoc:n},"next"===this.method&&(this.arg=void 0),h}},e}function i(e,t,n,r,a,s,o){try{var i=e[s](o),l=i.value}catch(e){return void n(e)}i.done?t(l):Promise.resolve(l).then(r,a)}var l={backend:"webgl",debug:!1,warmup:"face",modelBasePath:"".concat("https://assets.onfido.com/biometrics/active-video-liveness","/models/"),face:{enabled:!0,detector:{rotation:!0,maxDetected:1},mesh:{enabled:!0},iris:{enabled:!1},gesture:{enabled:!1},emotion:{enabled:!1},description:{enabled:!1},antispoof:{enabled:!1}},body:{enabled:!1},hand:{enabled:!1},object:{enabled:!1},gesture:{enabled:!1},segmentation:{enabled:!1}},u=function(){(r=new a.default(l)).load(),r.warmup(l).then((function(){console.log("this is config: ".concat(r.config.backend))}))},c=function(){var e,t=(e=o().mark((function e(t){return o().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,r.detect(t);case 2:return e.abrupt("return",e.sent);case 3:case"end":return e.stop()}}),e)})),function(){var t=this,n=arguments;return new Promise((function(r,a){var s=e.apply(t,n);function o(e){i(s,r,a,o,l,"next",e)}function l(e){i(s,r,a,o,l,"throw",e)}o(void 0)}))});return function(e){return t.apply(this,arguments)}}()},"./src/components/ProgressBars/index.tsx":
/*!***********************************************!*\
  !*** ./src/components/ProgressBars/index.tsx ***!
  \***********************************************/(e,t,n)=>{n.r(t),n.d(t,{ProgressBars:()=>i});var r=n(/*! ../../helpers */"./src/helpers/index.ts"),a=n(/*! ./style.module.scss */"./src/components/ProgressBars/style.module.scss"),s=n(/*! react/jsx-runtime */"./node_modules/preact/compat/jsx-runtime.mjs");function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var i=function(e){var t,n,i=e.left,l=e.right,u=function(e){var t={left:i,right:l};return Math.round(280-t[e]/100*280)},c=function(){return 100===i&&100===l};return(0,s.jsxs)("div",{className:a.default.progressWrapper,children:[(0,s.jsxs)("svg",{width:"48",height:"48",fill:"none",xmlns:"http://www.w3.org/2000/svg",className:(0,r.classy)(a.default.checkIcon,o({},a.default.scanComplete,c())),children:[(0,s.jsx)("rect",{width:"48",height:"48",rx:"24",fill:"#CBF8DA"}),(0,s.jsx)("path",{d:"m21.334 28.782-4.391-4.39-1.885 1.885 6.276 6.276L34.276 19.61l-1.885-1.885-11.057 11.057Z",fill:"#057D27"})]}),(0,s.jsxs)("div",{className:(0,r.classy)(a.default.leftProgressWrapper,(t={},o(t,a.default.finished,100===i),o(t,a.default.final,c()),t)),children:[(0,s.jsxs)("div",{className:a.default.progressLines,children:[(0,s.jsx)("svg",{width:"109",height:"162",viewBox:"0 0 131 196",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:(0,s.jsx)("path",{className:a.default.top,style:{strokeDashoffset:u("left")},d:"M 131 3.047 C 131 3.047 10.549 6.664 3.036 130.043 L 3.036 196"})}),(0,s.jsx)("svg",{width:"109",height:"162",viewBox:"0 0 131 196",className:a.default.bottomWrapper,fill:"none",xmlns:"http://www.w3.org/2000/svg",children:(0,s.jsx)("path",{className:a.default.bottom,style:{strokeDashoffset:u("left")},d:"M 131 3.047 C 131 3.047 10.549 6.664 3.036 130.043 L 3.036 196"})})]}),(0,s.jsx)("div",{className:a.default.placeholder,children:(0,s.jsx)("svg",{width:"109",height:"324",viewBox:"0 0 109 324",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:(0,s.jsx)("path",{opacity:".15",d:"M106.5 322v0C48.032 319.334 2 271.156 2 212.627V111.373C2 52.844 48.032 4.666 106.5 2v0",stroke:"#fff",strokeWidth:"4",strokeLinecap:"round"})})})]}),(0,s.jsxs)("div",{className:(0,r.classy)(a.default.rightProgressWrapper,(n={},o(n,a.default.finished,100===l),o(n,a.default.final,c()),n)),children:[(0,s.jsxs)("div",{className:a.default.progressLines,children:[(0,s.jsx)("svg",{width:"109",height:"162",viewBox:"0 0 131 196",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:(0,s.jsx)("path",{className:a.default.top,style:{strokeDashoffset:u("right")},d:"M 131 3.047 C 131 3.047 10.549 6.664 3.036 130.043 L 3.036 196"})}),(0,s.jsx)("svg",{width:"109",height:"162",className:a.default.bottomWrapper,viewBox:"0 0 131 196",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:(0,s.jsx)("path",{className:a.default.bottom,style:{strokeDashoffset:u("right")},d:"M 131 3.047 C 131 3.047 10.549 6.664 3.036 130.043 L 3.036 196"})})]}),(0,s.jsx)("div",{className:a.default.placeholder,children:(0,s.jsx)("svg",{width:"109",height:"324",viewBox:"0 0 109 324",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:(0,s.jsx)("path",{opacity:".15",d:"M106.5 322v0C48.032 319.334 2 271.156 2 212.627V111.373C2 52.844 48.032 4.666 106.5 2v0",stroke:"#fff",strokeWidth:"4",strokeLinecap:"round"})})})]})]})}},"./src/components/VideoFeedback/index.tsx":
/*!************************************************!*\
  !*** ./src/components/VideoFeedback/index.tsx ***!
  \************************************************/(e,t,n)=>{n.r(t),n.d(t,{VideoFeedback:()=>C});var r,a,s=n(/*! preact/hooks */"preact/hooks"),o=n(/*! ../FaceDetection */"./src/components/FaceDetection/index.ts"),i=n(/*! ../DebugStats */"./src/components/DebugStats/index.tsx"),l=n(/*! ../DebugFrame */"./src/components/DebugFrame/index.tsx"),u=n(/*! ../VideoFrame */"./src/components/VideoFrame/index.tsx"),c=n(/*! react-webcam */"./node_modules/react-webcam/dist/react-webcam.js"),d=n.n(c),h=n(/*! ../../helpers */"./src/helpers/index.ts"),p=n(/*! ./style.module.scss */"./src/components/VideoFeedback/style.module.scss"),f=n(/*! ../../types */"./src/types/index.ts"),m=n(/*! ../Alert */"./src/components/Alert/index.tsx"),A=n(/*! react/jsx-runtime */"./node_modules/preact/compat/jsx-runtime.mjs");function g(e){return g="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},g(e)}function y(){/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */y=function(){return e};var e={},t=Object.prototype,n=t.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},a=r.iterator||"@@iterator",s=r.asyncIterator||"@@asyncIterator",o=r.toStringTag||"@@toStringTag";function i(e,t,n){return Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{i({},"")}catch(e){i=function(e,t,n){return e[t]=n}}function l(e,t,n,r){var a=t&&t.prototype instanceof d?t:d,s=Object.create(a.prototype),o=new I(r||[]);return s._invoke=function(e,t,n){var r="suspendedStart";return function(a,s){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===a)throw s;return E()}for(n.method=a,n.arg=s;;){var o=n.delegate;if(o){var i=w(o,n);if(i){if(i===c)continue;return i}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if("suspendedStart"===r)throw r="completed",n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);r="executing";var l=u(e,t,n);if("normal"===l.type){if(r=n.done?"completed":"suspendedYield",l.arg===c)continue;return{value:l.arg,done:n.done}}"throw"===l.type&&(r="completed",n.method="throw",n.arg=l.arg)}}}(e,n,o),s}function u(e,t,n){try{return{type:"normal",arg:e.call(t,n)}}catch(e){return{type:"throw",arg:e}}}e.wrap=l;var c={};function d(){}function h(){}function p(){}var f={};i(f,a,(function(){return this}));var m=Object.getPrototypeOf,A=m&&m(m(C([])));A&&A!==t&&n.call(A,a)&&(f=A);var x=p.prototype=d.prototype=Object.create(f);function b(e){["next","throw","return"].forEach((function(t){i(e,t,(function(e){return this._invoke(t,e)}))}))}function v(e,t){function r(a,s,o,i){var l=u(e[a],e,s);if("throw"!==l.type){var c=l.arg,d=c.value;return d&&"object"==g(d)&&n.call(d,"__await")?t.resolve(d.__await).then((function(e){r("next",e,o,i)}),(function(e){r("throw",e,o,i)})):t.resolve(d).then((function(e){c.value=e,o(c)}),(function(e){return r("throw",e,o,i)}))}i(l.arg)}var a;this._invoke=function(e,n){function s(){return new t((function(t,a){r(e,n,t,a)}))}return a=a?a.then(s,s):s()}}function w(e,t){var n=e.iterator[t.method];if(void 0===n){if(t.delegate=null,"throw"===t.method){if(e.iterator.return&&(t.method="return",t.arg=void 0,w(e,t),"throw"===t.method))return c;t.method="throw",t.arg=new TypeError("The iterator does not provide a 'throw' method")}return c}var r=u(n,e.iterator,t.arg);if("throw"===r.type)return t.method="throw",t.arg=r.arg,t.delegate=null,c;var a=r.arg;return a?a.done?(t[e.resultName]=a.value,t.next=e.nextLoc,"return"!==t.method&&(t.method="next",t.arg=void 0),t.delegate=null,c):a:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,c)}function k(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function S(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function I(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(k,this),this.reset(!0)}function C(e){if(e){var t=e[a];if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var r=-1,s=function t(){for(;++r<e.length;)if(n.call(e,r))return t.value=e[r],t.done=!1,t;return t.value=void 0,t.done=!0,t};return s.next=s}}return{next:E}}function E(){return{value:void 0,done:!0}}return h.prototype=p,i(x,"constructor",p),i(p,"constructor",h),h.displayName=i(p,o,"GeneratorFunction"),e.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===h||"GeneratorFunction"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,p):(e.__proto__=p,i(e,o,"GeneratorFunction")),e.prototype=Object.create(x),e},e.awrap=function(e){return{__await:e}},b(v.prototype),i(v.prototype,s,(function(){return this})),e.AsyncIterator=v,e.async=function(t,n,r,a,s){void 0===s&&(s=Promise);var o=new v(l(t,n,r,a),s);return e.isGeneratorFunction(n)?o:o.next().then((function(e){return e.done?e.value:o.next()}))},b(x),i(x,o,"Generator"),i(x,a,(function(){return this})),i(x,"toString",(function(){return"[object Generator]"})),e.keys=function(e){var t=[];for(var n in e)t.push(n);return t.reverse(),function n(){for(;t.length;){var r=t.pop();if(r in e)return n.value=r,n.done=!1,n}return n.done=!0,n}},e.values=C,I.prototype={constructor:I,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(S),!e)for(var t in this)"t"===t.charAt(0)&&n.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=void 0)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var t=this;function r(n,r){return o.type="throw",o.arg=e,t.next=n,r&&(t.method="next",t.arg=void 0),!!r}for(var a=this.tryEntries.length-1;a>=0;--a){var s=this.tryEntries[a],o=s.completion;if("root"===s.tryLoc)return r("end");if(s.tryLoc<=this.prev){var i=n.call(s,"catchLoc"),l=n.call(s,"finallyLoc");if(i&&l){if(this.prev<s.catchLoc)return r(s.catchLoc,!0);if(this.prev<s.finallyLoc)return r(s.finallyLoc)}else if(i){if(this.prev<s.catchLoc)return r(s.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return r(s.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r];if(a.tryLoc<=this.prev&&n.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var s=a;break}}s&&("break"===e||"continue"===e)&&s.tryLoc<=t&&t<=s.finallyLoc&&(s=null);var o=s?s.completion:{};return o.type=e,o.arg=t,s?(this.method="next",this.next=s.finallyLoc,c):this.complete(o)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),c},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.finallyLoc===e)return this.complete(n.completion,n.afterLoc),S(n),c}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.tryLoc===e){var r=n.completion;if("throw"===r.type){var a=r.arg;S(n)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(e,t,n){return this.delegate={iterator:C(e),resultName:t,nextLoc:n},"next"===this.method&&(this.arg=void 0),c}},e}function x(e,t,n,r,a,s,o){try{var i=e[s](o),l=i.value}catch(e){return void n(e)}i.done?t(l):Promise.resolve(l).then(r,a)}function b(e){return function(e){if(Array.isArray(e))return k(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||w(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function v(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==n)return;var r,a,s=[],o=!0,i=!1;try{for(n=n.call(e);!(o=(r=n.next()).done)&&(s.push(r.value),!t||s.length!==t);o=!0);}catch(e){i=!0,a=e}finally{try{o||null==n.return||n.return()}finally{if(i)throw a}}return s}(e,t)||w(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function w(e,t){if(e){if("string"==typeof e)return k(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?k(e,t):void 0}}function k(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}!function(e){e[e.TIMEOUT=0]="TIMEOUT",e[e.TOO_FAST=1]="TOO_FAST"}(r||(r={})),function(e){e[e.INITIAL=0]="INITIAL",e[e.ALIGNED=1]="ALIGNED",e[e.TOO_FAR=2]="TOO_FAR",e[e.TOO_CLOSE=3]="TOO_CLOSE",e[e.NOT_CENTERED=4]="NOT_CENTERED"}(a||(a={}));var S=function(){return{left:0,top:0,width:0,height:0}},I=["video/webm;codecs=vp9","video/webm;codecs:vp9","video/webm","video/webm;codecs=vp8,opus","video/webm;codecs=vp8"],C=function(e){var t,n,c,g,w=e.debug,k=e.setVideoPayload,C=e.onError,E=e.onUserMedia,N=e.translate,T=e.track,R={frameRate:24,facingMode:"user"},_=(0,s.useRef)(null),M=(0,s.useRef)(null),$=(0,s.useRef)(0),F=(0,s.useRef)(0),O=(0,s.useRef)(null),D=(0,s.useRef)(!1),z=(0,s.useRef)(!1),P=v((0,s.useState)(),2),L=P[0],B=P[1],W=v((0,s.useState)(0),2),U=W[0],V=W[1],j=v((0,s.useState)(null),2),G=j[0],H=j[1],q=v((0,s.useState)([]),2),X=q[0],K=q[1],Z=v((0,s.useState)(!1),2),Y=Z[0],J=Z[1],Q=v((0,s.useState)(!1),2),ee=Q[0],te=Q[1],ne=v((0,s.useState)(S),2),re=ne[0],ae=ne[1],se=v((0,s.useState)(S),2),oe=se[0],ie=se[1],le=v((0,s.useState)(S),2),ue=le[0],ce=le[1],de=v((0,s.useState)(""),2),he=de[0],pe=de[1],fe=v((0,s.useState)(N("avc_face_alignment.title")),2),me=fe[0],Ae=fe[1],ge=v((0,s.useState)(a.INITIAL),2),ye=ge[0],xe=ge[1],be=(0,s.useCallback)((function(e){var t=e.data;t.size>0&&K((function(e){return[].concat(b(e),[t])}))}),[K]),ve=(0,s.useCallback)((function(){var e,t;(T(f.TrackingEvent.CAPTURE_SCREEN_SHOWN),null!==(e=_.current)&&void 0!==e&&e.stream)&&(M.current=new MediaRecorder(null===(t=_.current)||void 0===t?void 0:t.stream,{mimeType:[].concat(I,["video/mp4"]).find((function(e){var t;return null===(t=window.MediaRecorder)||void 0===t?void 0:t.isTypeSupported(e)})),audioBitsPerSecond:128e3,videoBitsPerSecond:25e5}),M.current.ondataavailable=be,M.current.start())}),[M,be]),we=(0,s.useCallback)((function(){var e;null===(e=M.current)||void 0===e||e.stop()}),[M]),ke=(0,s.useCallback)((function(){M.current&&(M.current.stop(),K([]),M.current.start())}),[M]);(0,s.useEffect)((function(){L&&(null==L?void 0:L.mesh.length)>0&&(V(Math.round(100*L.rotation.angle.yaw)/100),D.current||(D.current=!0,ke(),Ne(),Ee()),ee&&F.current>=15&&Se())}),[L]);var Se=function(){te(!1),H(r.TIMEOUT),Ce(),T(f.TrackingEvent.CAPTURE_ERROR_TIMEOUT_SHOWN)},Ie=function(){var e;(null===(e=_.current)||void 0===e?void 0:e.video)&&ae(_.current.video.getBoundingClientRect()),Ne(),Ee(),z.current=!0,O.current=requestAnimationFrame(Re)},Ce=function(){z.current=!1,O.current&&cancelAnimationFrame(O.current)},Ee=function(){F.current=+(Date.now()/1e3-$.current).toFixed(2)},Ne=function(){$.current=Math.floor(Date.now()/1e3)},Te=0,Re=function(){var e,t=(e=y().mark((function e(t){var n;return y().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(null!==(n=_.current)&&void 0!==n&&n.video&&z.current){e.next=2;break}return e.abrupt("return");case 2:if(0===Te&&(Te=t),!(t-Te<1e3/R.frameRate)){e.next=6;break}return O.current=requestAnimationFrame(Re),e.abrupt("return");case 6:Te=t,Ee(),(0,o.faceDetection)(_.current.video).then((function(e){B(e.face[0]),void 0===e.face[0]&&(D.current&&(te(!1),D.current=!1,Ne(),Ee()),pe(N("avc_face_alignment.feedback_no_face_detected")),F.current>=10&&C(f.LivenessError.FACE_DETECTION_TIMEOUT)),O.current=requestAnimationFrame(Re)}));case 9:case"end":return e.stop()}}),e)})),function(){var t=this,n=arguments;return new Promise((function(r,a){var s=e.apply(t,n);function o(e){x(s,r,a,o,i,"next",e)}function i(e){x(s,r,a,o,i,"throw",e)}o(void 0)}))});return function(e){return t.apply(this,arguments)}}();(0,s.useEffect)((function(){var e=re.width/5,t=re.height/(ee?16:10),n=ee?20:0;ie({left:e-n,top:t,width:re.width-2*e+2*n,height:re.height-3*t})}),[re,ee]),(0,s.useEffect)((function(){var e,t=null===(e=_.current)||void 0===e?void 0:e.video;if(t&&L){var n=re.height/t.videoHeight;ce({left:(L.box[0]+40)*n,top:(L.box[1]+20)*n,width:(L.box[2]-80)*n,height:(L.box[3]-40)*n})}}),[L,re]),(0,s.useEffect)((function(){var e;if((null===(e=X[0])||void 0===e?void 0:e.size)>0&&Y){var t=new Blob(X,{type:I.some((function(e){var t;return null===(t=window.MediaRecorder)||void 0===t?void 0:t.isTypeSupported(e)}))?"video/webm":"video/mp4"});k(t)}}),[X]),(0,s.useEffect)((function(){ee?(Ne(),Ee(),ve()):T(f.TrackingEvent.ALIGNMENT_SCREEN_SHOWN)}),[ee]),(0,s.useEffect)((function(){Y&&(Ce(),F.current<1.5?(H(r.TOO_FAST),T(f.TrackingEvent.CAPTURE_ERROR_TOO_FAST_SHOWN)):setTimeout(we,1e3))}),[Y]),(0,s.useEffect)((function(){switch(ye){case a.ALIGNED:T(f.TrackingEvent.ALIGNMENT_STATUS_UPDATED_ALIGNED);break;case a.TOO_FAR:T(f.TrackingEvent.ALIGNMENT_STATUS_UPDATED_TOO_FAR);break;case a.TOO_CLOSE:T(f.TrackingEvent.ALIGNMENT_STATUS_UPDATED_TOO_CLOSE);break;case a.NOT_CENTERED:T(f.TrackingEvent.ALIGNMENT_STATUS_UPDATED_NOT_CENTERED)}}),[ye]),(0,s.useEffect)((function(){if(ue.width&&!Y&&re&&L){var e=ee?187:225;ue.width>300?(xe(a.TOO_CLOSE),pe(N("avc_face_alignment.feedback_move_back")),te(!1)):ue.width<e?(xe(a.TOO_FAR),pe(N("avc_face_alignment.feedback_move_closer")),te(!1)):!function(e,t){return e.left>t.left&&e.top>t.top&&e.left+e.width<t.left+t.width&&e.top+e.height<t.top+t.height}(ue,oe)?(xe(a.NOT_CENTERED),pe(N("avc_face_alignment.feedback_not_centered")),te(!1)):(xe(a.ALIGNED),pe(""),Ae(N("avc_face_capture.title")),te(!0))}}),[L,ue,oe,re]),(0,s.useEffect)((function(){return(0,o.loadHuman)()}),[]);var _e,Me,$e;return(0,A.jsxs)("div",{className:p.default.videoContainer,children:[w?(0,A.jsx)(l.DebugFrame,{centerBounds:oe,faceBounds:ue,warningMessage:he,videoWidth:re.width}):null,(0,A.jsx)(u.VideoFrame,{faceYaw:U,ready:ee,setScanComplete:J,scanComplete:Y,warningMessage:he,instructionMessage:me}),w?(0,A.jsx)(i.DebugStats,{faceRotation:null==L?void 0:L.rotation.angle,real:null==L?void 0:L.real,elapsedTime:F.current,videoWidth:null===(t=_.current)||void 0===t||null===(n=t.video)||void 0===n?void 0:n.videoWidth,videoHeight:null===(c=_.current)||void 0===c||null===(g=c.video)||void 0===g?void 0:g.videoHeight}):null,(0,A.jsx)("div",{className:(0,h.classy)(p.default.videoElementWrapper,(_e={},Me=p.default.scanComplete,$e=Y,Me in _e?Object.defineProperty(_e,Me,{value:$e,enumerable:!0,configurable:!0,writable:!0}):_e[Me]=$e,_e)),children:(0,A.jsx)(d(),{className:p.default.videoElement,ref:_,onUserMedia:function(){E&&E(),setTimeout(Ie,2e3)},onUserMediaError:C,videoConstraints:R})}),function(){var e={title:N("avc_face_capture.alert.timeout_title"),message:N("avc_face_capture.alert.timeout_body"),buttonLabel:N("avc_face_capture.alert.timeout_button_primary"),trackingEvent:f.TrackingEvent.CAPTURE_ERROR_TIMEOUT_RESTART_CLICKED};G===r.TOO_FAST&&(e={title:N("avc_face_capture.alert.too_fast_title"),message:N("avc_face_capture.alert.too_fast_body"),buttonLabel:N("avc_face_capture.alert.too_fast_button_primary"),trackingEvent:f.TrackingEvent.CAPTURE_ERROR_TOO_FAST_RESTART_CLICKED});var t=function(e){T(e),ke(),te(!1),J(!1),H(null),Ie()};return(0,A.jsx)(m.Alert,{visible:null!==G,title:e.title,message:e.message,buttonLabel:e.buttonLabel,onConfirm:function(){return t(e.trackingEvent)}})}()]})}},"./src/components/VideoFrame/index.tsx":
/*!*********************************************!*\
  !*** ./src/components/VideoFrame/index.tsx ***!
  \*********************************************/(e,t,n)=>{n.r(t),n.d(t,{VideoFrame:()=>d});var r=n(/*! preact/hooks */"preact/hooks"),a=n(/*! ./style.module.scss */"./src/components/VideoFrame/style.module.scss"),s=n(/*! ../../assets/onfido.svg */"./src/assets/onfido.svg"),o=n(/*! ../WhiteFrame */"./src/components/WhiteFrame/index.tsx"),i=n(/*! ../ProgressBars */"./src/components/ProgressBars/index.tsx"),l=n(/*! react/jsx-runtime */"./node_modules/preact/compat/jsx-runtime.mjs");function u(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==n)return;var r,a,s=[],o=!0,i=!1;try{for(n=n.call(e);!(o=(r=n.next()).done)&&(s.push(r.value),!t||s.length!==t);o=!0);}catch(e){i=!0,a=e}finally{try{o||null==n.return||n.return()}finally{if(i)throw a}}return s}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return c(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return c(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function c(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}var d=function(e){var t=e.faceYaw,n=e.ready,c=e.setScanComplete,d=e.scanComplete,h=e.warningMessage,p=e.instructionMessage,f=u((0,r.useState)(0),2),m=f[0],A=f[1],g=u((0,r.useState)(0),2),y=g[0],x=g[1];(0,r.useEffect)((function(){100===m&&100===y&&c(!0)}),[m,y,c]),(0,r.useEffect)((function(){n||(A(0),x(0))}),[n]);var b=function(e,t,n,r,a,s){var o="left"===e;if(n<100&&a(0),r>=100)s(100);else if(o?t>.1:t<-.1){var i=t*(o?100:-100)/.6;Math.abs(r-i)>100?s(100):s(Math.round(i))}};return(0,r.useEffect)((function(){n&&!d&&(t>0?b("left",t,m,y,A,x):b("right",t,y,m,x,A))}),[t]),(0,l.jsxs)("div",{className:a.default.videoGrid,children:[(0,l.jsx)("div",{className:a.default.topBar}),n?(0,l.jsxs)("div",{className:a.default.middleBarOverlay,children:[(0,l.jsx)("div",{className:a.default.frameOverlayTop}),(0,l.jsxs)("div",{className:a.default.frameOverlayMiddle,children:[(0,l.jsx)("div",{className:a.default.frameOverlayLeft}),(0,l.jsx)("div",{className:a.default.frameMask}),(0,l.jsx)(i.ProgressBars,{left:m,right:y}),(0,l.jsx)("div",{className:a.default.frameOverlayRight})]}),(0,l.jsx)("div",{className:a.default.frameOverlayBottom})]}):(0,l.jsxs)("div",{className:a.default.middleBarWhiteFrame,children:[(0,l.jsx)(o.WhiteFrame,{}),h&&(0,l.jsx)("div",{className:a.default.warningPopup,children:h})]}),(0,l.jsxs)("div",{className:a.default.bottomBar,children:[(0,l.jsx)("span",{children:p}),(0,l.jsx)(s.default,{})]})]})}},"./src/components/WhiteFrame/index.tsx":
/*!*********************************************!*\
  !*** ./src/components/WhiteFrame/index.tsx ***!
  \*********************************************/(e,t,n)=>{n.r(t),n.d(t,{WhiteFrame:()=>s});var r=n(/*! ./style.module.scss */"./src/components/WhiteFrame/style.module.scss"),a=n(/*! react/jsx-runtime */"./node_modules/preact/compat/jsx-runtime.mjs"),s=function(){return(0,a.jsxs)("svg",{width:"100%",height:"100%",viewBox:"0 0 273 364",fill:"none",className:r.default.whiteFrame,xmlns:"http://www.w3.org/2000/svg",children:[(0,a.jsx)("g",{filter:"url(#filter0_d_1824_21222)",children:(0,a.jsx)("path",{d:"M22 70V46C22 32.7452 32.7452 22 46 22H70",stroke:"white",strokeWidth:"4",strokeLinecap:"round",strokeLinejoin:"round"})}),(0,a.jsx)("g",{filter:"url(#filter1_d_1824_21222)",children:(0,a.jsx)("path",{d:"M251 294L251 318C251 331.255 240.255 342 227 342L203 342",stroke:"white",strokeWidth:"4",strokeLinecap:"round",strokeLinejoin:"round"})}),(0,a.jsx)("g",{filter:"url(#filter2_d_1824_21222)",children:(0,a.jsx)("path",{d:"M70 342L46 342C32.7452 342 22 331.255 22 318L22 294",stroke:"white",strokeWidth:"4",strokeLinecap:"round",strokeLinejoin:"round"})}),(0,a.jsx)("g",{filter:"url(#filter3_d_1824_21222)",children:(0,a.jsx)("path",{d:"M203 22L227 22C240.255 22 251 32.7452 251 46L251 70",stroke:"white",strokeWidth:"4",strokeLinecap:"round",strokeLinejoin:"round"})}),(0,a.jsxs)("defs",{children:[(0,a.jsxs)("filter",{id:"filter0_d_1824_21222",x:"0",y:"0",width:"92",height:"92",filterUnits:"userSpaceOnUse",colorInterpolationFilters:"sRGB",children:[(0,a.jsx)("feFlood",{floodOpacity:"0",result:"BackgroundImageFix"}),(0,a.jsx)("feColorMatrix",{in:"SourceAlpha",type:"matrix",values:"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0",result:"hardAlpha"}),(0,a.jsx)("feOffset",{}),(0,a.jsx)("feGaussianBlur",{stdDeviation:"10"}),(0,a.jsx)("feColorMatrix",{type:"matrix",values:"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.5 0"}),(0,a.jsx)("feBlend",{mode:"normal",in2:"BackgroundImageFix",result:"effect1_dropShadow_1824_21222"}),(0,a.jsx)("feBlend",{mode:"normal",in:"SourceGraphic",in2:"effect1_dropShadow_1824_21222",result:"shape"})]}),(0,a.jsxs)("filter",{id:"filter1_d_1824_21222",x:"181",y:"272",width:"92",height:"92",filterUnits:"userSpaceOnUse",colorInterpolationFilters:"sRGB",children:[(0,a.jsx)("feFlood",{floodOpacity:"0",result:"BackgroundImageFix"}),(0,a.jsx)("feColorMatrix",{in:"SourceAlpha",type:"matrix",values:"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0",result:"hardAlpha"}),(0,a.jsx)("feOffset",{}),(0,a.jsx)("feGaussianBlur",{stdDeviation:"10"}),(0,a.jsx)("feColorMatrix",{type:"matrix",values:"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.5 0"}),(0,a.jsx)("feBlend",{mode:"normal",in2:"BackgroundImageFix",result:"effect1_dropShadow_1824_21222"}),(0,a.jsx)("feBlend",{mode:"normal",in:"SourceGraphic",in2:"effect1_dropShadow_1824_21222",result:"shape"})]}),(0,a.jsxs)("filter",{id:"filter2_d_1824_21222",x:"0",y:"272",width:"92",height:"92",filterUnits:"userSpaceOnUse",colorInterpolationFilters:"sRGB",children:[(0,a.jsx)("feFlood",{floodOpacity:"0",result:"BackgroundImageFix"}),(0,a.jsx)("feColorMatrix",{in:"SourceAlpha",type:"matrix",values:"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0",result:"hardAlpha"}),(0,a.jsx)("feOffset",{}),(0,a.jsx)("feGaussianBlur",{stdDeviation:"10"}),(0,a.jsx)("feColorMatrix",{type:"matrix",values:"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.5 0"}),(0,a.jsx)("feBlend",{mode:"normal",in2:"BackgroundImageFix",result:"effect1_dropShadow_1824_21222"}),(0,a.jsx)("feBlend",{mode:"normal",in:"SourceGraphic",in2:"effect1_dropShadow_1824_21222",result:"shape"})]}),(0,a.jsxs)("filter",{id:"filter3_d_1824_21222",x:"181",y:"0",width:"92",height:"92",filterUnits:"userSpaceOnUse",colorInterpolationFilters:"sRGB",children:[(0,a.jsx)("feFlood",{floodOpacity:"0",result:"BackgroundImageFix"}),(0,a.jsx)("feColorMatrix",{in:"SourceAlpha",type:"matrix",values:"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0",result:"hardAlpha"}),(0,a.jsx)("feOffset",{}),(0,a.jsx)("feGaussianBlur",{stdDeviation:"10"}),(0,a.jsx)("feColorMatrix",{type:"matrix",values:"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.5 0"}),(0,a.jsx)("feBlend",{mode:"normal",in2:"BackgroundImageFix",result:"effect1_dropShadow_1824_21222"}),(0,a.jsx)("feBlend",{mode:"normal",in:"SourceGraphic",in2:"effect1_dropShadow_1824_21222",result:"shape"})]})]})]})}},"./src/helpers/index.ts":
/*!******************************!*\
  !*** ./src/helpers/index.ts ***!
  \******************************/(e,t,n)=>{function r(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==n)return;var r,a,s=[],o=!0,i=!1;try{for(n=n.call(e);!(o=(r=n.next()).done)&&(s.push(r.value),!t||s.length!==t);o=!0);}catch(e){i=!0,a=e}finally{try{o||null==n.return||n.return()}finally{if(i)throw a}}return s}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return a(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return a(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function a(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}n.r(t),n.d(t,{classy:()=>o});var s=function(e){return(e instanceof Object?Object.entries(e).filter((function(e){return!!r(e,2)[1]})).map((function(e){return r(e,1)[0]})):[e]).filter(Boolean)},o=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.flat(10).flatMap(s).join(" ")}},"./src/types/index.ts":
/*!****************************!*\
  !*** ./src/types/index.ts ***!
  \****************************/(e,t,n)=>{var r,a;n.r(t),n.d(t,{LivenessError:()=>r,TrackingEvent:()=>a}),function(e){e.FACE_DETECTION_TIMEOUT="face_detection_timeout"}(r||(r={})),function(e){e.ALIGNMENT_SCREEN_SHOWN="alignment",e.ALIGNMENT_STATUS_UPDATED_TOO_FAR="alignment_status_too_far",e.ALIGNMENT_STATUS_UPDATED_TOO_CLOSE="alignment_status_too_close",e.ALIGNMENT_STATUS_UPDATED_ALIGNED="alignment_status_aligned",e.ALIGNMENT_STATUS_UPDATED_NOT_CENTERED="alignment_status_not_centered",e.CAPTURE_SCREEN_SHOWN="capture",e.CAPTURE_STATUS_UPDATED="capture_status",e.CAPTURE_ERROR_TIMEOUT_SHOWN="capture_error_timeout",e.CAPTURE_ERROR_TOO_FAST_SHOWN="capture_error_too_fast",e.CAPTURE_ERROR_TIMEOUT_RESTART_CLICKED="capture_error_timeout_restart_clicked",e.CAPTURE_ERROR_TOO_FAST_RESTART_CLICKED="capture_error_too_fast_restart_clicked"}(a||(a={}))},"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/ActiveVideoCapture/style.module.scss":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/ActiveVideoCapture/style.module.scss ***!
  \******************************************************************************************************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var r=n(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */"./node_modules/css-loader/dist/runtime/sourceMaps.js"),a=n.n(r),s=n(/*! ../../../node_modules/css-loader/dist/runtime/api.js */"./node_modules/css-loader/dist/runtime/api.js"),o=n.n(s)()(a());o.push([e.id,"/* add css module styles here (optional) */\n:root {\n  --ods-transition-duration: 0.15s;\n  --ods-border-radius-small: 2px;\n  --ods-border-radius-medium: 4px;\n  --ods-border-radius-large: 8px;\n  --ods-border-radius-full: 100vw;\n  --ods-color-neutral-900: 30, 30, 36;\n  --ods-color-neutral-800: 43, 45, 51;\n  --ods-color-neutral-700: 71, 73, 82;\n  --ods-color-neutral-600: 99, 102, 112;\n  --ods-color-neutral-500: 130, 136, 147;\n  --ods-color-neutral-400: 180, 186, 197;\n  --ods-color-neutral-300: 213, 218, 224;\n  --ods-color-neutral-200: 233, 236, 240;\n  --ods-color-neutral-100: 247, 249, 250;\n  --ods-color-neutral-050: 252, 252, 253;\n  --ods-color-neutral-white: 255, 255, 255;\n  --ods-color-neutral-black: 0, 0, 0;\n  --ods-color-primary-700: 28, 19, 101;\n  --ods-color-primary-600: 35, 42, 173;\n  --ods-color-primary-500: 54, 64, 245;\n  --ods-color-primary-400: 92, 108, 255;\n  --ods-color-primary-300: 130, 143, 255;\n  --ods-color-primary-200: 189, 195, 255;\n  --ods-color-primary-100: 235, 237, 255;\n  --ods-color-primary-050: 245, 246, 255;\n  --ods-color-primary-muted-600: 101, 105, 160;\n  --ods-color-primary-muted-300: 149, 185, 255;\n  --ods-color-accent-1-600: 255, 100, 100;\n  --ods-color-accent-1-500: 255, 137, 125;\n  --ods-color-accent-1-400: 255, 172, 163;\n  --ods-color-accent-2-600: 249, 178, 20;\n  --ods-color-accent-2-500: 255, 221, 84;\n  --ods-color-accent-2-400: 255, 236, 112;\n  --ods-color-accent-3-600: 129, 35, 173;\n  --ods-color-accent-3-500: 175, 95, 239;\n  --ods-color-accent-3-400: 222, 189, 255;\n  --ods-color-success-600: 0, 107, 36;\n  --ods-color-success-500: 5, 125, 39;\n  --ods-color-success-400: 21, 179, 18;\n  --ods-color-success-300: 81, 209, 123;\n  --ods-color-success-200: 157, 239, 184;\n  --ods-color-success-100: 203, 248, 218;\n  --ods-color-success-050: 236, 253, 241;\n  --ods-color-success-vivid-300: 145, 232, 123;\n  --ods-color-success-muted-500: 108, 137, 94;\n  --ods-color-success-muted-300: 137, 211, 163;\n  --ods-color-info-700: 28, 19, 101;\n  --ods-color-info-600: 35, 42, 173;\n  --ods-color-info-500: 54, 64, 245;\n  --ods-color-info-400: 92, 108, 255;\n  --ods-color-info-300: 130, 143, 255;\n  --ods-color-info-200: 189, 195, 255;\n  --ods-color-info-100: 235, 237, 255;\n  --ods-color-info-050: 245, 246, 255;\n  --ods-color-info-muted-600: 101, 105, 160;\n  --ods-color-info-muted-300: 149, 185, 255;\n  --ods-color-warning-600: 158, 75, 8;\n  --ods-color-warning-500: 196, 107, 4;\n  --ods-color-warning-400: 227, 133, 25;\n  --ods-color-warning-300: 251, 194, 127;\n  --ods-color-warning-200: 250, 218, 181;\n  --ods-color-warning-100: 253, 237, 219;\n  --ods-color-warning-050: 255, 245, 235;\n  --ods-color-warning-vivid-300: 253, 168, 70;\n  --ods-color-warning-muted-500: 150, 125, 96;\n  --ods-color-warning-muted-300: 235, 193, 144;\n  --ods-color-error-600: 170, 0, 0;\n  --ods-color-error-500: 195, 47, 47;\n  --ods-color-error-400: 245, 78, 78;\n  --ods-color-error-300: 252, 123, 123;\n  --ods-color-error-200: 255, 185, 185;\n  --ods-color-error-100: 252, 229, 229;\n  --ods-color-error-050: 255, 246, 246;\n  --ods-color-error-muted-500: 152, 93, 97;\n  --ods-color-error-muted-300: 239, 169, 169;\n  color-scheme: light;\n  --ods-color-content-main: var(--ods-color-neutral-800), 1;\n  --ods-color-content-secondary: var(--ods-color-neutral-600), 1;\n  --ods-color-content-action: var(--ods-color-primary-500), 1;\n  --ods-color-content-placeholder: var(--ods-color-neutral-500), 1;\n  --ods-color-content-disabled: var(--ods-color-neutral-500), 1;\n  --ods-color-content-link: var(--ods-color-primary-500), 1;\n  --ods-color-content-link-hover: var(--ods-color-primary-600), 1;\n  --ods-color-content-link-visited: var(--ods-color-accent-3-600), 1;\n  --ods-color-content-negative: var(--ods-color-error-500), 1;\n  --ods-color-content-warning: var(--ods-color-warning-600), 1;\n  --ods-color-content-positive: var(--ods-color-success-500), 1;\n  --ods-color-content-info: var(--ods-color-info-500), 1;\n  --ods-color-content-spinner: var(--ods-color-neutral-600), 1;\n  --ods-color-content-progress: var(--ods-color-primary-500), 1;\n  --ods-color-content-logo: var(--ods-color-primary-500), 1;\n  --ods-color-content-inverse-main: var(--ods-color-neutral-100), 1;\n  --ods-color-content-inverse-secondary: var(--ods-color-neutral-300), 1;\n  --ods-color-content-on-action: var(--ods-color-neutral-100), 1;\n  --ods-color-content-on-inverse-action: var(--ods-color-primary-500), 1;\n  --ods-color-content-always-light: var(--ods-color-neutral-100), 1;\n  --ods-color-content-always-dark: var(--ods-color-neutral-800), 1;\n  --ods-color-background-main: var(--ods-color-neutral-100), 1;\n  --ods-color-background-surface: var(--ods-color-neutral-050), 1;\n  --ods-color-background-surface-alt: var(--ods-color-neutral-200), 1;\n  --ods-color-background-action: var(--ods-color-primary-500), 1;\n  --ods-color-background-action-hover: var(--ods-color-primary-400), 1;\n  --ods-color-background-action-active: var(--ods-color-primary-600), 1;\n  --ods-color-background-action-subtle: var(--ods-color-primary-500), 0.1;\n  --ods-color-background-action-subtle-hover: var(--ods-color-primary-500), 0.05;\n  --ods-color-background-disabled: var(--ods-color-neutral-200), 1;\n  --ods-color-background-negative: var(--ods-color-error-500), 1;\n  --ods-color-background-negative-hover: var(--ods-color-error-400), 1;\n  --ods-color-background-negative-active: var(--ods-color-error-600), 1;\n  --ods-color-background-negative-subtle: var(--ods-color-error-500), 0.1;\n  --ods-color-background-negative-subtle-hover: var(--ods-color-error-500), 0.05;\n  --ods-color-background-warning: var(--ods-color-warning-400), 1;\n  --ods-color-background-warning-subtle: var(--ods-color-warning-400), 0.1;\n  --ods-color-background-positive: var(--ods-color-success-400), 1;\n  --ods-color-background-positive-subtle: var(--ods-color-success-400), 0.1;\n  --ods-color-background-info: var(--ods-color-info-500), 1;\n  --ods-color-background-info-subtle: var(--ods-color-info-500), 0.1;\n  --ods-color-background-input: var(--ods-color-neutral-050), 1;\n  --ods-color-background-input-selected: var(--ods-color-primary-500), 1;\n  --ods-color-background-spinner: var(--ods-color-neutral-600), 0.15;\n  --ods-color-background-progress: var(--ods-color-primary-500), 0.15;\n  --ods-color-background-overlay: var(--ods-color-neutral-black), 0.8;\n  --ods-color-background-overlay-subtle: var(--ods-color-neutral-black), 0.5;\n  --ods-color-background-inverse-main: var(--ods-color-neutral-900), 1;\n  --ods-color-background-inverse-surface: var(--ods-color-neutral-800), 1;\n  --ods-color-background-inverse-action: var(--ods-color-neutral-white), 1;\n  --ods-color-border-separator: var(--ods-color-neutral-200), 1;\n  --ods-color-border-input: var(--ods-color-neutral-500), 1;\n  --ods-color-border-input-hover: var(--ods-color-neutral-600), 1;\n  --ods-color-border-action: var(--ods-color-primary-500), 1;\n  --ods-color-border-action-hover: var(--ods-color-primary-400), 1;\n  --ods-color-border-action-subtle: var(--ods-color-primary-200), 1;\n  --ods-color-border-disabled: var(--ods-color-neutral-200), 1;\n  --ods-color-border-negative: var(--ods-color-error-500), 1;\n  --ods-color-border-negative-subtle: var(--ods-color-error-200), 1;\n  --ods-color-border-warning: var(--ods-color-warning-400), 1;\n  --ods-color-border-warning-subtle: var(--ods-color-warning-muted-300), 1;\n  --ods-color-border-positive: var(--ods-color-success-500), 1;\n  --ods-color-border-positive-subtle: var(--ods-color-success-muted-300), 1;\n  --ods-color-border-info: var(--ods-color-info-500), 1;\n  --ods-color-border-info-subtle: var(--ods-color-info-200), 1;\n  --ods-color-border-input-selected: var(--ods-color-primary-500), 1;\n  --ods-color-border-focus-inner: var(--ods-color-neutral-white), 1;\n  --ods-color-border-action-focus: var(--ods-color-primary-600), 1;\n  --ods-color-border-negative-focus: var(--ods-color-error-600), 1;\n  --ods-color-border-inverse-action: var(--ods-color-neutral-white), 1;\n}\n@media (prefers-reduced-motion) {\n  :root {\n    --ods-transition-duration: 0s;\n  }\n}\n\n.moGGhyFLGbgs8kh1ppcD {\n  position: absolute;\n  top: 0;\n  height: 100%;\n  width: 100%;\n  max-height: 100%;\n  padding: 0;\n  display: flex;\n  justify-content: center;\n  border-radius: var(--ods-border-radius-large);\n  overflow: hidden;\n}\n\n.li3CiV7LuPwFrzBsZSNw {\n  position: absolute;\n  width: 100%;\n  z-index: 10;\n}","",{version:3,sources:["webpack://./src/components/ActiveVideoCapture/style.module.scss","webpack://./node_modules/@onfido/castor/src/integrated/tokens/tokens.scss","webpack://./node_modules/@onfido/castor/src/integrated/tokens/theme-day.scss","webpack://./node_modules/@onfido/castor/src/integrated/tokens/theme.scss"],names:[],mappings:"AAAA,0CAAA;AAGA;ECAE,gCAAA;EACA,8BAAA;EACA,+BAAA;EACA,8BAAA;EACA,+BAAA;EACA,mCAAA;EACA,mCAAA;EACA,mCAAA;EACA,qCAAA;EACA,sCAAA;EACA,sCAAA;EACA,sCAAA;EACA,sCAAA;EACA,sCAAA;EACA,sCAAA;EACA,wCAAA;EACA,kCAAA;EACA,oCAAA;EACA,oCAAA;EACA,oCAAA;EACA,qCAAA;EACA,sCAAA;EACA,sCAAA;EACA,sCAAA;EACA,sCAAA;EACA,4CAAA;EACA,4CAAA;EACA,uCAAA;EACA,uCAAA;EACA,uCAAA;EACA,sCAAA;EACA,sCAAA;EACA,uCAAA;EACA,sCAAA;EACA,sCAAA;EACA,uCAAA;EACA,mCAAA;EACA,mCAAA;EACA,oCAAA;EACA,qCAAA;EACA,sCAAA;EACA,sCAAA;EACA,sCAAA;EACA,4CAAA;EACA,2CAAA;EACA,4CAAA;EACA,iCAAA;EACA,iCAAA;EACA,iCAAA;EACA,kCAAA;EACA,mCAAA;EACA,mCAAA;EACA,mCAAA;EACA,mCAAA;EACA,yCAAA;EACA,yCAAA;EACA,mCAAA;EACA,oCAAA;EACA,qCAAA;EACA,sCAAA;EACA,sCAAA;EACA,sCAAA;EACA,sCAAA;EACA,2CAAA;EACA,2CAAA;EACA,4CAAA;EACA,gCAAA;EACA,kCAAA;EACA,kCAAA;EACA,oCAAA;EACA,oCAAA;EACA,oCAAA;EACA,oCAAA;EACA,wCAAA;EACA,0CAAA;ECvEE,mBAAA;EAEA,yDAAA;EACA,8DAAA;EACA,2DAAA;EACA,gEAAA;EACA,6DAAA;EACA,yDAAA;EACA,+DAAA;EACA,kEAAA;EACA,2DAAA;EACA,4DAAA;EACA,6DAAA;EACA,sDAAA;EACA,4DAAA;EACA,6DAAA;EACA,yDAAA;EACA,iEAAA;EACA,sEAAA;EACA,8DAAA;EACA,sEAAA;EACA,iEAAA;EACA,gEAAA;EACA,4DAAA;EACA,+DAAA;EACA,mEAAA;EACA,8DAAA;EACA,oEAAA;EACA,qEAAA;EACA,uEAAA;EACA,8EAAA;EACA,gEAAA;EACA,8DAAA;EACA,oEAAA;EACA,qEAAA;EACA,uEAAA;EACA,8EAAA;EACA,+DAAA;EACA,wEAAA;EACA,gEAAA;EACA,yEAAA;EACA,yDAAA;EACA,kEAAA;EACA,6DAAA;EACA,sEAAA;EACA,kEAAA;EACA,mEAAA;EACA,mEAAA;EACA,0EAAA;EACA,oEAAA;EACA,uEAAA;EACA,wEAAA;EACA,6DAAA;EACA,yDAAA;EACA,+DAAA;EACA,0DAAA;EACA,gEAAA;EACA,iEAAA;EACA,4DAAA;EACA,0DAAA;EACA,iEAAA;EACA,2DAAA;EACA,wEAAA;EACA,4DAAA;EACA,yEAAA;EACA,qDAAA;EACA,4DAAA;EACA,kEAAA;EACA,iEAAA;EACA,gEAAA;EACA,gEAAA;EACA,oEAAA;AFuEJ;AGlII;EHfJ;IGgBM,6BAAA;EHqIJ;AACF;;AAlJA;EACE,kBAAA;EACA,MAAA;EACA,YAAA;EACA,WAAA;EACA,gBAAA;EACA,UAAA;EACA,aAAA;EACA,uBAAA;EACA,6CAAA;EACA,gBAAA;AAqJF;;AAlJA;EACE,kBAAA;EACA,WAAA;EACA,WAAA;AAqJF",sourcesContent:["/* add css module styles here (optional) */\n@use '@onfido/castor';\n\n:root {\n  @include castor.day();\n}\n\n.wrapper {\n  position: absolute;\n  top: 0;\n  height: 100%;\n  width: 100%;\n  max-height: 100%;\n  padding: 0;\n  display: flex;\n  justify-content: center;\n  border-radius: var(--ods-border-radius-large);\n  overflow: hidden;\n}\n\n.navigationBar {\n  position: absolute;\n  width: 100%;\n  z-index: 10;\n}\n","// generated by Theo (https://github.com/salesforce-ux/theo)\n\n@mixin tokens() {\n  --ods-transition-duration: 0.15s;\n  --ods-border-radius-small: 2px;\n  --ods-border-radius-medium: 4px;\n  --ods-border-radius-large: 8px;\n  --ods-border-radius-full: 100vw;\n  --ods-color-neutral-900: 30, 30, 36;\n  --ods-color-neutral-800: 43, 45, 51;\n  --ods-color-neutral-700: 71, 73, 82;\n  --ods-color-neutral-600: 99, 102, 112;\n  --ods-color-neutral-500: 130, 136, 147;\n  --ods-color-neutral-400: 180, 186, 197;\n  --ods-color-neutral-300: 213, 218, 224;\n  --ods-color-neutral-200: 233, 236, 240;\n  --ods-color-neutral-100: 247, 249, 250;\n  --ods-color-neutral-050: 252, 252, 253;\n  --ods-color-neutral-white: 255, 255, 255;\n  --ods-color-neutral-black: 0, 0, 0;\n  --ods-color-primary-700: 28, 19, 101;\n  --ods-color-primary-600: 35, 42, 173;\n  --ods-color-primary-500: 54, 64, 245;\n  --ods-color-primary-400: 92, 108, 255;\n  --ods-color-primary-300: 130, 143, 255;\n  --ods-color-primary-200: 189, 195, 255;\n  --ods-color-primary-100: 235, 237, 255;\n  --ods-color-primary-050: 245, 246, 255;\n  --ods-color-primary-muted-600: 101, 105, 160;\n  --ods-color-primary-muted-300: 149, 185, 255;\n  --ods-color-accent-1-600: 255, 100, 100;\n  --ods-color-accent-1-500: 255, 137, 125;\n  --ods-color-accent-1-400: 255, 172, 163;\n  --ods-color-accent-2-600: 249, 178, 20;\n  --ods-color-accent-2-500: 255, 221, 84;\n  --ods-color-accent-2-400: 255, 236, 112;\n  --ods-color-accent-3-600: 129, 35, 173;\n  --ods-color-accent-3-500: 175, 95, 239;\n  --ods-color-accent-3-400: 222, 189, 255;\n  --ods-color-success-600: 0, 107, 36;\n  --ods-color-success-500: 5, 125, 39;\n  --ods-color-success-400: 21, 179, 18;\n  --ods-color-success-300: 81, 209, 123;\n  --ods-color-success-200: 157, 239, 184;\n  --ods-color-success-100: 203, 248, 218;\n  --ods-color-success-050: 236, 253, 241;\n  --ods-color-success-vivid-300: 145, 232, 123;\n  --ods-color-success-muted-500: 108, 137, 94;\n  --ods-color-success-muted-300: 137, 211, 163;\n  --ods-color-info-700: 28, 19, 101;\n  --ods-color-info-600: 35, 42, 173;\n  --ods-color-info-500: 54, 64, 245;\n  --ods-color-info-400: 92, 108, 255;\n  --ods-color-info-300: 130, 143, 255;\n  --ods-color-info-200: 189, 195, 255;\n  --ods-color-info-100: 235, 237, 255;\n  --ods-color-info-050: 245, 246, 255;\n  --ods-color-info-muted-600: 101, 105, 160;\n  --ods-color-info-muted-300: 149, 185, 255;\n  --ods-color-warning-600: 158, 75, 8;\n  --ods-color-warning-500: 196, 107, 4;\n  --ods-color-warning-400: 227, 133, 25;\n  --ods-color-warning-300: 251, 194, 127;\n  --ods-color-warning-200: 250, 218, 181;\n  --ods-color-warning-100: 253, 237, 219;\n  --ods-color-warning-050: 255, 245, 235;\n  --ods-color-warning-vivid-300: 253, 168, 70;\n  --ods-color-warning-muted-500: 150, 125, 96;\n  --ods-color-warning-muted-300: 235, 193, 144;\n  --ods-color-error-600: 170, 0, 0;\n  --ods-color-error-500: 195, 47, 47;\n  --ods-color-error-400: 245, 78, 78;\n  --ods-color-error-300: 252, 123, 123;\n  --ods-color-error-200: 255, 185, 185;\n  --ods-color-error-100: 252, 229, 229;\n  --ods-color-error-050: 255, 246, 246;\n  --ods-color-error-muted-500: 152, 93, 97;\n  --ods-color-error-muted-300: 239, 169, 169;\n}\n","// generated by Theo (https://github.com/salesforce-ux/theo)\n\n@use './theme' as castor;\n\n@mixin day($types...) {\n  @include castor.theme('day', $types...) {\n    color-scheme: light;\n\n    --ods-color-content-main: var(--ods-color-neutral-800), 1;\n    --ods-color-content-secondary: var(--ods-color-neutral-600), 1;\n    --ods-color-content-action: var(--ods-color-primary-500), 1;\n    --ods-color-content-placeholder: var(--ods-color-neutral-500), 1;\n    --ods-color-content-disabled: var(--ods-color-neutral-500), 1;\n    --ods-color-content-link: var(--ods-color-primary-500), 1;\n    --ods-color-content-link-hover: var(--ods-color-primary-600), 1;\n    --ods-color-content-link-visited: var(--ods-color-accent-3-600), 1;\n    --ods-color-content-negative: var(--ods-color-error-500), 1;\n    --ods-color-content-warning: var(--ods-color-warning-600), 1;\n    --ods-color-content-positive: var(--ods-color-success-500), 1;\n    --ods-color-content-info: var(--ods-color-info-500), 1;\n    --ods-color-content-spinner: var(--ods-color-neutral-600), 1;\n    --ods-color-content-progress: var(--ods-color-primary-500), 1;\n    --ods-color-content-logo: var(--ods-color-primary-500), 1;\n    --ods-color-content-inverse-main: var(--ods-color-neutral-100), 1;\n    --ods-color-content-inverse-secondary: var(--ods-color-neutral-300), 1;\n    --ods-color-content-on-action: var(--ods-color-neutral-100), 1;\n    --ods-color-content-on-inverse-action: var(--ods-color-primary-500), 1;\n    --ods-color-content-always-light: var(--ods-color-neutral-100), 1;\n    --ods-color-content-always-dark: var(--ods-color-neutral-800), 1;\n    --ods-color-background-main: var(--ods-color-neutral-100), 1;\n    --ods-color-background-surface: var(--ods-color-neutral-050), 1;\n    --ods-color-background-surface-alt: var(--ods-color-neutral-200), 1;\n    --ods-color-background-action: var(--ods-color-primary-500), 1;\n    --ods-color-background-action-hover: var(--ods-color-primary-400), 1;\n    --ods-color-background-action-active: var(--ods-color-primary-600), 1;\n    --ods-color-background-action-subtle: var(--ods-color-primary-500), 0.1;\n    --ods-color-background-action-subtle-hover: var(--ods-color-primary-500), 0.05;\n    --ods-color-background-disabled: var(--ods-color-neutral-200), 1;\n    --ods-color-background-negative: var(--ods-color-error-500), 1;\n    --ods-color-background-negative-hover: var(--ods-color-error-400), 1;\n    --ods-color-background-negative-active: var(--ods-color-error-600), 1;\n    --ods-color-background-negative-subtle: var(--ods-color-error-500), 0.1;\n    --ods-color-background-negative-subtle-hover: var(--ods-color-error-500), 0.05;\n    --ods-color-background-warning: var(--ods-color-warning-400), 1;\n    --ods-color-background-warning-subtle: var(--ods-color-warning-400), 0.1;\n    --ods-color-background-positive: var(--ods-color-success-400), 1;\n    --ods-color-background-positive-subtle: var(--ods-color-success-400), 0.1;\n    --ods-color-background-info: var(--ods-color-info-500), 1;\n    --ods-color-background-info-subtle: var(--ods-color-info-500), 0.1;\n    --ods-color-background-input: var(--ods-color-neutral-050), 1;\n    --ods-color-background-input-selected: var(--ods-color-primary-500), 1;\n    --ods-color-background-spinner: var(--ods-color-neutral-600), 0.15;\n    --ods-color-background-progress: var(--ods-color-primary-500), 0.15;\n    --ods-color-background-overlay: var(--ods-color-neutral-black), 0.8;\n    --ods-color-background-overlay-subtle: var(--ods-color-neutral-black), 0.5;\n    --ods-color-background-inverse-main: var(--ods-color-neutral-900), 1;\n    --ods-color-background-inverse-surface: var(--ods-color-neutral-800), 1;\n    --ods-color-background-inverse-action: var(--ods-color-neutral-white), 1;\n    --ods-color-border-separator: var(--ods-color-neutral-200), 1;\n    --ods-color-border-input: var(--ods-color-neutral-500), 1;\n    --ods-color-border-input-hover: var(--ods-color-neutral-600), 1;\n    --ods-color-border-action: var(--ods-color-primary-500), 1;\n    --ods-color-border-action-hover: var(--ods-color-primary-400), 1;\n    --ods-color-border-action-subtle: var(--ods-color-primary-200), 1;\n    --ods-color-border-disabled: var(--ods-color-neutral-200), 1;\n    --ods-color-border-negative: var(--ods-color-error-500), 1;\n    --ods-color-border-negative-subtle: var(--ods-color-error-200), 1;\n    --ods-color-border-warning: var(--ods-color-warning-400), 1;\n    --ods-color-border-warning-subtle: var(--ods-color-warning-muted-300), 1;\n    --ods-color-border-positive: var(--ods-color-success-500), 1;\n    --ods-color-border-positive-subtle: var(--ods-color-success-muted-300), 1;\n    --ods-color-border-info: var(--ods-color-info-500), 1;\n    --ods-color-border-info-subtle: var(--ods-color-info-200), 1;\n    --ods-color-border-input-selected: var(--ods-color-primary-500), 1;\n    --ods-color-border-focus-inner: var(--ods-color-neutral-white), 1;\n    --ods-color-border-action-focus: var(--ods-color-primary-600), 1;\n    --ods-color-border-negative-focus: var(--ods-color-error-600), 1;\n    --ods-color-border-inverse-action: var(--ods-color-neutral-white), 1;\n  }\n}\n","@use 'sass:list';\n@use './mixins';\n@use './tokens' as castor;\n\n// ...$types: 'class' | 'raw';\n@mixin theme($name, $types...) {\n  $class: list.index($types, 'class');\n  $raw: list.index($types, 'raw');\n\n  $selector: if($class, '.castor-theme--#{$name}', null);\n\n  @include mixins.wrap-if($selector) {\n    @if not $raw {\n      @include castor.tokens();\n    }\n\n    @content;\n\n    @media (prefers-reduced-motion) {\n      --ods-transition-duration: 0s;\n    }\n  }\n}\n"],sourceRoot:""}]),o.locals={wrapper:"moGGhyFLGbgs8kh1ppcD",navigationBar:"li3CiV7LuPwFrzBsZSNw"};const i=o},"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/Alert/style.module.scss":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/Alert/style.module.scss ***!
  \*****************************************************************************************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var r=n(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */"./node_modules/css-loader/dist/runtime/sourceMaps.js"),a=n.n(r),s=n(/*! ../../../node_modules/css-loader/dist/runtime/api.js */"./node_modules/css-loader/dist/runtime/api.js"),o=n.n(s)()(a());o.push([e.id,'.LWAC8_HA8EXcrJmAqImz {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  padding: 16px;\n  z-index: 11;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity 0.2s ease-in;\n}\n.LWAC8_HA8EXcrJmAqImz::before {\n  content: "";\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(var(--ods-color-neutral-900), 1);\n  opacity: 0.85;\n  z-index: -1;\n}\n\n.BeasPdHt0dkLfy03nD56 {\n  opacity: 1;\n  visibility: visible;\n}\n\n.B8Ciq3JRQo3JDJiGWczS {\n  max-width: 350px;\n  background: rgba(var(--ods-color-neutral-white), 1);\n  border-radius: var(--ods-border-radius-large);\n  padding: 24px;\n  box-sizing: border-box;\n}\n.B8Ciq3JRQo3JDJiGWczS button {\n  width: 100%;\n}\n\n.TgF4OL_KLAroscTLSeqR {\n  font-family: inherit;\n  font-size: 1.25rem;\n  font-weight: 500;\n  line-height: 1.5rem;\n  text-transform: none;\n  color: rgba(var(--ods-color-content-main));\n  margin: 0;\n}\n\n.RUXGfS2ybtCAFTkJuOSI {\n  font-family: inherit;\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5rem;\n  text-transform: none;\n  margin-bottom: 24px;\n  color: rgba(var(--ods-color-content-secondary));\n}',"",{version:3,sources:["webpack://./src/components/Alert/style.module.scss","webpack://./node_modules/@onfido/castor/src/helpers/font/font.scss"],names:[],mappings:"AAEA;EACE,kBAAA;EACA,OAAA;EACA,MAAA;EACA,WAAA;EACA,YAAA;EACA,aAAA;EACA,WAAA;EACA,aAAA;EACA,mBAAA;EACA,uBAAA;EACA,sBAAA;EACA,UAAA;EACA,kBAAA;EACA,gCAAA;AADF;AAGE;EACE,WAAA;EACA,kBAAA;EACA,OAAA;EACA,MAAA;EACA,QAAA;EACA,SAAA;EACA,iDAAA;EACA,aAAA;EACA,WAAA;AADJ;;AAKA;EACE,UAAA;EACA,mBAAA;AAFF;;AAKA;EACE,gBAAA;EACA,mDAAA;EACA,6CAAA;EACA,aAAA;EACA,sBAAA;AAFF;AAIE;EACE,WAAA;AAFJ;;AAMA;EC0DE,oBAAA;EACA,kBAAA;EACA,gBAAA;EACA,mBAAA;EACA,oBAAA;ED5DA,0CAAA;EACA,SAAA;AACF;;AAEA;ECoDE,oBAAA;EACA,eAAA;EACA,gBAAA;EACA,mBAAA;EACA,oBAAA;EDtDA,mBAAA;EACA,+CAAA;AAKF",sourcesContent:["@use '@onfido/castor';\n\n.alert {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  padding: castor.space(2);\n  z-index: 11;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity 0.2s ease-in;\n\n  &::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    background: castor.color('neutral-900');\n    opacity: 0.85;\n    z-index: -1;\n  }\n}\n\n.visible {\n  opacity: 1;\n  visibility: visible;\n}\n\n.container {\n  max-width: 350px;\n  background: castor.color('neutral-white');\n  border-radius: castor.border-radius('large');\n  padding: castor.space(3);\n  box-sizing: border-box;\n\n  button {\n    width: 100%;\n  }\n}\n\n.title {\n  @include castor.font('400-bold');\n  color: castor.color('content-main');\n  margin: 0;\n}\n\n.message {\n  @include castor.font('300-regular');\n  margin-bottom: castor.space(3);\n  color: castor.color('content-secondary');\n}\n","@use 'sass:list';\n@use 'sass:map';\n@use 'sass:string';\n\n$_allowed-combinations: (\n  '800-bold',\n  '700-bold',\n  '600-bold',\n  '500-bold',\n  '400-bold',\n  '300-bold',\n  '200-bold',\n  '100-bold',\n  '800-regular',\n  '700-regular',\n  '600-regular',\n  '500-regular',\n  '400-regular',\n  '300-regular',\n  '200-regular',\n  '100-regular',\n  '800-light',\n  '700-light',\n  '600-light',\n  '500-light',\n  '400-allcaps',\n  '300-allcaps',\n  '200-allcaps',\n  '100-allcaps',\n  '400-mono',\n  '300-mono',\n  '200-mono'\n);\n\n$_sizes: (\n  '800': (\n    font-size: 3.375rem,\n    line-height: 4rem,\n  ),\n  '700': (\n    font-size: 2.875rem,\n    line-height: 3.5rem,\n  ),\n  '600': (\n    font-size: 1.875rem,\n    line-height: 2.5rem,\n  ),\n  '500': (\n    font-size: 1.5rem,\n    line-height: 2rem,\n  ),\n  '400': (\n    font-size: 1.25rem,\n    line-height: 1.5rem,\n  ),\n  '300': (\n    font-size: 1rem,\n    line-height: 1.5rem,\n  ),\n  '200': (\n    font-size: 0.875rem,\n    line-height: 1.5rem,\n  ),\n  '100': (\n    font-size: 0.75rem,\n    line-height: 1rem,\n  ),\n);\n\n$_types: (\n  'bold': (\n    font-weight: 500,\n  ),\n  'regular': (\n    font-weight: 400,\n  ),\n  'light': (\n    font-weight: 300,\n  ),\n  'allcaps': (\n    text-transform: uppercase,\n  ),\n  'mono': (\n    font-family: string.unquote('\"Roboto Mono\", Consolas, Menlo, monospace'),\n  ),\n);\n\n@mixin font($name) {\n  @if not list.index($_allowed-combinations, $name) {\n    @error 'Font token not supported: #{$name}';\n  }\n\n  $styles: ();\n\n  @if $name {\n    $separator-index: string.index($name, '-');\n\n    $size-key: string.slice($name, 1, $separator-index - 1);\n    $size-styles: map.get($_sizes, $size-key);\n    $styles: map.merge($styles, $size-styles);\n\n    $type-key: string.slice($name, $separator-index + 1);\n    $type-styles: map.get($_types, $type-key);\n    $styles: map.merge($styles, $type-styles);\n  }\n\n  font-family: _get-or-default($styles, font-family, inherit);\n  font-size: _get-or-default($styles, font-size, initial);\n  font-weight: _get-or-default($styles, font-weight, initial);\n  line-height: _get-or-default($styles, line-height, initial);\n  text-transform: _get-or-default($styles, text-transform, none);\n}\n\n@function _get-or-default($map, $key, $default) {\n  @if map.has-key($map, $key) {\n    @return map.get($map, $key);\n  }\n\n  @return $default;\n}\n"],sourceRoot:""}]),o.locals={alert:"LWAC8_HA8EXcrJmAqImz",visible:"BeasPdHt0dkLfy03nD56",container:"B8Ciq3JRQo3JDJiGWczS",title:"TgF4OL_KLAroscTLSeqR",message:"RUXGfS2ybtCAFTkJuOSI"};const i=o},"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/Button/style.module.scss":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/Button/style.module.scss ***!
  \******************************************************************************************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var r=n(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */"./node_modules/css-loader/dist/runtime/sourceMaps.js"),a=n.n(r),s=n(/*! ../../../node_modules/css-loader/dist/runtime/api.js */"./node_modules/css-loader/dist/runtime/api.js"),o=n.n(s)()(a());o.push([e.id,".wpj84BbdxhdGDOzrwFjB {\n  padding: 11px 23px;\n  /* stylelint-disable-next-line declaration-property-value-disallowed-list */\n  border: none;\n  background-color: rgba(var(--ods-color-background-action));\n  color: rgba(var(--ods-color-content-on-action));\n  border-radius: var(--ods-border-radius-medium);\n  font-family: inherit;\n  font-size: 1rem;\n  user-select: none;\n  appearance: none;\n  border: 1px solid rgba(0, 0, 0, 0);\n  box-sizing: border-box;\n  position: relative;\n  text-decoration: none;\n  width: fit-content;\n  min-width: 272px;\n  min-height: 48px;\n  cursor: pointer;\n  outline: none;\n}\n.wpj84BbdxhdGDOzrwFjB:hover {\n  background-color: rgba(var(--ods-color-background-action-hover));\n}","",{version:3,sources:["webpack://./src/components/Button/style.module.scss"],names:[],mappings:"AAEA;EACE,kBAAA;EACA,2EAAA;EACA,YAAA;EACA,0DAAA;EACA,+CAAA;EACA,8CAAA;EACA,oBAAA;EACA,eAAA;EACA,iBAAA;EACA,gBAAA;EACA,kCAAA;EACA,sBAAA;EACA,kBAAA;EACA,qBAAA;EACA,kBAAA;EACA,gBAAA;EACA,gBAAA;EACA,eAAA;EACA,aAAA;AADF;AAGE;EACE,gEAAA;AADJ",sourcesContent:["@use '@onfido/castor';\n\n.button {\n  padding: 11px 23px;\n  /* stylelint-disable-next-line declaration-property-value-disallowed-list */\n  border: none;\n  background-color: rgba(var(--ods-color-background-action));\n  color: rgba(var(--ods-color-content-on-action));\n  border-radius: var(--ods-border-radius-medium);\n  font-family: inherit;\n  font-size: 1rem;\n  user-select: none;\n  appearance: none;\n  border: 1px solid rgba(0, 0, 0, 0);\n  box-sizing: border-box;\n  position: relative;\n  text-decoration: none;\n  width: fit-content;\n  min-width: 272px;\n  min-height: 48px;\n  cursor: pointer;\n  outline: none;\n\n  &:hover {\n    background-color: rgba(var(--ods-color-background-action-hover));\n  }\n}\n"],sourceRoot:""}]),o.locals={button:"wpj84BbdxhdGDOzrwFjB"};const i=o},"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/DebugFrame/style.module.scss":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/DebugFrame/style.module.scss ***!
  \**********************************************************************************************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var r=n(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */"./node_modules/css-loader/dist/runtime/sourceMaps.js"),a=n.n(r),s=n(/*! ../../../node_modules/css-loader/dist/runtime/api.js */"./node_modules/css-loader/dist/runtime/api.js"),o=n.n(s)()(a());o.push([e.id,".HfelweMQbL4AYhflXMp5 {\n  border: 1px solid #ff0;\n  z-index: 1;\n  position: absolute;\n}\n\n.aBmXxSRvouptO27LB081 {\n  position: absolute;\n  border: 2px solid;\n  z-index: 1;\n  pointer-events: none;\n}\n\n.B7BIsknPnODDRjs49eur {\n  font-weight: bold;\n}\n\n.jW9dQf9ZLYJlVP6JAIYQ {\n  position: absolute;\n  height: 100%;\n  left: 50%;\n  transform: translateX(-50%);\n  z-index: 10;\n  pointer-events: none;\n}","",{version:3,sources:["webpack://./src/components/DebugFrame/style.module.scss"],names:[],mappings:"AAEA;EACE,sBAAA;EACA,UAAA;EACA,kBAAA;AADF;;AAIA;EACE,kBAAA;EACA,iBAAA;EACA,UAAA;EACA,oBAAA;AADF;;AAIA;EACE,iBAAA;AADF;;AAIA;EACE,kBAAA;EACA,YAAA;EACA,SAAA;EACA,2BAAA;EACA,WAAA;EACA,oBAAA;AADF",sourcesContent:["@use '@onfido/castor';\n\n.centerBounds {\n  border: 1px solid #ff0;\n  z-index: 1;\n  position: absolute;\n}\n\n.faceBounds {\n  position: absolute;\n  border: 2px solid;\n  z-index: 1;\n  pointer-events: none;\n}\n\n.warningMessage {\n  font-weight: bold;\n}\n\n.portraitDebugging {\n  position: absolute;\n  height: 100%;\n  left: 50%;\n  transform: translateX(-50%);\n  z-index: 10;\n  pointer-events: none;\n}\n"],sourceRoot:""}]),o.locals={centerBounds:"HfelweMQbL4AYhflXMp5",faceBounds:"aBmXxSRvouptO27LB081",warningMessage:"B7BIsknPnODDRjs49eur",portraitDebugging:"jW9dQf9ZLYJlVP6JAIYQ"};const i=o},"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/DebugStats/style.module.scss":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/DebugStats/style.module.scss ***!
  \**********************************************************************************************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var r=n(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */"./node_modules/css-loader/dist/runtime/sourceMaps.js"),a=n.n(r),s=n(/*! ../../../node_modules/css-loader/dist/runtime/api.js */"./node_modules/css-loader/dist/runtime/api.js"),o=n.n(s)()(a());o.push([e.id,".q60p6QD3yq8AGwhPxjFN {\n  position: fixed;\n  left: 0;\n  background-color: rgba(0, 0, 0, 0.8);\n  color: #fff;\n  font-size: 16px;\n  width: 150px;\n  margin-left: 3px;\n  padding: 4px 8px;\n  z-index: 20;\n}","",{version:3,sources:["webpack://./src/components/DebugStats/style.module.scss"],names:[],mappings:"AAEA;EACE,eAAA;EACA,OAAA;EACA,oCAAA;EACA,WAAA;EACA,eAAA;EACA,YAAA;EACA,gBAAA;EACA,gBAAA;EACA,WAAA;AADF",sourcesContent:["@use '@onfido/castor';\n\n.debug {\n  position: fixed;\n  left: 0;\n  background-color: rgba($color: #000, $alpha: 0.8);\n  color: #fff;\n  font-size: 16px;\n  width: 150px;\n  margin-left: 3px;\n  padding: 4px 8px;\n  z-index: 20;\n}\n"],sourceRoot:""}]),o.locals={debug:"q60p6QD3yq8AGwhPxjFN"};const i=o},"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/ProgressBars/style.module.scss":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/ProgressBars/style.module.scss ***!
  \************************************************************************************************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var r=n(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */"./node_modules/css-loader/dist/runtime/sourceMaps.js"),a=n.n(r),s=n(/*! ../../../node_modules/css-loader/dist/runtime/api.js */"./node_modules/css-loader/dist/runtime/api.js"),o=n.n(s)()(a());o.push([e.id,'.SRntH7COs1_g87HG4q4c {\n  display: flex;\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n.RMAs2D5FuXihhjjBmOsu {\n  padding: 0 8px;\n  position: relative;\n}\n.RMAs2D5FuXihhjjBmOsu .FMrqWS5Mdwxw94mZL1qe {\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  z-index: 105;\n}\n.RMAs2D5FuXihhjjBmOsu .FMrqWS5Mdwxw94mZL1qe svg {\n  overflow: visible;\n}\n.RMAs2D5FuXihhjjBmOsu.VyrNbwDhrfcy11yTXOH3 .FMrqWS5Mdwxw94mZL1qe path {\n  stroke: rgba(var(--ods-color-success-300), 1);\n  stroke-width: 6px;\n}\n.RMAs2D5FuXihhjjBmOsu::before, .RMAs2D5FuXihhjjBmOsu::after {\n  content: "";\n  display: block;\n  position: absolute;\n  left: calc(100% - 8px);\n  height: 5px;\n  background: rgba(var(--ods-color-success-300), 1);\n  transition: width 0.5s ease 0.2s;\n  width: 0;\n}\n.RMAs2D5FuXihhjjBmOsu::before {\n  top: 0;\n}\n.RMAs2D5FuXihhjjBmOsu::after {\n  bottom: 0;\n}\n.RMAs2D5FuXihhjjBmOsu.SAwenvETyB_nUp4tinCZ::before, .RMAs2D5FuXihhjjBmOsu.SAwenvETyB_nUp4tinCZ::after {\n  width: 8px;\n}\n.RMAs2D5FuXihhjjBmOsu .VmwffCV5pt93vn88Bbmr,\n.RMAs2D5FuXihhjjBmOsu .huGDQ1Lkt8hiAYTDQ_Np {\n  stroke: rgba(var(--ods-color-neutral-white), 1);\n  stroke-width: 4px;\n  stroke-linecap: round;\n  stroke-dashoffset: 280;\n  stroke-dasharray: 280;\n  transition: 0.2s cubic-bezier(0, 0.21, 0.36, 0.96);\n  fill: transparent;\n}\n.RMAs2D5FuXihhjjBmOsu .UQeZY1Jy8WuxDJwO_nKX {\n  transform: scaleY(-1);\n}\n.RMAs2D5FuXihhjjBmOsu .o2iAvDlIZwDShseVKpwZ {\n  position: absolute;\n  z-index: 101;\n  display: flex;\n  flex-direction: column;\n  top: 0;\n  padding-left: 1px;\n}\n.RMAs2D5FuXihhjjBmOsu .o2iAvDlIZwDShseVKpwZ svg {\n  overflow: hidden;\n}\n.RMAs2D5FuXihhjjBmOsu .o2iAvDlIZwDShseVKpwZ path {\n  stroke: rgba(var(--ods-color-neutral-white), 1);\n  stroke-linecap: round;\n  stroke-width: 4px;\n  opacity: 0.15;\n}\n\n.LGEoBSYKSmS12gxAW6Wy {\n  transform: scale(-1, 1);\n  padding: 0 8px;\n  position: relative;\n}\n.LGEoBSYKSmS12gxAW6Wy .FMrqWS5Mdwxw94mZL1qe {\n  position: relative;\n  z-index: 105;\n  display: flex;\n  flex-direction: column;\n}\n.LGEoBSYKSmS12gxAW6Wy .FMrqWS5Mdwxw94mZL1qe svg {\n  overflow: visible;\n}\n.LGEoBSYKSmS12gxAW6Wy.VyrNbwDhrfcy11yTXOH3 path {\n  stroke: rgba(var(--ods-color-success-300), 1);\n  stroke-width: 6px;\n}\n.LGEoBSYKSmS12gxAW6Wy::before, .LGEoBSYKSmS12gxAW6Wy::after {\n  content: "";\n  display: block;\n  position: absolute;\n  left: calc(100% - 8px);\n  height: 5px;\n  background: rgba(var(--ods-color-success-300), 1);\n  transition: width 0.5s ease 0.2s;\n  width: 0;\n}\n.LGEoBSYKSmS12gxAW6Wy::before {\n  top: 0;\n}\n.LGEoBSYKSmS12gxAW6Wy::after {\n  bottom: 0;\n}\n.LGEoBSYKSmS12gxAW6Wy.SAwenvETyB_nUp4tinCZ::before, .LGEoBSYKSmS12gxAW6Wy.SAwenvETyB_nUp4tinCZ::after {\n  width: 8px;\n}\n.LGEoBSYKSmS12gxAW6Wy .VmwffCV5pt93vn88Bbmr,\n.LGEoBSYKSmS12gxAW6Wy .huGDQ1Lkt8hiAYTDQ_Np {\n  stroke: rgba(var(--ods-color-neutral-white), 1);\n  stroke-width: 4px;\n  stroke-dasharray: 280;\n  stroke-linecap: round;\n  stroke-dashoffset: 280;\n  transition: 0.2s cubic-bezier(0, 0.21, 0.36, 0.96);\n  fill: transparent;\n}\n.LGEoBSYKSmS12gxAW6Wy .UQeZY1Jy8WuxDJwO_nKX {\n  transform: scaleY(-1);\n}\n.LGEoBSYKSmS12gxAW6Wy .o2iAvDlIZwDShseVKpwZ {\n  position: absolute;\n  z-index: 101;\n  top: 0;\n  display: flex;\n  flex-direction: column;\n}\n.LGEoBSYKSmS12gxAW6Wy .o2iAvDlIZwDShseVKpwZ svg {\n  overflow: hidden;\n}\n.LGEoBSYKSmS12gxAW6Wy .o2iAvDlIZwDShseVKpwZ path {\n  stroke: rgba(var(--ods-color-neutral-white), 1);\n  stroke-linecap: round;\n  stroke-width: 4px;\n  opacity: 0.15;\n}\n\n.V9ylQH61ansRDbsvgwXo {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  opacity: 0;\n  transition: opacity 0.2s cubic-bezier(0, 0.36, 0.35, 1);\n}\n.V9ylQH61ansRDbsvgwXo.fbq7xAziEL3xctktUsbu {\n  opacity: 1;\n}',"",{version:3,sources:["webpack://./src/components/ProgressBars/style.module.scss"],names:[],mappings:"AAMA;EACE,aAAA;EACA,kBAAA;EACA,SAAA;EACA,2BAAA;AALF;;AAQA;EACE,cAAA;EACA,kBAAA;AALF;AAOE;EACE,aAAA;EACA,sBAAA;EACA,kBAAA;EACA,YAAA;AALJ;AAOI;EACE,iBAAA;AALN;AAWM;EACE,6CAAA;EACA,iBA7Be;AAoBvB;AAcE;EAEE,WAAA;EACA,cAAA;EACA,kBAAA;EACA,sBAAA;EACA,WAAA;EACA,iDAAA;EACA,gCAAA;EACA,QAAA;AAbJ;AAgBE;EACE,MAAA;AAdJ;AAiBE;EACE,SAAA;AAfJ;AAmBI;EAEE,UAAA;AAlBN;AAsBE;;EAEE,+CAAA;EACA,iBAjEW;EAkEX,qBAAA;EACA,sBAAA;EACA,qBAAA;EACA,kDAnES;EAoET,iBAAA;AApBJ;AAwBI;EACE,qBAAA;AAtBN;AA0BE;EACE,kBAAA;EACA,YAAA;EACA,aAAA;EACA,sBAAA;EACA,MAAA;EACA,iBAAA;AAxBJ;AA0BI;EACE,gBAAA;AAxBN;AA2BI;EACE,+CAAA;EACA,qBAAA;EACA,iBA9FS;EA+FT,aAAA;AAzBN;;AA8BA;EACE,uBAAA;EACA,cAAA;EACA,kBAAA;AA3BF;AA6BE;EACE,kBAAA;EACA,YAAA;EACA,aAAA;EACA,sBAAA;AA3BJ;AA6BI;EACE,iBAAA;AA3BN;AAgCI;EACE,6CAAA;EACA,iBAtHiB;AAwFvB;AAkCE;EAEE,WAAA;EACA,cAAA;EACA,kBAAA;EACA,sBAAA;EACA,WAAA;EACA,iDAAA;EACA,gCAAA;EACA,QAAA;AAjCJ;AAoCE;EACE,MAAA;AAlCJ;AAqCE;EACE,SAAA;AAnCJ;AAuCI;EAEE,UAAA;AAtCN;AA0CE;;EAEE,+CAAA;EACA,iBAzJW;EA0JX,qBAAA;EACA,qBAAA;EACA,sBAAA;EACA,kDA3JS;EA4JT,iBAAA;AAxCJ;AA4CI;EACE,qBAAA;AA1CN;AA8CE;EACE,kBAAA;EACA,YAAA;EACA,MAAA;EACA,aAAA;EACA,sBAAA;AA5CJ;AA8CI;EACE,gBAAA;AA5CN;AA+CI;EACE,+CAAA;EACA,qBAAA;EACA,iBArLS;EAsLT,aAAA;AA7CN;;AAkDA;EACE,kBAAA;EACA,SAAA;EACA,QAAA;EACA,gCAAA;EACA,UAAA;EACA,uDAAA;AA/CF;AAiDE;EACE,UAAA;AA/CJ",sourcesContent:["@use '@onfido/castor';\n\n$stroke-width: 4px;\n$success-stroke-width: 6px;\n$transition: 0.2s cubic-bezier(0, 0.21, 0.36, 0.96);\n\n.progressWrapper {\n  display: flex;\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n.leftProgressWrapper {\n  padding: 0 8px;\n  position: relative;\n\n  .progressLines {\n    display: flex;\n    flex-direction: column;\n    position: relative;\n    z-index: 105;\n\n    svg {\n      overflow: visible;\n    }\n  }\n\n  &.finished {\n    .progressLines {\n      path {\n        stroke: castor.color('success-300');\n        stroke-width: $success-stroke-width;\n      }\n    }\n  }\n\n  &::before,\n  &::after {\n    content: '';\n    display: block;\n    position: absolute;\n    left: calc(100% - 8px);\n    height: 5px;\n    background: castor.color('success-300');\n    transition: width 0.5s ease 0.2s;\n    width: 0;\n  }\n\n  &::before {\n    top: 0;\n  }\n\n  &::after {\n    bottom: 0;\n  }\n\n  &.final {\n    &::before,\n    &::after {\n      width: 8px;\n    }\n  }\n\n  .top,\n  .bottom {\n    stroke: castor.color('neutral-white');\n    stroke-width: $stroke-width;\n    stroke-linecap: round;\n    stroke-dashoffset: 280;\n    stroke-dasharray: 280;\n    transition: $transition;\n    fill: transparent;\n  }\n\n  .bottom {\n    &Wrapper {\n      transform: scaleY(-1);\n    }\n  }\n\n  .placeholder {\n    position: absolute;\n    z-index: 101;\n    display: flex;\n    flex-direction: column;\n    top: 0;\n    padding-left: 1px;\n\n    svg {\n      overflow: hidden;\n    }\n\n    path {\n      stroke: castor.color('neutral-white');\n      stroke-linecap: round;\n      stroke-width: $stroke-width;\n      opacity: 0.15;\n    }\n  }\n}\n\n.rightProgressWrapper {\n  transform: scale(-1, 1);\n  padding: 0 8px;\n  position: relative;\n\n  .progressLines {\n    position: relative;\n    z-index: 105;\n    display: flex;\n    flex-direction: column;\n\n    svg {\n      overflow: visible;\n    }\n  }\n\n  &.finished {\n    path {\n      stroke: castor.color('success-300');\n      stroke-width: $success-stroke-width;\n    }\n  }\n\n  &::before,\n  &::after {\n    content: '';\n    display: block;\n    position: absolute;\n    left: calc(100% - 8px);\n    height: 5px;\n    background: castor.color('success-300');\n    transition: width 0.5s ease 0.2s;\n    width: 0;\n  }\n\n  &::before {\n    top: 0;\n  }\n\n  &::after {\n    bottom: 0;\n  }\n\n  &.final {\n    &::before,\n    &::after {\n      width: 8px;\n    }\n  }\n\n  .top,\n  .bottom {\n    stroke: castor.color('neutral-white');\n    stroke-width: $stroke-width;\n    stroke-dasharray: 280;\n    stroke-linecap: round;\n    stroke-dashoffset: 280;\n    transition: $transition;\n    fill: transparent;\n  }\n\n  .bottom {\n    &Wrapper {\n      transform: scaleY(-1);\n    }\n  }\n\n  .placeholder {\n    position: absolute;\n    z-index: 101;\n    top: 0;\n    display: flex;\n    flex-direction: column;\n\n    svg {\n      overflow: hidden;\n    }\n\n    path {\n      stroke: castor.color('neutral-white');\n      stroke-linecap: round;\n      stroke-width: $stroke-width;\n      opacity: 0.15;\n    }\n  }\n}\n\n.checkIcon {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  opacity: 0;\n  transition: opacity 0.2s cubic-bezier(0, 0.36, 0.35, 1);\n\n  &.scanComplete {\n    opacity: 1;\n  }\n}\n"],sourceRoot:""}]),o.locals={progressWrapper:"SRntH7COs1_g87HG4q4c",leftProgressWrapper:"RMAs2D5FuXihhjjBmOsu",progressLines:"FMrqWS5Mdwxw94mZL1qe",finished:"VyrNbwDhrfcy11yTXOH3",final:"SAwenvETyB_nUp4tinCZ",top:"VmwffCV5pt93vn88Bbmr",bottom:"huGDQ1Lkt8hiAYTDQ_Np",bottomWrapper:"UQeZY1Jy8WuxDJwO_nKX",placeholder:"o2iAvDlIZwDShseVKpwZ",rightProgressWrapper:"LGEoBSYKSmS12gxAW6Wy",checkIcon:"V9ylQH61ansRDbsvgwXo",scanComplete:"fbq7xAziEL3xctktUsbu"};const i=o},"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/VideoFeedback/style.module.scss":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/VideoFeedback/style.module.scss ***!
  \*************************************************************************************************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var r=n(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */"./node_modules/css-loader/dist/runtime/sourceMaps.js"),a=n.n(r),s=n(/*! ../../../node_modules/css-loader/dist/runtime/api.js */"./node_modules/css-loader/dist/runtime/api.js"),o=n.n(s)()(a());o.push([e.id,".EkarLOek9QISSUnOaJ5n {\n  height: auto;\n  position: relative;\n  display: grid;\n  grid-template-columns: 1fr auto 1fr;\n  width: 100%;\n}\n.EkarLOek9QISSUnOaJ5n .mkllVvs9rJmOtMJnU5Vr {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: rgba(var(--ods-color-neutral-black), 1);\n}\n.EkarLOek9QISSUnOaJ5n .mkllVvs9rJmOtMJnU5Vr .XMblQFubM3A88QttoNUj {\n  height: 100%;\n  width: auto;\n  transition: filter 0.1s ease-in;\n  transform: scaleX(-1);\n  transition-delay: 0.5s;\n}\n@media (max-width: 479px) {\n  .EkarLOek9QISSUnOaJ5n .mkllVvs9rJmOtMJnU5Vr .XMblQFubM3A88QttoNUj {\n    width: 480px;\n    height: 640px;\n  }\n}\n\n.cCrDC58vwlcaJDrtjixx {\n  transition: filter 0.2s cubic-bezier(0, 0.36, 0.35, 1);\n  filter: blur(10px);\n}","",{version:3,sources:["webpack://./src/components/VideoFeedback/style.module.scss"],names:[],mappings:"AAEA;EACE,YAAA;EACA,kBAAA;EACA,aAAA;EACA,mCAAA;EACA,WAAA;AADF;AAGE;EACE,kBAAA;EACA,WAAA;EACA,YAAA;EACA,aAAA;EACA,uBAAA;EACA,mBAAA;EACA,yDAAA;AADJ;AAGI;EACE,YAAA;EACA,WAAA;EACA,+BAAA;EACA,qBAAA;EACA,sBAAA;AADN;AAGM;EAPF;IAQI,YAAA;IACA,aAAA;EAAN;AACF;;AAKA;EACE,sDAAA;EACA,kBAAA;AAFF",sourcesContent:["@use '@onfido/castor';\n\n.videoContainer {\n  height: auto;\n  position: relative;\n  display: grid;\n  grid-template-columns: 1fr auto 1fr;\n  width: 100%;\n\n  .videoElementWrapper {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    background-color: castor.color('neutral-black');\n\n    .videoElement {\n      height: 100%;\n      width: auto;\n      transition: filter 0.1s ease-in;\n      transform: scaleX(-1);\n      transition-delay: 0.5s;\n\n      @media (max-width: 479px) {\n        width: 480px;\n        height: 640px;\n      }\n    }\n  }\n}\n\n.scanComplete {\n  transition: filter 0.2s cubic-bezier(0, 0.36, 0.35, 1);\n  filter: blur(10px);\n}\n"],sourceRoot:""}]),o.locals={videoContainer:"EkarLOek9QISSUnOaJ5n",videoElementWrapper:"mkllVvs9rJmOtMJnU5Vr",videoElement:"XMblQFubM3A88QttoNUj",scanComplete:"cCrDC58vwlcaJDrtjixx"};const i=o},"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/VideoFrame/style.module.scss":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/VideoFrame/style.module.scss ***!
  \**********************************************************************************************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>h});var r=n(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */"./node_modules/css-loader/dist/runtime/sourceMaps.js"),a=n.n(r),s=n(/*! ../../../node_modules/css-loader/dist/runtime/api.js */"./node_modules/css-loader/dist/runtime/api.js"),o=n.n(s),i=n(/*! ../../../node_modules/css-loader/dist/runtime/getUrl.js */"./node_modules/css-loader/dist/runtime/getUrl.js"),l=n.n(i),u=new URL('data:image/svg+xml;utf8,<svg viewBox="0 0 205 310" xmlns="http://www.w3.org/2000/svg"><path d="M 102.5 14 C 45.891 14 0 59.891 0 116.5 L 0 207.5 C 0 264.109 45.891 310 102.5 310 C 159.109 310 205 264.109 205 207.5 L 205 116.5 C 205 59.891 159.109 14 102.5 14 Z"/></svg>',"file:///Users/victor.camargo/projects/active-video-capture/src/components/VideoFrame/style.module.scss"),c=o()(a()),d=l()(u);c.push([e.id,"/* stylelint-disable max-nesting-depth, selector-max-compound-selectors */\n.G8nC0Fe3e39ATeycqkKU {\n  display: grid;\n  grid-template-rows: auto 1fr auto;\n  position: absolute;\n  z-index: 1;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n.G8nC0Fe3e39ATeycqkKU .mPLooer9KCt0SimSWTaA {\n  height: 63px;\n  width: 100%;\n  background-color: rgba(30, 30, 36, 0.9);\n}\n.G8nC0Fe3e39ATeycqkKU .ZDw8ABIljdwOkgn5akBH {\n  display: flex;\n  justify-content: center;\n  overflow: hidden;\n  position: relative;\n}\n.G8nC0Fe3e39ATeycqkKU .ZDw8ABIljdwOkgn5akBH .DNZymcM_zTlnKazf7hgF {\n  position: absolute;\n  background-color: rgba(30, 30, 36, 0.9);\n  border-radius: 60px;\n  padding: 16px 24px;\n  font-size: 16px;\n  color: #fff;\n  display: inline-block;\n  left: 50%;\n  top: 50%;\n  z-index: 1;\n  transform: translate(-50%, -50%);\n  white-space: nowrap;\n}\n.G8nC0Fe3e39ATeycqkKU .CZlxLeJ7IHX9vW4yUn0o {\n  --avc-svg-hole: url("+d+");\n  --avc-overlay-color: rgba(30, 30, 36, 0.9);\n  display: grid;\n  grid-template-rows: 1fr auto 1fr;\n  overflow: hidden;\n}\n.G8nC0Fe3e39ATeycqkKU .CZlxLeJ7IHX9vW4yUn0o .yJWHJDQak8hkM8u29kyC,\n.G8nC0Fe3e39ATeycqkKU .CZlxLeJ7IHX9vW4yUn0o .QrfSmYpoW_a4vL3nLwtB,\n.G8nC0Fe3e39ATeycqkKU .CZlxLeJ7IHX9vW4yUn0o .TCtynKtHr6MCVlg_wrJQ,\n.G8nC0Fe3e39ATeycqkKU .CZlxLeJ7IHX9vW4yUn0o .FqW_SlJQnbPm99Av7HE3 {\n  background-color: var(--avc-overlay-color);\n}\n.G8nC0Fe3e39ATeycqkKU .CZlxLeJ7IHX9vW4yUn0o .QRApeBQFGsq3XI_MjOED {\n  display: grid;\n  grid-template-columns: 1fr 205px 1fr;\n  position: relative;\n}\n.G8nC0Fe3e39ATeycqkKU .CZlxLeJ7IHX9vW4yUn0o .QRApeBQFGsq3XI_MjOED .I4lQOi3FoOamtTWDXhws {\n  width: 205px;\n  height: 310px;\n  /* stylelint-disable-next-line property-no-vendor-prefix */\n  -webkit-mask: var(--avc-svg-hole) 0/100% 100%, linear-gradient(#fff, #fff);\n  /* stylelint-disable-next-line property-no-vendor-prefix */\n  -webkit-mask-composite: xor;\n  mask: var(--avc-svg-hole) 0/100% 100%, linear-gradient(#fff, #fff);\n  mask-composite: exclude;\n  background-color: var(--avc-overlay-color);\n}\n.G8nC0Fe3e39ATeycqkKU .mof1ifeipdkQQuBuRba1 {\n  height: 152px;\n  width: 100%;\n  background-color: rgba(30, 30, 36, 0.9);\n  display: grid;\n  grid-template-rows: auto 1fr;\n}\n.G8nC0Fe3e39ATeycqkKU .mof1ifeipdkQQuBuRba1 > span {\n  margin-top: 32px;\n  text-align: center;\n  color: #fff;\n  display: block;\n  font-size: 18px;\n  width: 100%;\n}\n.G8nC0Fe3e39ATeycqkKU .mof1ifeipdkQQuBuRba1 > svg {\n  margin: auto auto 8px;\n  display: block;\n}","",{version:3,sources:["webpack://./src/components/VideoFrame/style.module.scss"],names:[],mappings:"AAAA,yEAAA;AA2BA;EACE,aAAA;EACA,iCAAA;EACA,kBAAA;EACA,UAAA;EACA,WAAA;EACA,YAAA;EACA,OAAA;EACA,MAAA;AAzBF;AA2BE;EACE,YAAA;EACA,WAAA;EACA,uCAAA;AAzBJ;AA4BE;EACE,aAAA;EACA,uBAAA;EACA,gBAAA;EACA,kBAAA;AA1BJ;AA4BI;EACE,kBAAA;EACA,uCAAA;EACA,mBAAA;EACA,kBAAA;EACA,eAAA;EACA,WAAA;EACA,qBAAA;EACA,SAAA;EACA,QAAA;EACA,UAAA;EACA,gCAAA;EACA,mBAAA;AA1BN;AA8BE;EACE,uDAAA;EACA,0CAAA;EAEA,aAAA;EACA,gCAAA;EACA,gBAAA;AA7BJ;AA+BI;;;;EAIE,0CAAA;AA7BN;AAgCI;EACE,aAAA;EACA,oCAAA;EACA,kBAAA;AA9BN;AAgCM;EACE,YAAA;EACA,aAAA;EACA,0DAAA;EACA,0EAAA;EAEA,0DAAA;EACA,2BAAA;EACA,kEAAA;EACA,uBAAA;EACA,0CAAA;AA/BR;AAoCE;EACE,aAAA;EACA,WAAA;EACA,uCAAA;EACA,aAAA;EACA,4BAAA;AAlCJ;AAoCI;EACE,gBAAA;EACA,kBAAA;EACA,WAAA;EACA,cAAA;EACA,eAAA;EACA,WAAA;AAlCN;AAqCI;EACE,qBAAA;EACA,cAAA;AAnCN",sourcesContent:['/* stylelint-disable max-nesting-depth, selector-max-compound-selectors */\n@mixin key-frame($name: \'default_anim\', $duration: 333ms, $count: infinit) {\n  @keyframes default_anim {\n    0% {\n      y: 0;\n      rx: 0;\n      fill: transparent;\n      x: 0;\n      width: 457px;\n      height: 424px;\n    }\n\n    100% {\n      rx: 121;\n      y: 24;\n      fill: rgba(30, 30, 36, 0.9);\n      x: 107;\n      width: 243px;\n      height: 360px;\n    }\n  }\n\n  animation-name: $name;\n  animation-duration: $duration;\n  animation-iteration-count: $count;\n}\n\n.videoGrid {\n  display: grid;\n  grid-template-rows: auto 1fr auto;\n  position: absolute;\n  z-index: 1;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n\n  .topBar {\n    height: 63px;\n    width: 100%;\n    background-color: rgba(30, 30, 36, 0.9);\n  }\n\n  .middleBarWhiteFrame {\n    display: flex;\n    justify-content: center;\n    overflow: hidden;\n    position: relative;\n\n    .warningPopup {\n      position: absolute;\n      background-color: rgba(30, 30, 36, 0.9);\n      border-radius: 60px;\n      padding: 16px 24px;\n      font-size: 16px;\n      color: #fff;\n      display: inline-block;\n      left: 50%;\n      top: 50%;\n      z-index: 1;\n      transform: translate(-50%, -50%);\n      white-space: nowrap;\n    }\n  }\n\n  .middleBarOverlay {\n    --avc-svg-hole: url(\'data:image/svg+xml;utf8,<svg viewBox="0 0 205 310" xmlns="http://www.w3.org/2000/svg"><path d="M 102.5 14 C 45.891 14 0 59.891 0 116.5 L 0 207.5 C 0 264.109 45.891 310 102.5 310 C 159.109 310 205 264.109 205 207.5 L 205 116.5 C 205 59.891 159.109 14 102.5 14 Z"/></svg>\');\n    --avc-overlay-color: rgba(30, 30, 36, 0.9);\n\n    display: grid;\n    grid-template-rows: 1fr auto 1fr;\n    overflow: hidden;\n\n    .frameOverlayTop,\n    .frameOverlayBottom,\n    .frameOverlayLeft,\n    .frameOverlayRight {\n      background-color: var(--avc-overlay-color);\n    }\n\n    .frameOverlayMiddle {\n      display: grid;\n      grid-template-columns: 1fr 205px 1fr;\n      position: relative;\n\n      .frameMask {\n        width: 205px;\n        height: 310px;\n        /* stylelint-disable-next-line property-no-vendor-prefix */\n        -webkit-mask: var(--avc-svg-hole) 0/100% 100%,\n          linear-gradient(#fff, #fff);\n        /* stylelint-disable-next-line property-no-vendor-prefix */\n        -webkit-mask-composite: xor;\n        mask: var(--avc-svg-hole) 0/100% 100%, linear-gradient(#fff, #fff);\n        mask-composite: exclude;\n        background-color: var(--avc-overlay-color);\n      }\n    }\n  }\n\n  .bottomBar {\n    height: 152px;\n    width: 100%;\n    background-color: rgba(30, 30, 36, 0.9);\n    display: grid;\n    grid-template-rows: auto 1fr;\n\n    > span {\n      margin-top: 32px;\n      text-align: center;\n      color: #fff;\n      display: block;\n      font-size: 18px;\n      width: 100%;\n    }\n\n    > svg {\n      margin: auto auto 8px;\n      display: block;\n    }\n  }\n}\n'],sourceRoot:""}]),c.locals={videoGrid:"G8nC0Fe3e39ATeycqkKU",topBar:"mPLooer9KCt0SimSWTaA",middleBarWhiteFrame:"ZDw8ABIljdwOkgn5akBH",warningPopup:"DNZymcM_zTlnKazf7hgF",middleBarOverlay:"CZlxLeJ7IHX9vW4yUn0o",frameOverlayTop:"yJWHJDQak8hkM8u29kyC",frameOverlayBottom:"QrfSmYpoW_a4vL3nLwtB",frameOverlayLeft:"TCtynKtHr6MCVlg_wrJQ",frameOverlayRight:"FqW_SlJQnbPm99Av7HE3",frameOverlayMiddle:"QRApeBQFGsq3XI_MjOED",frameMask:"I4lQOi3FoOamtTWDXhws",bottomBar:"mof1ifeipdkQQuBuRba1"};const h=c},"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/WhiteFrame/style.module.scss":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/WhiteFrame/style.module.scss ***!
  \**********************************************************************************************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});var r=n(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */"./node_modules/css-loader/dist/runtime/sourceMaps.js"),a=n.n(r),s=n(/*! ../../../node_modules/css-loader/dist/runtime/api.js */"./node_modules/css-loader/dist/runtime/api.js"),o=n.n(s)()(a());o.push([e.id,"@keyframes JmEL1Pz_UmcG3e06vPU_ {\n  0% {\n    transform: scale(0.96);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n.kJiaVKUD8Ov3R7FZHtiN {\n  height: 100%;\n  animation: JmEL1Pz_UmcG3e06vPU_ 1.5s ease-in-out 0s infinite alternate;\n}\n@media (max-width: 479px) {\n  .kJiaVKUD8Ov3R7FZHtiN {\n    max-width: 294px;\n  }\n}","",{version:3,sources:["webpack://./src/components/WhiteFrame/style.module.scss"],names:[],mappings:"AAAA;EACE;IACE,sBAAA;EACF;EAEA;IACE,mBAAA;EAAF;AACF;AAGA;EACE,YAAA;EACA,sEAAA;AADF;AAGE;EAJF;IAKI,gBAAA;EAAF;AACF",sourcesContent:["@keyframes scale {\n  0% {\n    transform: scale(0.96);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n}\n\n.whiteFrame {\n  height: 100%;\n  animation: scale 1.5s ease-in-out 0s infinite alternate;\n\n  @media (max-width: 479px) {\n    max-width: 294px;\n  }\n}\n"],sourceRoot:""}]),o.locals={whiteFrame:"kJiaVKUD8Ov3R7FZHtiN",scale:"JmEL1Pz_UmcG3e06vPU_"};const i=o},"./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/e=>{e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,a,s){"string"==typeof e&&(e=[[null,e,void 0]]);var o={};if(r)for(var i=0;i<this.length;i++){var l=this[i][0];null!=l&&(o[l]=!0)}for(var u=0;u<e.length;u++){var c=[].concat(e[u]);r&&o[c[0]]||(void 0!==s&&(void 0===c[5]||(c[1]="@layer".concat(c[5].length>0?" ".concat(c[5]):""," {").concat(c[1],"}")),c[5]=s),n&&(c[2]?(c[1]="@media ".concat(c[2]," {").concat(c[1],"}"),c[2]=n):c[2]=n),a&&(c[4]?(c[1]="@supports (".concat(c[4],") {").concat(c[1],"}"),c[4]=a):c[4]="".concat(a)),t.push(c))}},t}},"./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/e=>{e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},"./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/e=>{e.exports=function(e){var t=e[1],n=e[3];if(!n)return t;if("function"==typeof btoa){var r=btoa(unescape(encodeURIComponent(JSON.stringify(n)))),a="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r),s="/*# ".concat(a," */"),o=n.sources.map((function(e){return"/*# sourceURL=".concat(n.sourceRoot||"").concat(e," */")}));return[t].concat(o).concat([s]).join("\n")}return[t].join("\n")}},"./node_modules/preact/compat/dist/compat.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/preact/compat/dist/compat.module.js ***!
  \**********************************************************/(e,t,n)=>{n.r(t),n.d(t,{Children:()=>f,Component:()=>s.Component,Fragment:()=>s.Fragment,PureComponent:()=>l,StrictMode:()=>X,Suspense:()=>g,SuspenseList:()=>b,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:()=>L,cloneElement:()=>V,createContext:()=>s.createContext,createElement:()=>s.createElement,createFactory:()=>W,createPortal:()=>S,createRef:()=>s.createRef,default:()=>K,findDOMNode:()=>G,flushSync:()=>q,forwardRef:()=>h,hydrate:()=>R,isValidElement:()=>U,lazy:()=>x,memo:()=>u,render:()=>T,unmountComponentAtNode:()=>j,unstable_batchedUpdates:()=>H,version:()=>B});var r=n(/*! preact/hooks */"preact/hooks"),a={};for(const e in r)["default","createElement","createContext","createRef","Fragment","Component","version","Children","render","hydrate","unmountComponentAtNode","createPortal","createFactory","cloneElement","isValidElement","findDOMNode","PureComponent","memo","forwardRef","flushSync","unstable_batchedUpdates","StrictMode","Suspense","SuspenseList","lazy","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED"].indexOf(e)<0&&(a[e]=()=>r[e]);n.d(t,a);var s=n(/*! preact */"preact");function o(e,t){for(var n in t)e[n]=t[n];return e}function i(e,t){for(var n in e)if("__source"!==n&&!(n in t))return!0;for(var r in t)if("__source"!==r&&e[r]!==t[r])return!0;return!1}function l(e){this.props=e}function u(e,t){function n(e){var n=this.props.ref,r=n==e.ref;return!r&&n&&(n.call?n(null):n.current=null),t?!t(this.props,e)||!r:i(this.props,e)}function r(t){return this.shouldComponentUpdate=n,(0,s.createElement)(e,t)}return r.displayName="Memo("+(e.displayName||e.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(l.prototype=new s.Component).isPureReactComponent=!0,l.prototype.shouldComponentUpdate=function(e,t){return i(this.props,e)||i(this.state,t)};var c=s.options.__b;s.options.__b=function(e){e.type&&e.type.__f&&e.ref&&(e.props.ref=e.ref,e.ref=null),c&&c(e)};var d="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function h(e){function t(t){var n=o({},t);return delete n.ref,e(n,t.ref||null)}return t.$$typeof=d,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(e.displayName||e.name)+")",t}var p=function(e,t){return null==e?null:(0,s.toChildArray)((0,s.toChildArray)(e).map(t))},f={map:p,forEach:p,count:function(e){return e?(0,s.toChildArray)(e).length:0},only:function(e){var t=(0,s.toChildArray)(e);if(1!==t.length)throw"Children.only";return t[0]},toArray:s.toChildArray},m=s.options.__e;s.options.__e=function(e,t,n,r){if(e.then)for(var a,s=t;s=s.__;)if((a=s.__c)&&a.__c)return null==t.__e&&(t.__e=n.__e,t.__k=n.__k),a.__c(e,t);m(e,t,n,r)};var A=s.options.unmount;function g(){this.__u=0,this.t=null,this.__b=null}function y(e){var t=e.__.__c;return t&&t.__e&&t.__e(e)}function x(e){var t,n,r;function a(a){if(t||(t=e()).then((function(e){n=e.default||e}),(function(e){r=e})),r)throw r;if(!n)throw t;return(0,s.createElement)(n,a)}return a.displayName="Lazy",a.__f=!0,a}function b(){this.u=null,this.o=null}s.options.unmount=function(e){var t=e.__c;t&&t.__R&&t.__R(),t&&!0===e.__h&&(e.type=null),A&&A(e)},(g.prototype=new s.Component).__c=function(e,t){var n=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(n);var a=y(r.__v),s=!1,o=function(){s||(s=!0,n.__R=null,a?a(i):i())};n.__R=o;var i=function(){if(!--r.__u){if(r.state.__e){var e=r.state.__e;r.__v.__k[0]=function e(t,n,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map((function(t){return e(t,n,r)})),t.__c&&t.__c.__P===n&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(e,e.__c.__P,e.__c.__O)}var t;for(r.setState({__e:r.__b=null});t=r.t.pop();)t.forceUpdate()}},l=!0===t.__h;r.__u++||l||r.setState({__e:r.__b=r.__v.__k[0]}),e.then(o,o)},g.prototype.componentWillUnmount=function(){this.t=[]},g.prototype.render=function(e,t){if(this.__b){if(this.__v.__k){var n=document.createElement("div"),r=this.__v.__k[0].__c;this.__v.__k[0]=function e(t,n,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach((function(e){"function"==typeof e.__c&&e.__c()})),t.__c.__H=null),null!=(t=o({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=n),t.__c=null),t.__k=t.__k&&t.__k.map((function(t){return e(t,n,r)}))),t}(this.__b,n,r.__O=r.__P)}this.__b=null}var a=t.__e&&(0,s.createElement)(s.Fragment,null,e.fallback);return a&&(a.__h=null),[(0,s.createElement)(s.Fragment,null,t.__e?null:e.children),a]};var v=function(e,t,n){if(++n[1]===n[0]&&e.o.delete(t),e.props.revealOrder&&("t"!==e.props.revealOrder[0]||!e.o.size))for(n=e.u;n;){for(;n.length>3;)n.pop()();if(n[1]<n[0])break;e.u=n=n[2]}};function w(e){return this.getChildContext=function(){return e.context},e.children}function k(e){var t=this,n=e.i;t.componentWillUnmount=function(){(0,s.render)(null,t.l),t.l=null,t.i=null},t.i&&t.i!==n&&t.componentWillUnmount(),e.__v?(t.l||(t.i=n,t.l={nodeType:1,parentNode:n,childNodes:[],appendChild:function(e){this.childNodes.push(e),t.i.appendChild(e)},insertBefore:function(e,n){this.childNodes.push(e),t.i.appendChild(e)},removeChild:function(e){this.childNodes.splice(this.childNodes.indexOf(e)>>>1,1),t.i.removeChild(e)}}),(0,s.render)((0,s.createElement)(w,{context:t.context},e.__v),t.l)):t.l&&t.componentWillUnmount()}function S(e,t){var n=(0,s.createElement)(k,{__v:e,i:t});return n.containerInfo=t,n}(b.prototype=new s.Component).__e=function(e){var t=this,n=y(t.__v),r=t.o.get(e);return r[0]++,function(a){var s=function(){t.props.revealOrder?(r.push(a),v(t,e,r)):a()};n?n(s):s()}},b.prototype.render=function(e){this.u=null,this.o=new Map;var t=(0,s.toChildArray)(e.children);e.revealOrder&&"b"===e.revealOrder[0]&&t.reverse();for(var n=t.length;n--;)this.o.set(t[n],this.u=[1,0,this.u]);return e.children},b.prototype.componentDidUpdate=b.prototype.componentDidMount=function(){var e=this;this.o.forEach((function(t,n){v(e,n,t)}))};var I="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,C=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,E="undefined"!=typeof document,N=function(e){return("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(e)};function T(e,t,n){return null==t.__k&&(t.textContent=""),(0,s.render)(e,t),"function"==typeof n&&n(),e?e.__c:null}function R(e,t,n){return(0,s.hydrate)(e,t),"function"==typeof n&&n(),e?e.__c:null}s.Component.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach((function(e){Object.defineProperty(s.Component.prototype,e,{configurable:!0,get:function(){return this["UNSAFE_"+e]},set:function(t){Object.defineProperty(this,e,{configurable:!0,writable:!0,value:t})}})}));var _=s.options.event;function M(){}function $(){return this.cancelBubble}function F(){return this.defaultPrevented}s.options.event=function(e){return _&&(e=_(e)),e.persist=M,e.isPropagationStopped=$,e.isDefaultPrevented=F,e.nativeEvent=e};var O,D={configurable:!0,get:function(){return this.class}},z=s.options.vnode;s.options.vnode=function(e){var t=e.type,n=e.props,r=n;if("string"==typeof t){var a=-1===t.indexOf("-");for(var o in r={},n){var i=n[o];E&&"children"===o&&"noscript"===t||"value"===o&&"defaultValue"in n&&null==i||("defaultValue"===o&&"value"in n&&null==n.value?o="value":"download"===o&&!0===i?i="":/ondoubleclick/i.test(o)?o="ondblclick":/^onchange(textarea|input)/i.test(o+t)&&!N(n.type)?o="oninput":/^onfocus$/i.test(o)?o="onfocusin":/^onblur$/i.test(o)?o="onfocusout":/^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o)?o=o.toLowerCase():a&&C.test(o)?o=o.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===i&&(i=void 0),r[o]=i)}"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=(0,s.toChildArray)(n.children).forEach((function(e){e.props.selected=-1!=r.value.indexOf(e.props.value)}))),"select"==t&&null!=r.defaultValue&&(r.value=(0,s.toChildArray)(n.children).forEach((function(e){e.props.selected=r.multiple?-1!=r.defaultValue.indexOf(e.props.value):r.defaultValue==e.props.value}))),e.props=r,n.class!=n.className&&(D.enumerable="className"in n,null!=n.className&&(r.class=n.className),Object.defineProperty(r,"className",D))}e.$$typeof=I,z&&z(e)};var P=s.options.__r;s.options.__r=function(e){P&&P(e),O=e.__c};var L={ReactCurrentDispatcher:{current:{readContext:function(e){return O.__n[e.__c].props.value}}}},B="17.0.2";function W(e){return s.createElement.bind(null,e)}function U(e){return!!e&&e.$$typeof===I}function V(e){return U(e)?s.cloneElement.apply(null,arguments):e}function j(e){return!!e.__k&&((0,s.render)(null,e),!0)}function G(e){return e&&(e.base||1===e.nodeType&&e)||null}var H=function(e,t){return e(t)},q=function(e,t){return e(t)},X=s.Fragment;const K={useState:r.useState,useReducer:r.useReducer,useEffect:r.useEffect,useLayoutEffect:r.useLayoutEffect,useRef:r.useRef,useImperativeHandle:r.useImperativeHandle,useMemo:r.useMemo,useCallback:r.useCallback,useContext:r.useContext,useDebugValue:r.useDebugValue,version:"17.0.2",Children:f,render:T,hydrate:R,unmountComponentAtNode:j,createPortal:S,createElement:s.createElement,createContext:s.createContext,createFactory:W,cloneElement:V,createRef:s.createRef,Fragment:s.Fragment,isValidElement:U,findDOMNode:G,Component:s.Component,PureComponent:l,memo:u,forwardRef:h,flushSync:q,unstable_batchedUpdates:H,StrictMode:s.Fragment,Suspense:g,SuspenseList:b,lazy:x,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:L}},"./node_modules/react-webcam/dist/react-webcam.js":
/*!********************************************************!*\
  !*** ./node_modules/react-webcam/dist/react-webcam.js ***!
  \********************************************************/function(e,t,n){var r;r=function(e){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":
/*!******************************!*\
  !*** ./src/react-webcam.tsx ***!
  \******************************/
/*! exports provided: default */function(e,t,n){n.r(t);var r,a=n(/*! react */"react"),s=(r=function(e,t){return r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},r(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}),o=function(){return o=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var a in t=arguments[n])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e},o.apply(this,arguments)},i=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};function l(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)}"undefined"!=typeof window&&(void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(e){var t=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return t?new Promise((function(n,r){t.call(navigator,e,n,r)})):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}));var u=function(e){function t(t){var n=e.call(this,t)||this;return n.canvas=null,n.ctx=null,n.requestUserMediaId=0,n.unmounted=!1,n.state={hasUserMedia:!1},n}return s(t,e),t.prototype.componentDidMount=function(){var e=this.state,t=this.props;this.unmounted=!1,l()?(e.hasUserMedia||this.requestUserMedia(),t.children&&"function"!=typeof t.children&&console.warn("children must be a function")):t.onUserMediaError("getUserMedia not supported")},t.prototype.componentDidUpdate=function(e){var t=this.props;if(l()){var n=JSON.stringify(e.audioConstraints)!==JSON.stringify(t.audioConstraints),r=JSON.stringify(e.videoConstraints)!==JSON.stringify(t.videoConstraints),a=e.minScreenshotWidth!==t.minScreenshotWidth,s=e.minScreenshotHeight!==t.minScreenshotHeight;(r||a||s)&&(this.canvas=null,this.ctx=null),(n||r)&&(this.stopAndCleanup(),this.requestUserMedia())}else t.onUserMediaError("getUserMedia not supported")},t.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},t.stopMediaStream=function(e){e&&(e.getVideoTracks&&e.getAudioTracks?(e.getVideoTracks().map((function(t){e.removeTrack(t),t.stop()})),e.getAudioTracks().map((function(t){e.removeTrack(t),t.stop()}))):e.stop())},t.prototype.stopAndCleanup=function(){var e=this.state;e.hasUserMedia&&(t.stopMediaStream(this.stream),e.src&&window.URL.revokeObjectURL(e.src))},t.prototype.getScreenshot=function(e){var t=this.state,n=this.props;if(!t.hasUserMedia)return null;var r=this.getCanvas(e);return r&&r.toDataURL(n.screenshotFormat,n.screenshotQuality)},t.prototype.getCanvas=function(e){var t=this.state,n=this.props;if(!this.video)return null;if(!t.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var r=this.video.videoWidth,a=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var s=r/a;a=(r=n.minScreenshotWidth||this.video.clientWidth)/s,n.minScreenshotHeight&&a<n.minScreenshotHeight&&(r=(a=n.minScreenshotHeight)*s)}this.canvas=document.createElement("canvas"),this.canvas.width=(null==e?void 0:e.width)||r,this.canvas.height=(null==e?void 0:e.height)||a,this.ctx=this.canvas.getContext("2d")}var o=this.ctx,i=this.canvas;return o&&i&&(n.mirrored&&(o.translate(i.width,0),o.scale(-1,1)),o.imageSmoothingEnabled=n.imageSmoothing,o.drawImage(this.video,0,0,(null==e?void 0:e.width)||i.width,(null==e?void 0:e.height)||i.height),n.mirrored&&(o.scale(-1,1),o.translate(-i.width,0))),i},t.prototype.requestUserMedia=function(){var e=this,n=this.props,r=function(r,a){var s={video:void 0===a||a};n.audio&&(s.audio=void 0===r||r),e.requestUserMediaId++;var o=e.requestUserMediaId;navigator.mediaDevices.getUserMedia(s).then((function(n){e.unmounted||o!==e.requestUserMediaId?t.stopMediaStream(n):e.handleUserMedia(null,n)})).catch((function(t){e.handleUserMedia(t)}))};if("mediaDevices"in navigator)r(n.audioConstraints,n.videoConstraints);else{var a=function(e){return{optional:[{sourceId:e}]}},s=function(e){var t=e.deviceId;return"string"==typeof t?t:Array.isArray(t)&&t.length>0?t[0]:"object"==typeof t&&t.ideal?t.ideal:null};MediaStreamTrack.getSources((function(e){var t=null,o=null;e.forEach((function(e){"audio"===e.kind?t=e.id:"video"===e.kind&&(o=e.id)}));var i=s(n.audioConstraints);i&&(t=i);var l=s(n.videoConstraints);l&&(o=l),r(a(t),a(o))}))}},t.prototype.handleUserMedia=function(e,t){var n=this.props;if(e||!t)return this.setState({hasUserMedia:!1}),void n.onUserMediaError(e);this.stream=t;try{this.video&&(this.video.srcObject=t),this.setState({hasUserMedia:!0})}catch(e){this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(t)})}n.onUserMedia(t)},t.prototype.render=function(){var e=this,t=this.state,n=this.props,r=n.audio,s=(n.forceScreenshotSourceSize,n.onUserMedia,n.onUserMediaError,n.screenshotFormat,n.screenshotQuality,n.minScreenshotWidth,n.minScreenshotHeight,n.audioConstraints,n.videoConstraints,n.imageSmoothing,n.mirrored),l=n.style,u=void 0===l?{}:l,c=n.children,d=i(n,["audio","forceScreenshotSourceSize","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),h=s?o(o({},u),{transform:(u.transform||"")+" scaleX(-1)"}):u,p={getScreenshot:this.getScreenshot.bind(this)};return a.createElement(a.Fragment,null,a.createElement("video",o({autoPlay:!0,src:t.src,muted:!r,playsInline:!0,ref:function(t){e.video=t},style:h},d)),c&&c(p))},t.defaultProps={audio:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},t}(a.Component);t.default=u},react:
/*!**************************************************************************************!*\
  !*** external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"} ***!
  \**************************************************************************************/
/*! no static exports found */function(t,n){t.exports=e}}).default},e.exports=r(n(/*! react */"./node_modules/preact/compat/dist/compat.module.js"))},"./src/components/ActiveVideoCapture/style.module.scss":
/*!*************************************************************!*\
  !*** ./src/components/ActiveVideoCapture/style.module.scss ***!
  \*************************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>g});var r=n(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),a=n.n(r),s=n(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */"./node_modules/style-loader/dist/runtime/styleDomAPI.js"),o=n.n(s),i=n(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */"./node_modules/style-loader/dist/runtime/insertBySelector.js"),l=n.n(i),u=n(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"),c=n.n(u),d=n(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */"./node_modules/style-loader/dist/runtime/insertStyleElement.js"),h=n.n(d),p=n(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */"./node_modules/style-loader/dist/runtime/styleTagTransform.js"),f=n.n(p),m=n(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./style.module.scss */"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/ActiveVideoCapture/style.module.scss"),A={};A.styleTagTransform=f(),A.setAttributes=c(),A.insert=l().bind(null,"head"),A.domAPI=o(),A.insertStyleElement=h();a()(m.default,A);const g=m.default&&m.default.locals?m.default.locals:void 0},"./src/components/Alert/style.module.scss":
/*!************************************************!*\
  !*** ./src/components/Alert/style.module.scss ***!
  \************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>g});var r=n(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),a=n.n(r),s=n(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */"./node_modules/style-loader/dist/runtime/styleDomAPI.js"),o=n.n(s),i=n(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */"./node_modules/style-loader/dist/runtime/insertBySelector.js"),l=n.n(i),u=n(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"),c=n.n(u),d=n(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */"./node_modules/style-loader/dist/runtime/insertStyleElement.js"),h=n.n(d),p=n(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */"./node_modules/style-loader/dist/runtime/styleTagTransform.js"),f=n.n(p),m=n(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./style.module.scss */"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/Alert/style.module.scss"),A={};A.styleTagTransform=f(),A.setAttributes=c(),A.insert=l().bind(null,"head"),A.domAPI=o(),A.insertStyleElement=h();a()(m.default,A);const g=m.default&&m.default.locals?m.default.locals:void 0},"./src/components/Button/style.module.scss":
/*!*************************************************!*\
  !*** ./src/components/Button/style.module.scss ***!
  \*************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>g});var r=n(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),a=n.n(r),s=n(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */"./node_modules/style-loader/dist/runtime/styleDomAPI.js"),o=n.n(s),i=n(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */"./node_modules/style-loader/dist/runtime/insertBySelector.js"),l=n.n(i),u=n(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"),c=n.n(u),d=n(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */"./node_modules/style-loader/dist/runtime/insertStyleElement.js"),h=n.n(d),p=n(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */"./node_modules/style-loader/dist/runtime/styleTagTransform.js"),f=n.n(p),m=n(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./style.module.scss */"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/Button/style.module.scss"),A={};A.styleTagTransform=f(),A.setAttributes=c(),A.insert=l().bind(null,"head"),A.domAPI=o(),A.insertStyleElement=h();a()(m.default,A);const g=m.default&&m.default.locals?m.default.locals:void 0},"./src/components/DebugFrame/style.module.scss":
/*!*****************************************************!*\
  !*** ./src/components/DebugFrame/style.module.scss ***!
  \*****************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>g});var r=n(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),a=n.n(r),s=n(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */"./node_modules/style-loader/dist/runtime/styleDomAPI.js"),o=n.n(s),i=n(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */"./node_modules/style-loader/dist/runtime/insertBySelector.js"),l=n.n(i),u=n(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"),c=n.n(u),d=n(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */"./node_modules/style-loader/dist/runtime/insertStyleElement.js"),h=n.n(d),p=n(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */"./node_modules/style-loader/dist/runtime/styleTagTransform.js"),f=n.n(p),m=n(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./style.module.scss */"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/DebugFrame/style.module.scss"),A={};A.styleTagTransform=f(),A.setAttributes=c(),A.insert=l().bind(null,"head"),A.domAPI=o(),A.insertStyleElement=h();a()(m.default,A);const g=m.default&&m.default.locals?m.default.locals:void 0},"./src/components/DebugStats/style.module.scss":
/*!*****************************************************!*\
  !*** ./src/components/DebugStats/style.module.scss ***!
  \*****************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>g});var r=n(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),a=n.n(r),s=n(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */"./node_modules/style-loader/dist/runtime/styleDomAPI.js"),o=n.n(s),i=n(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */"./node_modules/style-loader/dist/runtime/insertBySelector.js"),l=n.n(i),u=n(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"),c=n.n(u),d=n(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */"./node_modules/style-loader/dist/runtime/insertStyleElement.js"),h=n.n(d),p=n(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */"./node_modules/style-loader/dist/runtime/styleTagTransform.js"),f=n.n(p),m=n(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./style.module.scss */"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/DebugStats/style.module.scss"),A={};A.styleTagTransform=f(),A.setAttributes=c(),A.insert=l().bind(null,"head"),A.domAPI=o(),A.insertStyleElement=h();a()(m.default,A);const g=m.default&&m.default.locals?m.default.locals:void 0},"./src/components/ProgressBars/style.module.scss":
/*!*******************************************************!*\
  !*** ./src/components/ProgressBars/style.module.scss ***!
  \*******************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>g});var r=n(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),a=n.n(r),s=n(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */"./node_modules/style-loader/dist/runtime/styleDomAPI.js"),o=n.n(s),i=n(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */"./node_modules/style-loader/dist/runtime/insertBySelector.js"),l=n.n(i),u=n(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"),c=n.n(u),d=n(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */"./node_modules/style-loader/dist/runtime/insertStyleElement.js"),h=n.n(d),p=n(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */"./node_modules/style-loader/dist/runtime/styleTagTransform.js"),f=n.n(p),m=n(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./style.module.scss */"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/ProgressBars/style.module.scss"),A={};A.styleTagTransform=f(),A.setAttributes=c(),A.insert=l().bind(null,"head"),A.domAPI=o(),A.insertStyleElement=h();a()(m.default,A);const g=m.default&&m.default.locals?m.default.locals:void 0},"./src/components/VideoFeedback/style.module.scss":
/*!********************************************************!*\
  !*** ./src/components/VideoFeedback/style.module.scss ***!
  \********************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>g});var r=n(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),a=n.n(r),s=n(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */"./node_modules/style-loader/dist/runtime/styleDomAPI.js"),o=n.n(s),i=n(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */"./node_modules/style-loader/dist/runtime/insertBySelector.js"),l=n.n(i),u=n(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"),c=n.n(u),d=n(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */"./node_modules/style-loader/dist/runtime/insertStyleElement.js"),h=n.n(d),p=n(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */"./node_modules/style-loader/dist/runtime/styleTagTransform.js"),f=n.n(p),m=n(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./style.module.scss */"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/VideoFeedback/style.module.scss"),A={};A.styleTagTransform=f(),A.setAttributes=c(),A.insert=l().bind(null,"head"),A.domAPI=o(),A.insertStyleElement=h();a()(m.default,A);const g=m.default&&m.default.locals?m.default.locals:void 0},"./src/components/VideoFrame/style.module.scss":
/*!*****************************************************!*\
  !*** ./src/components/VideoFrame/style.module.scss ***!
  \*****************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>g});var r=n(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),a=n.n(r),s=n(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */"./node_modules/style-loader/dist/runtime/styleDomAPI.js"),o=n.n(s),i=n(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */"./node_modules/style-loader/dist/runtime/insertBySelector.js"),l=n.n(i),u=n(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"),c=n.n(u),d=n(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */"./node_modules/style-loader/dist/runtime/insertStyleElement.js"),h=n.n(d),p=n(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */"./node_modules/style-loader/dist/runtime/styleTagTransform.js"),f=n.n(p),m=n(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./style.module.scss */"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/VideoFrame/style.module.scss"),A={};A.styleTagTransform=f(),A.setAttributes=c(),A.insert=l().bind(null,"head"),A.domAPI=o(),A.insertStyleElement=h();a()(m.default,A);const g=m.default&&m.default.locals?m.default.locals:void 0},"./src/components/WhiteFrame/style.module.scss":
/*!*****************************************************!*\
  !*** ./src/components/WhiteFrame/style.module.scss ***!
  \*****************************************************/(e,t,n)=>{n.r(t),n.d(t,{default:()=>g});var r=n(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"),a=n.n(r),s=n(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */"./node_modules/style-loader/dist/runtime/styleDomAPI.js"),o=n.n(s),i=n(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */"./node_modules/style-loader/dist/runtime/insertBySelector.js"),l=n.n(i),u=n(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"),c=n.n(u),d=n(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */"./node_modules/style-loader/dist/runtime/insertStyleElement.js"),h=n.n(d),p=n(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */"./node_modules/style-loader/dist/runtime/styleTagTransform.js"),f=n.n(p),m=n(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/sass-loader/dist/cjs.js!./style.module.scss */"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/components/WhiteFrame/style.module.scss"),A={};A.styleTagTransform=f(),A.setAttributes=c(),A.insert=l().bind(null,"head"),A.domAPI=o(),A.insertStyleElement=h();a()(m.default,A);const g=m.default&&m.default.locals?m.default.locals:void 0},"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/e=>{var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var s={},o=[],i=0;i<e.length;i++){var l=e[i],u=r.base?l[0]+r.base:l[0],c=s[u]||0,d="".concat(u," ").concat(c);s[u]=c+1;var h=n(d),p={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==h)t[h].references++,t[h].updater(p);else{var f=a(p,r);r.byIndex=i,t.splice(i,0,{identifier:d,updater:f,references:1})}o.push(d)}return o}function a(e,t){var n=t.domAPI(t);n.update(e);return function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,a){var s=r(e=e||[],a=a||{});return function(e){e=e||[];for(var o=0;o<s.length;o++){var i=n(s[o]);t[i].references--}for(var l=r(e,a),u=0;u<s.length;u++){var c=n(s[u]);0===t[c].references&&(t[c].updater(),t.splice(c,1))}s=l}}},"./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/e=>{var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},"./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/e=>{e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/(e,t,n)=>{e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},"./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/e=>{e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var a=void 0!==n.layer;a&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,a&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var s=n.sourceMap;s&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},"./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/e=>{e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},preact:
/*!*************************!*\
  !*** external "preact" ***!
  \*************************/e=>{e.exports=a},"preact/compat":
/*!********************************!*\
  !*** external "preact/compat" ***!
  \********************************/e=>{e.exports=s},"preact/hooks":
/*!*******************************!*\
  !*** external "preact/hooks" ***!
  \*******************************/e=>{e.exports=o},"preact/jsx-runtime":
/*!*************************************!*\
  !*** external "preact/jsx-runtime" ***!
  \*************************************/e=>{e.exports=i},"./node_modules/preact/compat/jsx-runtime.mjs":
/*!****************************************************!*\
  !*** ./node_modules/preact/compat/jsx-runtime.mjs ***!
  \****************************************************/(e,t,n)=>{n.r(t);n(/*! preact/compat */"preact/compat");var r=n(/*! preact/jsx-runtime */"preact/jsx-runtime"),a={};for(const e in r)"default"!==e&&(a[e]=()=>r[e]);n.d(t,a)}},u={};function c(e){var t=u[e];if(void 0!==t)return t.exports;var n=u[e]={id:e,exports:{}};return l[e].call(n.exports,n,n.exports,c),n.exports}c.amdO={},c.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return c.d(t,{a:t}),t},c.d=(e,t)=>{for(var n in t)c.o(t,n)&&!c.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},c.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),c.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),c.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},c.nc=void 0;t={};(()=>{
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
c.r(t),c.d(t,{ActiveVideoCapture:()=>e.ActiveVideoCapture,LivenessError:()=>n.LivenessError,TrackingEvent:()=>n.TrackingEvent});var e=c(/*! ./components/ActiveVideoCapture */"./src/components/ActiveVideoCapture/index.tsx"),n=c(/*! ./types */"./src/types/index.ts")})();var d=t.ActiveVideoCapture,h=t.LivenessError,p=(t.TrackingEvent,n("../node_modules/react-redux/es/index.js")),f=n("./locales/index.tsx"),m=n("./components/utils/index.tsx"),A=n("./components/utils/string.ts"),g=n("./components/CameraPermissions/withPermissionsFlow.tsx"),y=n("./components/Camera/withFailureHandling.tsx"),x=n("../node_modules/@babel/runtime-corejs3/core-js-stable/instance/map.js"),b=n.n(x),v="onfido-sdk-ui-ActiveVideo-FaceNotDetected-list",w="onfido-sdk-ui-ActiveVideo-FaceNotDetected-listItem",k="onfido-sdk-ui-ActiveVideo-FaceNotDetected-text",S=n("./components/ActiveVideo/Button/index.tsx"),I=n("./components/ActiveVideo/Footer/index.tsx"),C=n("./components/ActiveVideo/Header/index.tsx"),E=n("./components/ActiveVideo/assets/ErrorIcon.tsx"),N=function(){return(0,a.h)("svg",{width:"32",height:"32",viewBox:"0 0 32 32",fill:"none",xmlns:"http://www.w3.org/2000/svg"},(0,a.h)("path",{d:"M9.32406 15.9993C9.32406 19.6807 12.3187 22.6754 16.0001 22.6754C19.6814 22.6754 22.6761 19.6807 22.6761 15.9993C22.6761 12.318 19.6814 9.32335 16.0001 9.32335C12.3187 9.32335 9.32406 12.318 9.32406 15.9993ZM16.0001 11.99C18.2107 11.99 20.0094 13.7887 20.0094 15.9993C20.0094 18.21 18.2107 20.0087 16.0001 20.0087C13.7894 20.0087 11.9907 18.21 11.9907 15.9993C11.9907 13.7887 13.7894 11.99 16.0001 11.99ZM14.6641 25.3327H17.3307V29.3327H14.6641V25.3327ZM14.6641 2.66602H17.3307V6.66602H14.6641V2.66602ZM2.66406 14.666H6.66406V17.3327H2.66406V14.666ZM25.3307 14.666H29.3307V17.3327H25.3307V14.666ZM5.6254 24.4834L8.45206 21.654L10.3387 23.5394L7.51206 26.3687L5.6254 24.4834ZM21.6534 8.45802L24.4827 5.62868L26.3681 7.51402L23.5387 10.3433L21.6534 8.45802ZM8.45606 10.3447L5.62673 7.51535L7.5134 5.63002L10.3401 8.45935L8.45606 10.3447ZM26.3681 24.4847L24.4827 26.37L21.6534 23.5407L23.5387 21.6553L26.3681 24.4847Z",fill:"#2B2D33"}))},T=function(){return(0,a.h)("svg",{width:"32",height:"32",fill:"none",xmlns:"http://www.w3.org/2000/svg"},(0,a.h)("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M2.736 15.578c.028-.09 3.087-8.912 13.264-8.912s13.236 8.823 13.265 8.912l.14.421-.14.422c-.029.089-3.088 8.912-13.265 8.912S2.764 16.51 2.735 16.42l-.14-.422.141-.421Zm2.696.421c.67 1.539 3.433 6.667 10.568 6.667 7.13 0 9.896-5.123 10.568-6.667-.67-1.538-3.433-6.666-10.568-6.666-7.13 0-9.896 5.122-10.568 6.666ZM12 16c0-2.188 1.81-4 4-4 2.188 0 4 1.812 4 4 0 2.19-1.812 4-4 4-2.19 0-4-1.81-4-4Z",fill:"#2B2D33"}))},R=function(){return(0,a.h)("svg",{width:"32",height:"32",fill:"none",xmlns:"http://www.w3.org/2000/svg"},(0,a.h)("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M14.735 9.827a4 4 0 0 1 2.53 0l4.49 1.497c.544.181.912.69.912 1.265v6.822c0 .574-.368 1.084-.912 1.265l-4.49 1.497a4 4 0 0 1-2.53 0l-4.49-1.497a1.333 1.333 0 0 1-.912-1.265V12.59c0-.574.367-1.084.912-1.265l4.49-1.497Zm3.373-2.53a6.666 6.666 0 0 0-4.216 0l-4.49 1.497a3.998 3.998 0 0 0-2.282 1.945 5.335 5.335 0 0 0 0 10.522 3.999 3.999 0 0 0 2.282 1.945l4.49 1.497a6.666 6.666 0 0 0 4.216 0l4.49-1.497a3.998 3.998 0 0 0 2.282-1.945 5.335 5.335 0 0 0 0-10.522 3.998 3.998 0 0 0-2.282-1.945l-4.49-1.497Zm7.225 6.393v4.62a2.666 2.666 0 0 0 0-4.62ZM6.667 18.31v-4.62a2.666 2.666 0 0 0 0 4.62ZM20 12.667h-8v2.666h8v-2.667Zm-8 4h8v2.666h-8v-2.666Z",fill:"#2B2D33"}))},_=function(){return(0,a.h)("svg",{width:"32",height:"32",fill:"none",xmlns:"http://www.w3.org/2000/svg"},(0,a.h)("path",{d:"M16 2.666c-7.352 0-13.334 5.981-13.334 13.333S8.648 29.333 16 29.333c7.352 0 13.333-5.982 13.333-13.334 0-7.352-5.981-13.333-13.333-13.333Zm0 2.667c4.284 0 7.976 2.544 9.672 6.197-.412-.195-.81-.417-1.194-.664-.545-.344-1.164-.735-1.946-1.03-.892-.34-1.867-.503-2.979-.503s-2.087.164-2.979.502c-.782.298-1.4.688-1.962 1.042-.504.316-.938.59-1.47.792-.595.225-1.24.33-2.035.33-.794 0-1.44-.105-2.032-.33-.534-.202-.971-.478-1.475-.798a25.866 25.866 0 0 0-.693-.417C8.783 7.389 12.15 5.333 16 5.333Zm0 21.333c-5.882 0-10.667-4.785-10.667-10.667 0-1.08.164-2.12.464-3.102.126.077.247.146.378.23.548.347 1.168.739 1.954 1.035.892.34 1.866.504 2.978.504 1.11 0 2.085-.164 2.98-.503.782-.297 1.4-.688 1.962-1.041.504-.316.938-.59 1.47-.793.594-.224 1.24-.33 2.034-.33.795 0 1.44.106 2.034.331.532.2.966.475 1.485.803.545.344 1.164.734 1.947 1.03a7.5 7.5 0 0 0 1.537.388c.065.476.11.956.11 1.448 0 5.882-4.785 10.667-10.666 10.667Z",fill:"#2B2D33"}),(0,a.h)("path",{d:"M11.334 20a2 2 0 1 0 0-4 2 2 0 0 0 0 4ZM20.666 20a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z",fill:"#2B2D33"}))},M=n("./components/ActiveVideo/Wrapper/index.tsx"),$=n("./components/ActiveVideo/BaseScreen/index.tsx"),F=(0,n("./Tracker/index.tsx")._h)((0,f.hp)((function(e){var t=e.restart,n=e.trackScreen,r=e.translate,s=[{icon:(0,a.h)(N,null),label:r("avc_no_face_detected.list_item_lighting")},{icon:(0,a.h)(T,null),label:r("avc_no_face_detected.list_item_eyes")},{icon:(0,a.h)(R,null),label:r("avc_no_face_detected.list_item_mask")},{icon:(0,a.h)(_,null),label:r("avc_no_face_detected.list_item_face")}];return(0,a.h)($.U,null,(0,a.h)(M.i,null,(0,a.h)(C.h,{title:r("avc_no_face_detected.title")},(0,a.h)(E.P,null)),(0,a.h)("ul",{className:v},b()(s).call(s,(function(e,t){return(0,a.h)("li",{className:w,key:t},e.icon," ",(0,a.h)("span",{className:k},e.label))})))),(0,a.h)(I.$,null,(0,a.h)(S.z,{onClick:function(){return n("no_face_detected_restart_clicked"),void t()}},r("avc_no_face_detected.button_primary_restart"))))})),"no_face_detected"),O=n("./components/Capture/withCrossDeviceWhenNoCamera.tsx"),D=n("./components/NavigationBar/index.tsx"),z=(0,f.hp)((0,O.Z)((0,y.Z)((0,g.Z)((function(e){var t=e.nextStep,n=e.back,s=e.translate,i=e.trackScreen,l=e.actions,u=e.mobileFlow,c=e.hasGrantedPermission,f=e.onUserMedia,g=e.onFailure,y=(0,o.useState)(),x=(0,r.Z)(y,2),b=x[0],v=x[1],w=(0,p.I0)();return b===h.FACE_DETECTION_TIMEOUT?(0,a.h)(F,{restart:function(){return v(null)},translate:s,trackScreen:i}):(b&&console.error("Unsupported error: ".concat(b)),(0,a.h)(d,{debug:!1,translate:s,track:function(e){i(e)},onError:function(e){e instanceof Error&&g?g(e):v(e)},onSuccess:function(e){var n={method:"activeVideo",blob:e.videoPayload,id:(0,A.kb)(),sdkMetadata:(0,m.I7)({captureMethod:"html5"},u)};w(l.createCapture(n)),t()},onUserMedia:f,hasGrantedPermission:!!c,navigationBar:(0,a.h)(D.ZP,{back:n,transparent:!0})}))})))))}}]);
//# sourceMappingURL=onfido.activeVideo.min.js.map